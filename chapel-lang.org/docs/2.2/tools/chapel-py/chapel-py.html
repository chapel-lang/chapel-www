<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>chapel-py &mdash; Chapel Documentation 2.2</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=b21de401"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Unstable Warning Anonymizer Script" href="../unstableWarningAnonymizer/unstableWarningAnonymizer.html" />
    <link rel="prev" title="Protocol Buffers Support in Chapel" href="../protoc-gen-chpl/protoc-gen-chpl.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.2
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.2";
$pagename = "tools/chapel-py/chapel-py";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#development">Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#interoperability">Interoperability</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#other">Other</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">chapel-py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usage">Usage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../unstableWarningAnonymizer/unstableWarningAnonymizer.html">Unstable Warning Anonymizer Script</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Tools</a></li>
      <li class="breadcrumb-item active">chapel-py</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/tools/chapel-py/chapel-py.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="chapel-py">
<span id="readme-chapel-py"></span><h1>chapel-py<a class="headerlink" href="#chapel-py" title="Link to this heading">¶</a></h1>
<p>Python bindings for Chapel’s frontend library, Dyno.</p>
<p>The purpose of this library is to allow programmers to easily create tools
for the Chapel programming language that would be more difficult to write
using C++ (the native language in which the Chapel frontend library is written).</p>
<p>For example, here’s a toy program that prints the names of all things declared
anywhere in <code class="docutils literal notranslate"><span class="pre">myfile.chpl</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">chapel</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
<span class="n">ast</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;myfile.chpl&quot;</span><span class="p">)</span>

<span class="n">all_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">ast</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NamedDecl</span><span class="p">):</span>
        <span class="n">all_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_names</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">myfile.chpl</span></code> contains the following:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">myfile</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then the program will print out something like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span>
<span class="n">y</span>
<span class="n">x</span>
<span class="n">myfile</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Chapel Python bindings are not yet fully mature. The API is subject to
change and is not considered stable. Users of this library should be prepared
to update their code as the library evolves.</p>
</div>
<section id="installation">
<span id="chapel-py-installation"></span><h2>Installation<a class="headerlink" href="#installation" title="Link to this heading">¶</a></h2>
<p>Make sure that you have a from-source build of Chapel available in your
<code class="docutils literal notranslate"><span class="pre">CHPL_HOME</span></code>. Currently, the build script also requires having LLVM available
in your path. The build script also requires that the development package of
Python be installed (for many package managers this is called
<code class="docutils literal notranslate"><span class="pre">python3-devel</span></code>). With those constraints met, you can just run <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">chapel-py-venv</span></code>:</p>
<p>This will allow you to use the Python bindings from a Python script run with
<code class="docutils literal notranslate"><span class="pre">$CHPL_HOME/util/config/run-in-venv-with-python-bindings.bash</span> <span class="pre">python3</span></code>,
instead of just <code class="docutils literal notranslate"><span class="pre">python3</span></code>. If you wish to install the Python bindings in your
system Python, run <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">$CHPL_HOME/tools/chapel-py</span></code>.</p>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>The library is split into several major components:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">chapel</span></code> module provides the AST node class hierarchy and the <code class="docutils literal notranslate"><span class="pre">Context</span></code>
object. It also provides some higher-level, pure Python implementations of
certain utility functions. For instance, it provides the <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and
<code class="docutils literal notranslate"><span class="pre">postorder</span></code> traversal iterators and a <code class="docutils literal notranslate"><span class="pre">match</span></code> function to perform AST
<a class="reference internal" href="#chapel-py-pattern-matching"><span class="std std-ref">pattern matching</span></a>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">chapel.replace</span></code> module provides the “replacer API”, which is intended
to perform transformations on existing Chapel files for various reasons. For
instance, deprecations and syntax changes can be performed automatically using
the replacer API, by finding AST patterns and performing string substitution.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">chapel.lsp</span></code> module provides a few helpers to transform Dyno types to
LSP (Language Server Protocol) types. This module requires the <a class="reference external" href="https://pypi.org/project/lsprotocol/">lsprotocol</a> package.</p></li>
</ul>
<section id="chapel">
<h3><code class="docutils literal notranslate"><span class="pre">chapel</span></code><a class="headerlink" href="#chapel" title="Link to this heading">¶</a></h3>
<p>The main entry point to the Chapel Python API is the <code class="docutils literal notranslate"><span class="pre">Context</span></code> object. This
is a wrapper around the C++ construct of the same name. The Context in Dyno
is responsible for memoizing computations, interning strings, and more. The
Python wrapper around this object has methods that can be used to get started
with processing Chapel programs; one such method is <code class="docutils literal notranslate"><span class="pre">parse</span></code>, which accepts
a file path and returns a list of Chapel AST nodes that represent this file.</p>
<p>At compile-time, <code class="docutils literal notranslate"><span class="pre">chapel-py</span></code> generates a class hierarchy of Python objects,
with base class <code class="docutils literal notranslate"><span class="pre">AstNode</span></code>. A class is created for each of the AST nodes understood
by Dyno. Thus, one might write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">chapel</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
<span class="n">asts</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;myfile.chpl&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;it&#39;s a module&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">asts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Module</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;it&#39;s not a module&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the Python <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> builtin is used to determine if the first
AST node returned by <code class="docutils literal notranslate"><span class="pre">parse</span></code> is a module (it should be!)</p>
<p>Because the AST nodes form a class hierarchy, it’s possible to perform a more
general check; the following example prints “It’s a loop!” for all loops
(<code class="docutils literal notranslate"><span class="pre">do</span></code>- <code class="docutils literal notranslate"><span class="pre">while</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">foreach</span></code>, etc.), and “It’s not a loop…” otherwise.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Loop</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a loop!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s not a loop...&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The AST nodes from the Python API are iterable; iterating over a node yields
its children. Thus, one might print all the declarations in a module as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_decls</span><span class="p">(</span><span class="n">mod</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">mod</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">NamedDecl</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
</pre></div>
</div>
<p>Full AST traversals can be built on top of this functionality. Below
is the definition for <code class="docutils literal notranslate"><span class="pre">postorder</span></code> from the <code class="docutils literal notranslate"><span class="pre">chapel</span></code> module:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively visit the given AST node, going in post-order (children-then-parent)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">postorder</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">node</span>
</pre></div>
</div>
<p>To find the list of available methods for each AST node class, the current best
practice is to consult the generated
<code class="docutils literal notranslate"><span class="pre">$CHPL_HOME/tools/chapel-py/src/chapel/core/__init__.pyi</span></code> file. This is
generated by default when the Python bindings are built and is the most
up-to-date source of information on the API.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">chapel</span></code> module also provides convenience functions for working with the library.
For instance, it provides the <code class="docutils literal notranslate"><span class="pre">postorder</span></code> and <code class="docutils literal notranslate"><span class="pre">preorder</span></code> iterators (the
implementation of the former is included above). It also provides a couple
of more advanced helpers for dealing with Chapel ASTs.</p>
<section id="chapel-parse-attribute">
<h4><code class="docutils literal notranslate"><span class="pre">chapel.parse_attribute</span></code><a class="headerlink" href="#chapel-parse-attribute" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">parse_attribute</span></code> function, given a “description” of an attribute (its
name and formal list), tries to parse an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> AST node. This function
accounts for named and unnamed actuals, reordering, etc. For instance, given
an “attribute schema”:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">attr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;doXYZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>And the following Chapel attribute:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">@</span><span class="nd">doXYZ</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="s">&quot;!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The function returns:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>This function is used in the <a class="reference internal" href="../chplcheck/chplcheck.html#readme-chplcheck"><span class="std std-ref">Chapel linter</span></a> to handle
silencing warnings:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ignores_rule</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">rulename</span><span class="p">):</span>
    <span class="n">ag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute_group</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">ag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">ag</span><span class="p">:</span>
        <span class="n">attr_call</span> <span class="o">=</span> <span class="n">chapel</span><span class="o">.</span><span class="n">parse_attribute</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">IgnoreAttr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr_call</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>

        <span class="n">ignored_rule</span> <span class="o">=</span> <span class="n">attr_call</span><span class="p">[</span><span class="s2">&quot;rule&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ignored_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ignored_rule</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">rulename</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</section>
<section id="chapel-match-pattern">
<span id="chapel-py-pattern-matching"></span><h4><code class="docutils literal notranslate"><span class="pre">chapel.match_pattern</span></code><a class="headerlink" href="#chapel-match-pattern" title="Link to this heading">¶</a></h4>
<p>This function provides general pattern matching functionality to enable users
of the Python API to rapidly find “interesting” locations in the AST. It
supports arbitrary levels of nesting, as well as “named variables” to easily
retrieve deeply nested AST nodes after a pattern has matched.</p>
<p>Generally, a call to <code class="docutils literal notranslate"><span class="pre">match_pattern</span></code> takes an AST node and a pattern (what
constitutes a pattern is explained below). If the pattern matches, the function
returns a Python <code class="docutils literal notranslate"><span class="pre">dict</span></code> that maps pattern variables to their corresponding
AST nodes; an empty <code class="docutils literal notranslate"><span class="pre">dict</span></code> is returned if no pattern variables were used. If
the pattern does not match, the function returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>To explain the possible patterns, it’s helpful to have an example AST.
We will use the following Chapel function, and its AST <code class="docutils literal notranslate"><span class="pre">myFn</span></code>, in the following
examples:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="o">+</span><span class="nx">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The simplest example of pattern is an AST class. For instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">chapel</span><span class="o">.</span><span class="n">match_pattern</span><span class="p">(</span><span class="n">myFn</span><span class="p">,</span> <span class="n">Function</span><span class="p">))</span> <span class="c1"># Prints &quot;{}&quot;</span>
</pre></div>
</div>
<p>When a function AST node <code class="docutils literal notranslate"><span class="pre">myFn</span></code> is matched against the <code class="docutils literal notranslate"><span class="pre">Function</span></code> pattern,
the match is successful; since no pattern variables were used, this results
in an empty dictionary <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
<p>A list can be used to represent patterns of AST nodes with children. To match a
function with exactly two arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">chapel</span><span class="o">.</span><span class="n">match_pattern</span><span class="p">(</span><span class="n">myFn</span><span class="p">,</span> <span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">Formal</span><span class="p">,</span> <span class="n">Formal</span><span class="p">,</span> <span class="n">Block</span><span class="p">]))</span> <span class="c1"># Prints &quot;{}&quot;</span>
</pre></div>
</div>
<p>Since we still haven’t used any pattern variables, the result of
<code class="docutils literal notranslate"><span class="pre">match_pattern</span></code> still returns <code class="docutils literal notranslate"><span class="pre">{}</span></code>. However, having matched the pattern, it
would be cumbersome to attempt to retrieve each of the two formals from the
list: we’d need to access the function’s children again, by their index. Since
<code class="docutils literal notranslate"><span class="pre">Formal</span></code> nodes are direct children of the <code class="docutils literal notranslate"><span class="pre">Function</span></code>, this isn’t too
inconvenient; however, conceivably, the nodes of interest could be further down
in the AST from the parent. This is where pattern variables come in. Instead of
writing <code class="docutils literal notranslate"><span class="pre">Formal</span></code>, we can write <code class="docutils literal notranslate"><span class="pre">(&quot;?f1&quot;,</span> <span class="pre">Formal)</span></code>. This will cause the
pattern matcher to save the AST node matching <code class="docutils literal notranslate"><span class="pre">Formal</span></code> into the variable
<code class="docutils literal notranslate"><span class="pre">f1</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;?f1&quot;</span><span class="p">,</span> <span class="n">Formal</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;?f2&quot;</span><span class="p">,</span> <span class="n">Formal</span><span class="p">),</span> <span class="n">Block</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">chapel</span><span class="o">.</span><span class="n">match_pattern</span><span class="p">(</span><span class="n">myFn</span><span class="p">,</span> <span class="n">pat</span><span class="p">))</span> <span class="c1"># Prints &quot;{ &#39;f1&#39;: ..., &#39;f2&#39;: ... }&quot;</span>
</pre></div>
</div>
<p>The dictionary returned by <code class="docutils literal notranslate"><span class="pre">match_pattern</span></code> can then be queried by the variables
to retrieve the formals.</p>
<p>We can further restrict our pattern to require formals with ‘simple’ type
expressions (identifiers).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="n">Formal</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">],</span> <span class="p">[</span><span class="n">Formal</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">],</span> <span class="n">Block</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">chapel</span><span class="o">.</span><span class="n">match_pattern</span><span class="p">(</span><span class="n">myFn</span><span class="p">,</span> <span class="n">pat</span><span class="p">))</span> <span class="c1"># Prints &quot;{}&quot;</span>
</pre></div>
</div>
<p>Pattern variables can still be used with list patterns like <code class="docutils literal notranslate"><span class="pre">[Formal,</span>
<span class="pre">Identifier]</span></code>. This is done by adding the pattern variable string to the front
of the list.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;?f1&quot;</span><span class="p">,</span> <span class="n">Formal</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;f2&quot;</span><span class="p">,</span> <span class="n">Formal</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">],</span> <span class="n">Block</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">chapel</span><span class="o">.</span><span class="n">match_pattern</span><span class="p">(</span><span class="n">myFn</span><span class="p">,</span> <span class="n">pat</span><span class="p">))</span> <span class="c1"># Prints &quot;{ &#39;f1&#39;: ..., &#39;f2&#39;: ... }&quot;</span>
</pre></div>
</div>
<p>Some other useful features of the pattern library:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">rest</span></code> pattern can be used as part of a list to indicate that you don’t
care about the remaining AST children, however many there are.</p></li>
<li><p>A variable without an AST node, (<code class="docutils literal notranslate"><span class="pre">&quot;?x&quot;</span></code>) can be used by itself to match any
AST node and store it in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">set</span></code> can be used to represent a disjunctive or pattern. For example,
<code class="docutils literal notranslate"><span class="pre">set([Begin,</span> <span class="pre">Cobegin])</span></code> will match either a <code class="docutils literal notranslate"><span class="pre">Begin</span></code> or a <code class="docutils literal notranslate"><span class="pre">Cobegin</span></code> node.</p></li>
</ul>
</section>
<section id="chapel-each-matching">
<h4><code class="docutils literal notranslate"><span class="pre">chapel.each_matching</span></code><a class="headerlink" href="#chapel-each-matching" title="Link to this heading">¶</a></h4>
<p>This function combines the operation of <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">match_pattern</span></code> to iterate
an AST and yield all nodes matching the given pattern. Concretely, given
a pattern, it yields the node and the variables resulting from the match.
The following snippet will print one line for each binary operation, listing
the operation itself and the operation’s two operands.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chapel</span><span class="o">.</span><span class="n">each_matching</span><span class="p">(</span><span class="n">myFn</span><span class="p">,</span> <span class="p">[</span><span class="n">OpCall</span><span class="p">,</span> <span class="s2">&quot;?l&quot;</span><span class="p">,</span> <span class="s2">&quot;?r&quot;</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found an operation &quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">op</span><span class="p">(),</span> <span class="s2">&quot;with operands: &quot;</span><span class="p">,</span> <span class="n">variables</span><span class="p">[</span><span class="s2">&quot;l&quot;</span><span class="p">],</span> <span class="n">variables</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>
<section id="chapel-replace">
<h3><code class="docutils literal notranslate"><span class="pre">chapel.replace</span></code><a class="headerlink" href="#chapel-replace" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">chapel.replace</span></code> module is used for writing “replacer scripts”. The motivation
for this module is evolving the Chapel language. As the language develops, we
tend to shift the patterns we prefer, and modify unstable language syntax. When
modifying existing code to match the new standards, we either have to perform
the changes manually, or resort to “general” tools like <code class="docutils literal notranslate"><span class="pre">sed</span></code> or <code class="docutils literal notranslate"><span class="pre">awk</span></code>. However,
the trouble with these tools is that they are suited for modifying streams of
text. When modifying programs in a language, it is more natural to work with
a structured representation – the AST. Thus, the <code class="docutils literal notranslate"><span class="pre">chapel.replacer</span></code> module
provides utilities to modify a file by traversing the ASTs contained within,
and generating a list of substitutions.</p>
<p>Although the AST is used to find places in the code where changes must be made,
the changes themselves are performed using string operation. This is motivated
by many reasons:</p>
<ul class="simple">
<li><p>Dyno does not have good support for modifying ASTs (they are immutable).</p></li>
<li><p>If an AST is modified, it should be printed back to the file with only those
modifications; however, this would require the Chapel syntax printer to
be able to preserve most of the original format of the text.</p></li>
<li><p>Writing plain code, such as <code class="docutils literal notranslate"><span class="pre">1+1</span></code>, is often easier than creating an AST node
(<code class="docutils literal notranslate"><span class="pre">PlusNode(IntNode(1),</span> <span class="pre">IntNode(1))</span></code>).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">chapel.replace</span></code> module provides a driver function <code class="docutils literal notranslate"><span class="pre">run</span></code>, which, when given
a source of changes (described below), takes over the execution of the program.
It registers and parses command line arguments, and handles file modifications.
Thus, given an AST traversal, you end up with a fully-featured command-line
script ready to be pointed at files.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>usage: replace [-h] [--suffix SUFFIX] [--in-place] [filenames ...]

A tool to search-and-replace Chapel expressions with others

positional arguments:
  filenames

options:
  -h, --help       show this help message and exit
  --suffix SUFFIX
  --in-place`
</pre></div>
</div>
<p>The ‘source of changes’ is a Python iterator that should accept two arguments:
<code class="docutils literal notranslate"><span class="pre">rc</span></code> (for ‘replacement context’) and <code class="docutils literal notranslate"><span class="pre">root</span></code> (for the AST node at which the
traversal begins). A very simple (albeit completely pointless and semantically
incorrect) example is the following script, which replaces all occurrences of
the number <code class="docutils literal notranslate"><span class="pre">42</span></code> with <code class="docutils literal notranslate"><span class="pre">meaningOfLife</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">replace_all_42</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">each_matching</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">text</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;42&#39;</span><span class="p">:</span> <span class="k">yield</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="s1">&#39;meaningOfLife&#39;</span><span class="p">)</span>

<span class="n">run</span><span class="p">(</span><span class="n">replace_all_42</span><span class="p">)</span>
</pre></div>
</div>
<p>A more practical example is renaming methods. Note that this is not
amenable to naive substitution: we don’t want to accidentally rename non-methods
that happen to have the same name, or even locally declared functions inside
other functions in a record or class. Consider renaming the <code class="docutils literal notranslate"><span class="pre">enterThis</span></code>
method to <code class="docutils literal notranslate"><span class="pre">enterContext</span></code> (this is a real change that was performed in
the Chapel language in 1.32, though it was not done automatically with the
help of this tool). In the following snippet, only the <code class="docutils literal notranslate"><span class="pre">proc</span></code> labeled <code class="docutils literal notranslate"><span class="pre">(1)</span></code>
should be renamed. This is because <code class="docutils literal notranslate"><span class="pre">enterThis</span></code> is actually a method. On
the other hand, <code class="docutils literal notranslate"><span class="pre">(2)</span></code>, even though it’s declared within <code class="docutils literal notranslate"><span class="pre">R</span></code>’s curly braces,
is actually a locally defined function, and not a method on <code class="docutils literal notranslate"><span class="pre">R</span></code>.
<code class="docutils literal notranslate"><span class="pre">(3)</span></code> is a freestanding function, and thus should also not be renamed.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
    <span class="k">proc</span> <span class="nf">enterThis</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// (1)</span>
    <span class="k">proc</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">proc</span> <span class="nf">enterThis</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// (2)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">enterThis</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// (3)</span>
</pre></div>
</div>
<p>This can be implemented using the following iterator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">replace_enter_this</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">each_matching</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;enterThis&quot;</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">is_method</span><span class="p">():</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">txt</span><span class="p">:</span> <span class="n">txt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;enterThis&quot;</span><span class="p">,</span> <span class="s2">&quot;enterContext&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>In this case, instead of yielding a pair of the node-to-replace and the
replacement text, the iterator produces a <code class="docutils literal notranslate"><span class="pre">lambda</span></code>, which will be fed the
node’s current string representation (<code class="docutils literal notranslate"><span class="pre">proc</span> <span class="pre">enterThis()</span> <span class="pre">{...</span></code>). Using
this lambda, we perform a simple substitution, renaming <code class="docutils literal notranslate"><span class="pre">enterThis</span></code> to
<code class="docutils literal notranslate"><span class="pre">enterContext</span></code> with Python’s regular <code class="docutils literal notranslate"><span class="pre">replace</span></code> method.</p>
<p>Finally, the following script was used to automatically insert interfaces into
records and classes that provided the corresponding functionality. It was
used to update about 150 files (including Chapel modules and tests). This
script implements the following features:</p>
<ul class="simple">
<li><p>Detecting particular signatures of the <code class="docutils literal notranslate"><span class="pre">init</span></code> method specific to deserialization</p></li>
<li><p>Always printing the supported interfaces in a specific order</p></li>
<li><p>Supporting both primary and secondary methods, including a mix of both</p></li>
<li><p>Adding a new interface list or modifying an existing one</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tag_aggregates_with_io_interfaces</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="n">aggrs_to_change</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">set</span><span class="p">())</span>
    <span class="n">names_to_tag</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">set</span><span class="p">())</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chapel</span><span class="o">.</span><span class="n">each_matching</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="o">.</span><span class="n">is_method</span><span class="p">():</span> <span class="k">continue</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;serialize&quot;</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;writeSerializable&quot;</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;deserialize&quot;</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;readDeserializable&quot;</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;init&quot;</span><span class="p">:</span>
            <span class="n">formal_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Formal</span><span class="p">):</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;this&quot;</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">formal_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">formal_names</span><span class="p">)</span> <span class="o">&gt;=</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">formal_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;deserializer&quot;</span> <span class="ow">and</span> <span class="n">formal_names</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;reader&quot;</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;initDeserializable&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">is_primary_method</span><span class="p">():</span>
            <span class="n">aggrs_to_change</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">unique_id</span><span class="p">()]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">this_receiver</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">this_formal</span><span class="p">()</span>
        <span class="n">names_to_tag</span><span class="p">[</span><span class="n">rc</span><span class="o">.</span><span class="n">node_exact_string</span><span class="p">(</span><span class="n">this_receiver</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_tag_str</span><span class="p">(</span><span class="n">tags</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;serializable&quot;</span>

        <span class="c1"># tags have a preferred order, so just use an if-else chain to make that work</span>
        <span class="n">the_order</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;writeSerializable&quot;</span><span class="p">,</span> <span class="s2">&quot;readDeserializable&quot;</span><span class="p">,</span> <span class="s2">&quot;initDeserializable&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">the_order</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chapel</span><span class="o">.</span><span class="n">each_matching</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">AggregateDecl</span><span class="p">):</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">unique_id</span><span class="p">()</span> <span class="ow">in</span> <span class="n">aggrs_to_change</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">|=</span> <span class="n">aggrs_to_change</span><span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">unique_id</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names_to_tag</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">|=</span> <span class="n">names_to_tag</span><span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">name</span><span class="p">()]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

        <span class="n">tag_str</span> <span class="o">=</span> <span class="n">build_tag_str</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="n">record_text</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">node_exact_string</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="n">curlypos</span> <span class="o">=</span> <span class="n">record_text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">)</span>
        <span class="n">colonpos</span> <span class="o">=</span> <span class="n">record_text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">colonpos</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">colonpos</span> <span class="o">&lt;</span> <span class="n">curlypos</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="n">record_text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; {&quot;</span> <span class="p">,</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">tag_str</span> <span class="o">+</span> <span class="s2">&quot; {&quot;</span> <span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="n">record_text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">record</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; : &quot;</span> <span class="o">+</span> <span class="n">tag_str</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">yield</span> <span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">new_text</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../protoc-gen-chpl/protoc-gen-chpl.html" class="btn btn-neutral float-left" title="Protocol Buffers Support in Chapel" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../unstableWarningAnonymizer/unstableWarningAnonymizer.html" class="btn btn-neutral float-right" title="Unstable Warning Anonymizer Script" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>