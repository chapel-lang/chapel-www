<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Loops &mdash; Chapel Documentation 2.2</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=b21de401"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Procedures" href="procedures.html" />
    <link rel="prev" title="Variables" href="variables.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.2
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.2";
$pagename = "primers/loops";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Primers</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#language-basics">Language Basics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Loops</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#serial-loops">Serial Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-loops">Parallel Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-parallel-loops">Data-Parallel Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-parallel-loops">Task-Parallel Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#closing-discussions">Closing Discussions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l3"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="specialMethods.html">Special Methods on Classes and Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericClasses.html">Generic Classes and Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="varargs.html">Variadic Arguments (var args)</a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="nothingVariables.html">Nothing Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="errorHandling.html">Error Handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#iterators">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#task-parallelism">Task Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#locality">Locality</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-parallelism">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interoperability">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#library-utilities">Library Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#numerical-libraries">Numerical Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-overview">Language Overview</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Primers</a></li>
      <li class="breadcrumb-item active">Loops</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/primers/loops.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="loops">
<span id="primers-loops"></span><h1>Loops<a class="headerlink" href="#loops" title="Link to this heading">¶</a></h1>
<p><a class="reference external" href="https://github.com/chapel-lang/chapel/blob/main/test/release/examples/primers/loops.chpl">View loops.chpl on GitHub</a></p>
<p>This primer teaches the loop forms supported by Chapel, both serial
and parallel.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>  <span class="c1">// enable access to the readln() call that we use below</span>
</pre></div>
</div>
<p>Like most imperative programming languages, Chapel supports loops.
A loop is designed to run the statement or statements making up its
body a number of times, where that number could be one or even zero.
Chapel supports traditional serial loops, which execute the loop’s
iterations one after another.  It also supports parallel loops in
which the loop’s iterations may run simultaneously using hardware
parallelism available in the target system.  This primer is designed
to introduce these loop forms and to provide guidance as to when
each might be appropriate.</p>
<p>First, let’s start with a quick survey of the loop forms before
going through them in detail.  Chapel supports:</p>
<ul>
<li><p><strong>while loops:</strong> <a class="reference internal" href="#while-loops"><span class="std std-ref">for arbitrary serial loops</span></a></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="nx">cond</span> <span class="k">do</span> <span class="o">..</span><span class="p">.</span><span class="nx">body</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
</li>
<li><p><strong>for loops:</strong> <a class="reference internal" href="#for-loops"><span class="std std-ref">for iterator-driven serial loops</span></a></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="o">..</span><span class="p">.</span><span class="nx">body</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
</li>
<li><p><strong>foreach loops:</strong> <a class="reference internal" href="#foreach-loops"><span class="std std-ref">for parallel loops implemented using hardware parallelism (e.g., vectorization)</span></a></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="o">..</span><span class="p">.</span><span class="nx">body</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
</li>
<li><p><strong>forall loops:</strong> <a class="reference internal" href="#forall-loops"><span class="std std-ref">for parallel loops implemented using software parallelism (e.g., threads)</span></a></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="o">..</span><span class="p">.</span><span class="nx">body</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
</li>
<li><p><strong>square-bracket loops:</strong> <a class="reference internal" href="#square-bracket-loops"><span class="std std-ref">as a shorthand for forall- or foreach-loops</span></a></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="o">..</span><span class="p">.</span><span class="nx">body</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
</li>
<li><p><strong>coforall loops:</strong> <a class="reference internal" href="#coforall-loops"><span class="std std-ref">for concurrent loops in which each iteration is executed by a distinct task</span></a></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">coforall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="o">..</span><span class="p">.</span><span class="nx">body</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
</li>
</ul>
<p>In addition to going through these loop forms in detail, this primer
also covers <a class="reference internal" href="#loops-arrs-doms"><span class="std std-ref">loops over arrays and domains</span></a>,
<a class="reference internal" href="#zip-iter"><span class="std std-ref">zippered iteration</span></a>, <a class="reference internal" href="#param-for-loops"><span class="std std-ref">fully unrolled for-loops</span></a>, <a class="reference internal" href="#loops-promotion"><span class="std std-ref">promotion</span></a>, <a class="reference internal" href="#race-conditions"><span class="std std-ref">race
conditions</span></a>, <a class="reference internal" href="#loop-nests"><span class="std std-ref">loop nests</span></a>,
<a class="reference internal" href="#loop-choice"><span class="std std-ref">when to use which loop form</span></a>, and <a class="reference internal" href="#common-loop-mistake"><span class="std std-ref">a common
performance mistake</span></a>.</p>
<section id="serial-loops">
<h2>Serial Loops<a class="headerlink" href="#serial-loops" title="Link to this heading">¶</a></h2>
<section id="while-loops">
<span id="id1"></span><h3>While Loops<a class="headerlink" href="#while-loops" title="Link to this heading">¶</a></h3>
<p>We’ll start with Chapel’s <em>while-loops</em>, which execute as long as a
boolean condition remains true.  While loops come in two forms, the
<code class="docutils literal notranslate"><span class="pre">while...</span></code> loop and the <code class="docutils literal notranslate"><span class="pre">do...while</span></code> loop.  These are similar to
their counterparts in other languages.</p>
<p>Here is a <code class="docutils literal notranslate"><span class="pre">while...</span></code> loop that will print and double an integer
<code class="docutils literal notranslate"><span class="pre">i</span></code> until its value exceeds 100:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the first while-loop, i is &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="nx">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the event that the loop body consists of only a single statement,
you can use the <code class="docutils literal notranslate"><span class="pre">do</span></code> keyword to define it rather than curly
brackets (a <em>compound statement</em>).  For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="k">do</span>
  <span class="nx">j</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;At the end of the second while-loop, j is &quot;</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
</pre></div>
</div>
<p>If you want to be sure to execute the loop body at least once,
you’ll typically want to use the <code class="docutils literal notranslate"><span class="pre">do...while</span></code> form:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the third while-loop, k is &quot;</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
  <span class="nx">k</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span>
</pre></div>
</div>
<p>One way in which Chapel’s <code class="docutils literal notranslate"><span class="pre">do...while</span></code> loops may differ from those
you’ve used in other languages is that the condition expression can
refer to symbols declared within the loop.  For example, the test
against <code class="docutils literal notranslate"><span class="pre">i</span></code> in the following loop refers to the local
per-iteration constant declared within the loop’s body rather than
the variable defined above to drive our first while-loop.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">do</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">readln</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the fourth while-loop, i is &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="for-loops">
<span id="id2"></span><h3>For Loops<a class="headerlink" href="#for-loops" title="Link to this heading">¶</a></h3>
<p>Chapel’s other serial loop form is the <em>for-loop</em>.  Here is a simple
for-loop that iterates over the integers 1 through 3, inclusive:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the first for-loop, i is &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Though this example may look and act a lot like the C loop <code class="docutils literal notranslate"><span class="pre">for</span>
<span class="pre">(i=1;</span> <span class="pre">i&lt;=3;</span> <span class="pre">i++)</span></code>, the way it works is somewhat different.
Specifically, in Chapel a for-loop always invokes a <em>serial
iterator</em>.  In more detail:</p>
<p>Chapel for-loops generally take the form: <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">[inds]</span> <span class="pre">in</span> <span class="pre">[expr]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">[expr]</span></code> is the <em>iterand expression</em> that the loop is
traversing.  When this iterand is a call to a Chapel iterator, the
loop will invoke that iterator.  If the iterand is a variable or
value of a given type, the loop invokes that type’s default serial
iterator method.  See the <a class="reference internal" href="iterators.html#primers-iterators"><span class="std std-ref">Iterators Primer</span></a> for more about defining iterators.</p>
<p>The iterand in the loop above is the range value <code class="docutils literal notranslate"><span class="pre">1..3</span></code>, so the
loop invokes the <code class="docutils literal notranslate"><span class="pre">range</span></code> type’s default serial iterator method,
which yields the range’s indices one at a time.  For more about
ranges, see the <a class="reference internal" href="ranges.html#primers-ranges"><span class="std std-ref">Ranges Primer</span></a>.</p>
<p>As values are yielded back to a for-loop, they are bound to the
loop’s <em>index variable(s)</em>.  In this case, the index variable is
<code class="docutils literal notranslate"><span class="pre">i</span></code>.  A for-loop’s index or indices are brand new identifiers
introduced by the loop, and each iteration of the loop can be
thought of as getting its own private copy of the index variable.</p>
<p>An implication of this is that the <code class="docutils literal notranslate"><span class="pre">i</span></code> variable in the loop above
is new and distinct from previous <code class="docutils literal notranslate"><span class="pre">i</span></code> variables that appeared
earlier in this primer.  Another implication is that a for-loop’s
index values will not be carried from one iteration of the loop to
the next, nor persist after the loop completes.  If you want such
behaviors, you’ll need to use a while-loop, or to declare additional
variables outside of the for-loop that will persist across
iterations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">range</span></code> type’s iterator yields its indices by <code class="docutils literal notranslate"><span class="pre">out</span></code> intent,
preventing the loop’s index variable <code class="docutils literal notranslate"><span class="pre">i</span></code> from being assigned
within the loop body.  In effect, the loop above can be thought of
as being equivalent to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the first for-loop, i is &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">{</span>
  <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the first for-loop, i is &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">{</span>
  <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the first for-loop, i is &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Other iterators may yield their indices using the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent,
permits the loop index variable to be modified.  We’ll see an
example of this in the next section.</p>
</section>
<section id="loops-over-arrays-and-domains">
<span id="loops-arrs-doms"></span><h3>Loops over Arrays and Domains<a class="headerlink" href="#loops-over-arrays-and-domains" title="Link to this heading">¶</a></h3>
<p>In addition to looping over ranges and explicit iterators, loops in
Chapel are commonly used to iterate over arrays or domains (see the
<a class="reference internal" href="arrays.html#primers-arrays"><span class="std std-ref">Arrays</span></a> and <a class="reference internal" href="domains.html#primers-domains"><span class="std std-ref">Domains</span></a>
Primers for details on these types).  When iterating over an array
variable, its serial iterator yields references to the array’s
elements, permitting them to be read or modified within the loop.
For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">,</span> <span class="mf">7.8</span><span class="p">];</span>

<span class="k">for</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">A</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The second for-loop is doubling &quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the second for-loop, A is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>When iterating over a domain, the corresponding index variable
represents a read-only copy of the domain’s indices:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">A</span><span class="p">.</span><span class="k">domain</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In the third for-loop, element &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="s">&quot; of A is &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For a multidimensional domain, the index variable will be a tuple,
and indices will be yielded in row-major order:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">Dom2D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span> <span class="nx">idx</span> <span class="kd">in</span> <span class="nx">Dom2D</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The fourth for-loop got index &quot;</span><span class="p">,</span> <span class="nx">idx</span><span class="p">,</span> <span class="s">&quot; from Dom2D&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Like other tuples in Chapel, such indices can be de-tupled into
their distinct components:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">Dom2D</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The fifth for-loop got row = &quot;</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="s">&quot; and col = &quot;</span><span class="p">,</span> <span class="nx">col</span><span class="p">);</span>
</pre></div>
</div>
<p>This last example also demonstrates that single-statement for-loops
can be declared using the <code class="docutils literal notranslate"><span class="pre">do</span></code> keyword, similar to what we saw
with while-loops above.</p>
</section>
<section id="zippered-for-loops">
<span id="zip-iter"></span><h3>Zippered For-Loops<a class="headerlink" href="#zippered-for-loops" title="Link to this heading">¶</a></h3>
<p>For-loops also support <em>zippered</em> iteration, in which multiple
iterand expressions are invoked in a coordinated manner, yielding
multiple indices.  For example, the following loop iterates over two
ranges and an array in a zippered manner:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">idx</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">8</span> <span class="k">by</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">A</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the first zippered for-loop, idx is &quot;</span><span class="p">,</span> <span class="nx">idx</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the iterands in a zippered loop need to have compatible
sizes and shapes.  In this case, each of the two ranges represent
four indices, and the array is 1-dimensional and has four elements,
so this is a legal zippering.</p>
<p>A zippered loop generates a tuple index, storing one component for
each iterand expression being zipped together.  As a result, in the
loop above, <code class="docutils literal notranslate"><span class="pre">idx</span></code> is a 3-tuple, where the first two components are
integers representing the indices yielded by <code class="docutils literal notranslate"><span class="pre">1..4</span></code> and <code class="docutils literal notranslate"><span class="pre">1..8</span> <span class="pre">by</span>
<span class="pre">2</span></code>, respectively; the third element refers to the elements of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Like other tuples, such indices can be de-tupled into their
distinct components in the loop header:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">8</span> <span class="k">by</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">A</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Within the second zippered for-loop, i, j, and a are: &quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">a</span><span class="p">));</span>
</pre></div>
</div>
<p>Zippered for-loops can iterate over an arbitrary number of iterand
expressions.</p>
</section>
<section id="statically-varying-unrolled-for-loops">
<span id="param-for-loops"></span><h3>Statically Varying (Unrolled) For-Loops<a class="headerlink" href="#statically-varying-unrolled-for-loops" title="Link to this heading">¶</a></h3>
<p>One last case to know about is that Chapel has a few for-loop forms
that support the ability to have distinct static types or values per
iteration.  This is achieved by unrolling the for-loop at
compile-time to create distinct copies of the loop body that
represent the different static properties.</p>
<p>The two primary ways to write such for-loops today are by iterating
over:</p>
<ul class="simple">
<li><p>a heterogeneous tuple</p></li>
<li><p>a range value whose low and high bounds are both <code class="docutils literal notranslate"><span class="pre">param</span></code> expressions and whose index variable is also declared as a <code class="docutils literal notranslate"><span class="pre">param</span></code>:</p></li>
</ul>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">tup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s">&quot;four&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="nx">t</span> <span class="kd">in</span> <span class="nx">tup</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;One component of &#39;tup&#39; has type &quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>

<span class="k">for</span> <span class="kd">param</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="nx">tup</span><span class="p">.</span><span class="nx">size</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Component &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="s">&quot; of &#39;tup&#39; has type &quot;</span><span class="p">,</span> <span class="nx">tup</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
</pre></div>
</div>
<p>For each of these loops, the compiler will fully unroll the loop,
and each copy of the loop body will be specialized to the types of
the tuple components (<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">real</span></code>, and <code class="docutils literal notranslate"><span class="pre">string</span></code>,
respectively).  The second loop will also be specialized to the
<code class="docutils literal notranslate"><span class="pre">param</span></code> values of <code class="docutils literal notranslate"><span class="pre">i</span></code> (0, 1, and 2, respectively).</p>
<p>This concludes this primer’s introduction to Chapel’s serial loop forms.</p>
</section>
</section>
<section id="parallel-loops">
<h2>Parallel Loops<a class="headerlink" href="#parallel-loops" title="Link to this heading">¶</a></h2>
<p>Next, let’s look at Chapel’s parallel loop forms, all of which are
written very similarly to the serial for-loops shown above, simply
using different keywords.  Specifically, each parallel loop form
supports per-iteration index variables, zippered iteration, a <code class="docutils literal notranslate"><span class="pre">do</span></code>
keyword form for single-statement bodies, etc., just like the
for-loop.</p>
<p>A key property of parallel loops in Chapel is that the programmer is
asserting that the loop’s iterations are order-independent and that
they can/should execute in parallel.  The Chapel compiler will take
the programmer’s word for this and do its best to implement the loop
in parallel rather than trying to prove that the loop is
parallel-safe or race-free before doing so.  As a result, it is
possible for a user to write parallel loops that contain races or
are otherwise unsafe, though Chapel’s design reduces the chances of
inadvertently doing so.</p>
<p>In the following discussion, we’ll divide Chapel’s parallel loop
forms into two categories: data-parallel loops (e.g., <code class="docutils literal notranslate"><span class="pre">foreach</span></code>
and <code class="docutils literal notranslate"><span class="pre">forall</span></code>) and task-parallel loops (<code class="docutils literal notranslate"><span class="pre">coforall</span></code>).</p>
</section>
<section id="data-parallel-loops">
<h2>Data-Parallel Loops<a class="headerlink" href="#data-parallel-loops" title="Link to this heading">¶</a></h2>
<p>Data-parallel loops in Chapel can be thought of as indicating “the
iterations of this loop can, and should, be performed in parallel.”
Unlike task-parallel loops, the specifics of how a data-parallel
loop will be parallelized are abstracted away from the loop, as we
will see.</p>
<p>Because the specific implementation of a data-parallel loop is
abstract, the programmer shouldn’t assume anything about the amount
of parallelism that will be used to implement the loop, nor how its
iterations will be parallelized or scheduled.  The loop could even
be executed completely serially like a for-loop.  For these reasons,
performing any sort of blocking or synchronized operation between
distinct iterations of a single data-parallel loop would violate the
order-independent property and not be a legal use case (however,
using a task-parallel loop in such cases may be more appropriate, as
we will see).</p>
<section id="foreach-loops">
<span id="id3"></span><h3>Foreach Loops<a class="headerlink" href="#foreach-loops" title="Link to this heading">¶</a></h3>
<p>The first, and simplest, data-parallel loop is the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop.
This loop form asserts that the loop meets the order-independent and
unsynchronized properties above, and specifies that its iterations
should be implemented using hardware parallelism if possible.  When
executing a foreach-loop on a conventional processor or GPU, the
compiler will attempt to implement its iterations using any hardware
SIMD/SIMT parallelism that’s available.  For example, if executing
the loop on a processor with vector instructions, it will attempt to
implement the loop using those instructions if possible.  Notably, a
foreach-loop will not implement its iterations using multiple Chapel
tasks or software threads (the forall-loop, below, does this).</p>
<p>Syntactically, foreach-loops are identical to for-loops, simply
using the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> keyword.  For example, the following
<code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop will double the values of the array <code class="docutils literal notranslate"><span class="pre">A</span></code> declared
above:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">A</span> <span class="k">do</span>
  <span class="nx">a</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After our first foreach-loop, A is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>Because each iteration is performing its own operations on its own
elements of A, this loop is trivially parallel-safe, and completely
reasonable to write using <code class="docutils literal notranslate"><span class="pre">foreach</span></code>.  When running the computation
on a processor that supports vector instructions for performing
floating point multiplications, the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> keyword’s assertion
that the loop is legal to parallelize improves the compiler’s
ability to implement the loop using those instructions.</p>
<p>Like the for-loops above, Chapel’s foreach-loops support zippered
iteration.  For example, the following loop performs a zippered
iteration over the array <cite>A</cite> and an unbounded range <cite>1..</cite>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">a</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">);</span>

 <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After our first zippered foreach-loop, A is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that if a Chapel program only used foreach-loops to express its
parallelism, it would never make use of the multiple processor cores
of a modern processor nor the distinct compute nodes of a cluster or
HPC system.  This is because foreach-loops don’t ever introduce new
Chapel tasks, and tasks are the only way to run in parallel at
system scales beyond a single processor core.  As a result, to
leverage the full power of most parallel platforms, we need to look
to Chapel’s other parallel loop forms.</p>
</section>
<section id="forall-loops">
<span id="id4"></span><h3>Forall Loops<a class="headerlink" href="#forall-loops" title="Link to this heading">¶</a></h3>
<p>Forall-loops are similar to foreach-loops, except that they have the
potential to be implemented using multiple Chapel tasks.  This
permits them to use multiple cores and/or compute nodes to execute
the loop’s iterations.</p>
<p>Just as Chapel’s for-loops invoke a serial iterator, its
forall-loops invoke a parallel iterator.  Where serial iterators may
only yield values sequentially, a parallel iterator’s yield
statements may occur within parallel loops and constructs, resulting
in parallel execution.  When using a forall-loop with zippered
iterands, the first iterand in the zippering controls the loop’s
parallelism.  For details about writing such parallel iterators, see
the <a class="reference internal" href="parIters.html#primers-pariters"><span class="std std-ref">Parallel Iterators Primer</span></a>.</p>
<p>A parallel iterator can create as many tasks as it wants, and can
specify where they should run.  By convention, most will create as
many tasks as are appropriate for the hardware parallelism that the
loop iterand targets.  For example, the default parallel iterator
for a range, local domain, or local array typically implements its
iterations using a number of tasks equal to the number of local
processor cores that are available, since those data structures are
stored on a single locale.  In contrast, the default parallel
iterator for a distributed domain or array will typically implement
the iterations using all of the available processor cores on all of
the locales that own a subset of the domain’s indices or array’s
elements.</p>
<p>The task that originally encountered the forall-loop will not
proceed past the loop until all tasks created by the parallel
iterator to run the loop’s iterations have completed.  Logically,
you can think of there as being a <em>join</em> operation on all tasks that
are helping to implement the forall-loop.</p>
<p>Looking at some simple examples, when run on a k-core processor,
each of the following loops will typically use <code class="docutils literal notranslate"><span class="pre">k</span></code> tasks to
implement the loop’s iterations in parallel (at least, when <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span>
<span class="pre">n</span></code>):</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">B</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>


<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span>
  <span class="nx">B</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the forall loop over a range, B is: &quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">);</span>


<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">B</span><span class="p">.</span><span class="k">domain</span> <span class="k">do</span>
  <span class="nx">B</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">A</span><span class="p">.</span><span class="nx">size</span><span class="p">];</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the forall loop over a domain, B is: &quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">);</span>


<span class="k">forall</span> <span class="nx">b</span> <span class="kd">in</span> <span class="nx">B</span> <span class="k">do</span>
  <span class="nx">b</span> <span class="o">=</span> <span class="o">-</span><span class="nx">b</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the forall loop over an array, B is: &quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">);</span>
</pre></div>
</div>
<p>Note the presence of the <code class="docutils literal notranslate"><span class="pre">with</span></code>-clause in the first two loops
above.  By default, variables declared outside of a parallel loop in
Chapel, like <code class="docutils literal notranslate"><span class="pre">B</span></code> here, will be represented by a <code class="docutils literal notranslate"><span class="pre">const</span></code> shadow
version of the variable within the loop itself.  This is designed to
avoid inadvertent race conditions within the loop, by preventing
multiple iterations of the loop from writing to the same variable
simultaneously.  As a result, if it is your intention to modify the
variable, using a <code class="docutils literal notranslate"><span class="pre">with</span></code>-clause is a way to say how that variable
should be made available to the loop.</p>
<p>In the cases above that want to write to <code class="docutils literal notranslate"><span class="pre">B</span></code>’s elements using
<code class="docutils literal notranslate"><span class="pre">B[i]</span></code>, the shadow variable for <code class="docutils literal notranslate"><span class="pre">B</span></code> would prevent such
assignments since it is <code class="docutils literal notranslate"><span class="pre">const</span></code>.  So we override that behavior
using the <code class="docutils literal notranslate"><span class="pre">with</span></code>-clauses to say that <code class="docutils literal notranslate"><span class="pre">B</span></code> should be made
available to the loop body by reference (<code class="docutils literal notranslate"><span class="pre">ref</span></code>).  For more
information on task intents and <code class="docutils literal notranslate"><span class="pre">with</span></code>-clauses, refer to the
<a class="reference internal" href="forallLoops.html#primers-forallloops"><span class="std std-ref">Forall Loops</span></a> and <a class="reference internal" href="taskParallel.html#primers-taskparallel"><span class="std std-ref">Task Parallelism</span></a> primers.</p>
<p>Note, however, that when we’re looping over the array itself, as in
the last forall-loop above or the foreach-loops in the previous
section, there’s no need for such an intent because we’re not
modifying the shadow variable of something declared outside the
loop; instead, it’s just the loop’s indices themselves, which do not
receive shadow variables since they are already private to the
iteration, and therefore not amenable to races.</p>
<p>Next, let’s consider some forall-loops over distributed domains and
arrays.  When we iterate over a domain or array that’s distributed
across multiple locales, each with <code class="docutils literal notranslate"><span class="pre">k</span></code> cores, each locale will
tend to use its <code class="docutils literal notranslate"><span class="pre">k</span></code> cores to iterate over the subset of the domain
or array that it owns locally:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">BlockDist</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">BlockDom</span> <span class="o">=</span> <span class="nx">blockDist</span><span class="p">.</span><span class="nx">createDomain</span><span class="p">({</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">});</span>
<span class="kd">var</span> <span class="nx">C</span><span class="p">:</span> <span class="p">[</span><span class="nx">BlockDom</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>

<span class="k">forall</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">BlockDom</span> <span class="k">do</span>
  <span class="nx">C</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">here</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the forall loop over a distributed domain, C is:\n&quot;</span><span class="p">,</span><span class="nx">C</span><span class="p">);</span>

<span class="k">forall</span> <span class="nx">c</span> <span class="kd">in</span> <span class="nx">C</span> <span class="k">do</span>
  <span class="nx">c</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the forall loop over a distributed array, C is:\n&quot;</span><span class="p">,</span> <span class="nx">C</span><span class="p">);</span>
</pre></div>
</div>
<p>Because forall-loops invoke parallel iterators, the tasks they
create and where they run are not defined by the Chapel language,
but by the iterators themselves.  Any type supporting parallel
iteration should describe how its parallel iterators work as part of
its user-facing documentation.  For more about distributed domains
and arrays or parallel iterators, refer to the
<a class="reference internal" href="distributions.html#primers-distributions"><span class="std std-ref">Distributions</span></a> and <a class="reference internal" href="parIters.html#primers-pariters"><span class="std std-ref">Parallel Iterators</span></a> primers.</p>
</section>
<section id="square-bracket-loops">
<span id="id5"></span><h3>Square-Bracket Loops<a class="headerlink" href="#square-bracket-loops" title="Link to this heading">¶</a></h3>
<p>A third data-parallel loop form uses square brackets to define the
loop instead of the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> or <code class="docutils literal notranslate"><span class="pre">forall</span></code> keywords.  For
example, such a loop may look like:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="nx">B</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.001</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the first square bracket loop, B is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">);</span>

<span class="p">[</span><span class="nx">c</span> <span class="kd">in</span> <span class="nx">C</span><span class="p">]</span> <span class="nx">c</span> <span class="o">-=</span> <span class="mf">0.001</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the second square bracket loop, C is:\n&quot;</span><span class="p">,</span> <span class="nx">C</span><span class="p">);</span>
</pre></div>
</div>
<p>In this loop form, the square brackets can be thought of as
replacing the <code class="docutils literal notranslate"><span class="pre">for[each|all]</span></code> and <code class="docutils literal notranslate"><span class="pre">do</span></code> keywords, respectively.
This loop is both a shorthand for a data parallel loop, while also
supporting a “sliding scale” of parallelism.  Specifically, it will
be equivalent to a <code class="docutils literal notranslate"><span class="pre">forall</span></code> loop if its iterand has/is a parallel
iterator, and a <code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop otherwise.</p>
</section>
<section id="promotion-and-data-parallel-loops">
<span id="loops-promotion"></span><h3>Promotion and Data-Parallel Loops<a class="headerlink" href="#promotion-and-data-parallel-loops" title="Link to this heading">¶</a></h3>
<p>In Chapel, an operator or procedure accepting a formal argument of
type <code class="docutils literal notranslate"><span class="pre">t</span></code> can be <em>promoted</em> by invoking the procedure with:</p>
<ul class="simple">
<li><p>an array whose elements are of type <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p>a range or domain whose indices are of type <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
</ul>
<p>Such promotions are equivalent to <code class="docutils literal notranslate"><span class="pre">forall</span></code> loops that iterate over
each of the promoted actual arguments in a zippered manner, passing
the respective elements into the operator or procedure.  For
example, given the procedure:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">t</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="nx">d</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">foo</span><span class="p">(</span><span class="nx">C</span><span class="p">,</span> <span class="nx">BlockDom</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the promoted call to foo(), C is:\n&quot;</span><span class="p">,</span> <span class="nx">C</span><span class="p">);</span>
</pre></div>
</div>
<p>is equivalent to the forall-loop:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">ij</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">C</span><span class="p">,</span> <span class="nx">BlockDom</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">foo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">ij</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the equivalent zippered forall loop, C is:\n&quot;</span><span class="p">,</span> <span class="nx">C</span><span class="p">);</span>
</pre></div>
</div>
<p>As a result, the parallel calls to <code class="docutils literal notranslate"><span class="pre">foo()</span></code> will be executed using
the available processor cores on each of the locales that own a
portion of <code class="docutils literal notranslate"><span class="pre">C</span></code> since <code class="docutils literal notranslate"><span class="pre">C</span></code> is the first iterand in the <cite>zip</cite>
expression.</p>
</section>
<section id="a-final-note-on-data-parallel-loops-and-legality-races">
<span id="race-conditions"></span><h3>A final note on data-parallel loops and legality / races<a class="headerlink" href="#a-final-note-on-data-parallel-loops-and-legality-races" title="Link to this heading">¶</a></h3>
<p>As mentioned previously, the Chapel compiler and language are not
responsible for making sure that a data-parallel loop is safe to
execute in parallel.  Shadow variables reduce the chances of an
accidental race, but do not protect against them.  If a programmer
writes a data-parallel loop that is not parallel-safe or that
creates a race, the outcome is their responsibility, not Chapel’s.</p>
<p>As an example, the following loop may appear to replace the interior
elements of an array with the average of their neighbors; yet,
because the same elements may be read and written simultaneously by
distinct parallel iterations, the results will be unpredictable
depending on how the iterations are scheduled at execution-time:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">(</span><span class="nx">i</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span> <span class="kt">real</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Before the race-y averaging loop, D is: &quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">);</span>
<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">2</span><span class="o">..&lt;</span><span class="nx">n</span> <span class="k">do</span>
  <span class="nx">D</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">D</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">D</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// if the following line were uncommented, you would likely see</span>
<span class="c1">// different results after each execution of the program:</span>
<span class="c1">//</span>
<span class="c1">// writeln(&quot;After the race-y averaging loop, D is: &quot;, D);</span>
</pre></div>
</div>
<p>The programmer is still permitted to write such loops in Chapel, and
the compiler will dutifully implement them as requested; but it will
not protect the user from such races.</p>
<p>One way to write the averaging computation above in a correct, but
still parallel, manner would be to store the results into a distinct
array to avoid reading and writing the same elements within a single
parallel loop:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">E</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">(</span><span class="nx">i</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span> <span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">F</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Before the safe averaging loop, E is: &quot;</span><span class="p">,</span> <span class="nx">E</span><span class="p">);</span>

<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">2</span><span class="o">..&lt;</span><span class="nx">n</span> <span class="k">do</span>
  <span class="nx">F</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">E</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">E</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the safe averaging loop, F is: &quot;</span><span class="p">,</span> <span class="nx">F</span><span class="p">);</span>
</pre></div>
</div>
<p>Part of the reason the Chapel compiler does not prevent writing
parallel loops with races is that it can be difficult to determine
whether a given loop is safe to parallelize or not.  For example,
the following variation on the original loop would be safe since it
only writes to even elements and reads from odd ones:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">D</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">(</span><span class="nx">i</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span> <span class="kt">real</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Before the third averaging loop, D is: &quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">);</span>
<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">2</span><span class="o">..&lt;</span><span class="nx">n</span> <span class="k">by</span> <span class="mi">2</span> <span class="k">do</span>
  <span class="nx">D</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">D</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">D</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the third averaging loop, D is: &quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">);</span>
</pre></div>
</div>
<p>Distinguishing between loops that are parallel-safe versus not is
generally intractable, so rather than attempting to make that
judgment, Chapel trusts the programmer to use the loop form they
want.  Moreover, for some parallel computations, race conditions can
be benign, acceptable, or desirable; and Chapel does not want to
prevent users from writing such computations.</p>
<p>An important thing to remember about Chapel’s forall-loops is that
they are essentially invocations of parallel iterators.  In
practice, those parallel iterators are themselves often written in
terms of the data-parallel loop forms above, or the more explicit
task-parallel coforall-loops that we’ll cover next.</p>
</section>
</section>
<section id="task-parallel-loops">
<h2>Task-Parallel Loops<a class="headerlink" href="#task-parallel-loops" title="Link to this heading">¶</a></h2>
<p>Chapel has a single task-parallel loop form, the <code class="docutils literal notranslate"><span class="pre">coforall</span></code> loop:</p>
<section id="coforall-loops">
<span id="id6"></span><h3>Coforall Loops<a class="headerlink" href="#coforall-loops" title="Link to this heading">¶</a></h3>
<p>In most respects, the coforall-loop is the simplest parallel loop
form to explain in Chapel.  It literally creates a distinct Chapel
task for each iteration of the loop; it then waits until each of
those tasks has completed executing its copy of the loop body before
proceeding.  Mnemonically, <code class="docutils literal notranslate"><span class="pre">coforall</span></code> can be thought of as a
“concurrent forall loop”.  For example, the following coforall loop
will create four tasks, one for each iteration of the loop:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">numTasks</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">total</span><span class="p">:</span> <span class="k">atomic</span> <span class="kt">int</span><span class="p">;</span>

<span class="k">coforall</span> <span class="nx">tid</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">numTasks</span> <span class="k">do</span>
  <span class="nx">total</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">tid</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The total of the integers 1..&quot;</span><span class="p">,</span> <span class="nx">numTasks</span><span class="p">,</span> <span class="s">&quot; is &quot;</span><span class="p">,</span> <span class="nx">total</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span>
</pre></div>
</div>
<p>Because each iteration is executed by a separate task,
coforall-loops can synchronize between distinct iterations of the
loop, unlike the data-parallel loop forms.  This makes
coforall-loops useful as a means of creating an arbitrary number of
tasks that are independently doing the same, or similar, things.  In
practice, the parallel iterators used to define <code class="docutils literal notranslate"><span class="pre">forall</span></code> loops are
often implemented in terms of coforall-loops that create a task per
processor core and/or locale.  As an example, the following
coforall-loop creates a task per processor core across all locales:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">coforall</span> <span class="nx">loc</span> <span class="kd">in</span> <span class="nx">Locales</span> <span class="p">{</span>
  <span class="k">on</span> <span class="nx">loc</span> <span class="p">{</span>
    <span class="k">coforall</span> <span class="nx">tid</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">here</span><span class="p">.</span><span class="nx">maxTaskPar</span> <span class="p">{</span>
      <span class="c1">// ``here.maxTaskPar`` queries the number of parallel tasks</span>
      <span class="c1">// that can run on this locale, and it is typically equal to the</span>
      <span class="c1">// number of local processor cores.  So this loop body will be</span>
      <span class="c1">// executed once per core per locale.</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For further information about tasks in Chapel, see the <a class="reference internal" href="taskParallel.html#primers-taskparallel"><span class="std std-ref">Task
Parallelism Primer</span></a>.</p>
<p>When using coforall loops, keep in mind that a task will be created
for each iteration, and that each task will consume memory and
processing resources.  For example, a coforall loop with a million
iterations will literally create a million tasks.  If you don’t have
a million cores to run them on, this is likely to be overkill,
requiring more memory and processing power than is warranted..  If
there is no explicit synchronization between the iterations, a
forall loop is typically a better choice, since it would use a
number of tasks proportional to the targeted hardware parallelism.</p>
</section>
</section>
<section id="closing-discussions">
<h2>Closing Discussions<a class="headerlink" href="#closing-discussions" title="Link to this heading">¶</a></h2>
<p>At this point, you’ve learned about all of Chapel’s loop forms.  The
remaining sections cover some loop-related topics that may come up
in practice.</p>
<section id="nesting-loops">
<span id="loop-nests"></span><h3>Nesting Loops<a class="headerlink" href="#nesting-loops" title="Link to this heading">¶</a></h3>
<p>The loop forms discussed here can be nested arbitrarily, and their
definitions are the same whether they are an outer or inner loop.  A
nested for-loop will perform nested serial iterations as in other
languages.  A nested coforall-loop will create a number of tasks
equal to the outer loop’s trip count and the sum of all the inner
loops’ counts.  For example, the following loop will create around
<code class="docutils literal notranslate"><span class="pre">x**2</span></code> tasks, since each iteration of each loop will create its
own task.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">();</span>
<span class="k">coforall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">x</span> <span class="k">do</span>
  <span class="k">coforall</span> <span class="nx">j</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">x</span> <span class="k">do</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Here&#39;s a message from one of the nested coforall tasks&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>A tricky case to reason about in a nested loop situation is the
forall-loop since its implementation is essentially “Do whatever the
parallel iterator says.”  If a parallel iterator were to always
create <code class="docutils literal notranslate"><span class="pre">x</span></code> tasks (say), then a nested forall loop invoking that
iterator in both loops would create roughly <code class="docutils literal notranslate"><span class="pre">x**2</span></code> tasks as in the
coforall example above.</p>
<p>In practice, however, most parallel iterators (including those
defined on ranges, domains, and arrays) will take stock of the
number of tasks running on the current locale and then throttle the
number of tasks they create to avoid overwhelming the node.  As a
result, a nested forall-loop over a pair of ranges, like:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">500</span> <span class="p">{</span>
  <span class="k">forall</span> <span class="nx">j</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">500</span> <span class="p">{</span>
    <span class="c1">// do some computation here</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will typically create only <code class="docutils literal notranslate"><span class="pre">numCores</span></code> tasks in total.
Specifically, the outer loop will create <code class="docutils literal notranslate"><span class="pre">numCores</span></code> tasks, then
each of the inner loops will see that all the cores are busy and
avoid creating additional tasks since there is nowhere to run them.</p>
<p>In such cases, if the inner loop body was not computationally
intensive, it could make sense to rewrite the inner loop as a
<code class="docutils literal notranslate"><span class="pre">foreach</span></code> in order to avoid the overhead of having the iterator
determine whether or not to create tasks at all:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">500</span> <span class="p">{</span>
  <span class="k">foreach</span> <span class="nx">j</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">500</span> <span class="p">{</span>
    <span class="c1">// do some computation here</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That said, such overheads are relatively modest, so for loop bodies
that are computationally intensive, the benefit of changing the
inner loop from <code class="docutils literal notranslate"><span class="pre">forall</span></code> to <code class="docutils literal notranslate"><span class="pre">foreach</span></code> may be negligible.</p>
<p>In summary, there is nothing magical about nested loops.  When
reasoning about what a given loop nest does, consider the loops one
at a time.  For example, what does the outer loop do?  (“It’s a
<code class="docutils literal notranslate"><span class="pre">forall</span></code>, so it will invoke the parallel iterator specified by its
iterand.”)  OK, what about the next loop?  (“It’s a <cite>coforall</cite>, so
it will literally create a task per iteration regardless of how many
are already running).  What about the next loop?  (“It’s a
<code class="docutils literal notranslate"><span class="pre">foreach</span></code>, so it will try to use hardware features in the task’s
current target processor to implement its iterations”).  Chapel’s
implementation of parallel loops is very imperative, where the most
complex case is being familiar with the parallelism implemented by
any iterand expressions of a <code class="docutils literal notranslate"><span class="pre">forall</span></code> loop.</p>
</section>
<section id="when-to-use-which-loop-form">
<span id="loop-choice"></span><h3>When to Use Which Loop Form?<a class="headerlink" href="#when-to-use-which-loop-form" title="Link to this heading">¶</a></h3>
<p>Given these various loop forms, which ones should you use when?</p>
<p>Starting with the obvious, if you have a loop that wants or needs to
be serial, such as a loop spanning the time steps of a simulation,
you should use one of the serial loop forms.  When writing a serial
loop, if you are iterating over a type that supports iteration, like
an array, domain, range, or list, the for-loop can often be the
clearest and most elegant loop form.  Or, if a serial iterator
exists that does what you want, invoking it with a for-loop is also
an obvious choice.  But if you want to do something more general
that is not currently supported by an iterator, the while-loop can
serve as a more general fallback.  Or you might want to write an
iterator of your own that wraps your unique serial loop structure,
and then use a for-loop to invoke it.  Refer to the <a class="reference internal" href="iterators.html#primers-iterators"><span class="std std-ref">Iterators
Primer</span></a> for more information about doing this.</p>
<p>When choosing between the parallel loop forms, one consideration
should be how many iterations the loop has.  For example, if you’re
iterating over an array with a million elements, you typically
wouldn’t want to use a coforall-loop, since that would literally
create a million tasks.  Unless you happen to have a million
processor cores, this is probably overkill.  And even if you do have
a million cores, each would only own one element; so if your loop’s
body was not computationally intensive, you may spend more time
creating and destroying tasks than actually getting useful work
done.  In such cases, the forall- or foreach-loops could be a better
choice since they will create parallelism proportional to the
computational resources that are storing the array.</p>
<p>Another consideration is whether you require synchronization or
coordination between distinct iterations of the loop.  If you do,
the coforall-loop is probably the right choice since it’s the only
one that permits inter-iteration coordination, since each iteration
will be executed by a distinct task.  When you do not require
synchronization between iterations, the forall-loop or
square-bracket loop are generally good defaults to reach for since
they will make best use of the hardware parallelism corresponding to
the iterand expression.  The foreach loop can serve as an
alternative if you know that you’re already running a number of
tasks that will saturate your hardware parallelism, or if the loop
itself is of sufficiently modest size or computational intensity
that creating new tasks to execute it would be overkill.</p>
</section>
<section id="a-common-performance-mistake">
<span id="common-loop-mistake"></span><h3>A Common Performance Mistake<a class="headerlink" href="#a-common-performance-mistake" title="Link to this heading">¶</a></h3>
<p>Wrapping up, one of Chapel’s most powerful features — the fact that
forall loops can generate distributed memory parallelism in addition
to local, multi-core parallelism — can also be the cause of simple
errors that can kill performance.  When writing forall-loops, it is
important to consider the iterand expression and what computational
resources it will use.  Here is an example that illustrates how
things can go wrong:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a block-distributed array G</span>
<span class="kd">var</span> <span class="nx">G</span> <span class="o">=</span> <span class="nx">blockDist</span><span class="p">.</span><span class="nx">createArray</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="c1">// attempt (but fail) to iterate over G&#39;s elements in a parallel,</span>
<span class="c1">// distributed manner</span>
<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="k">do</span>
  <span class="nx">G</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After the non-distributed forall, G is: &quot;</span><span class="p">,</span> <span class="nx">G</span><span class="p">);</span>
</pre></div>
</div>
<p>While the code, as written, will work properly, the comment is
incorrect in expecting that the computation will be distributed.
Specifically, even though <code class="docutils literal notranslate"><span class="pre">G</span></code> is distributed and accessed within
the loop, the forall loop’s iterand is a range and ranges are not
distributed.  As a result, the range’s default iterator method will
only consider the local cores when deciding how many tasks to create
and where to run them.  The loop’s body will still be able to update
the remote elements of <code class="docutils literal notranslate"><span class="pre">G</span></code> by virtue of Chapel’s global namespace.</p>
<p>We can see that this is the case by storing the ID of the locale
that executes each iteration into G:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="k">do</span>
  <span class="nx">G</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">here</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The locales assigning to G (range version) were: &quot;</span><span class="p">,</span> <span class="nx">G</span><span class="p">);</span>
</pre></div>
</div>
<p>In order to get the correct behavior, we’d need to iterate over
something distributed instead, like G itself:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">G</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// reset G</span>

<span class="k">forall</span> <span class="nx">g</span> <span class="kd">in</span> <span class="nx">G</span> <span class="k">do</span>
  <span class="nx">g</span> <span class="o">=</span> <span class="nx">here</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The locales assigning to G (array version) were: &quot;</span><span class="p">,</span> <span class="nx">G</span><span class="p">);</span>
</pre></div>
</div>
<p>Or its domain, which is also distributed:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">G</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// reset G</span>

<span class="k">forall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">G</span><span class="p">.</span><span class="k">domain</span> <span class="k">do</span>
  <span class="nx">G</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">here</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The locales assigning to G (domain version) were: &quot;</span><span class="p">,</span> <span class="nx">G</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition to iterating over arrays and domains, iterating over
slices of arrays and domains is another technique for making sure
your forall-loop computations maintain locality and affinity.  For
example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">G</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// reset G</span>

<span class="k">forall</span> <span class="nx">g</span> <span class="kd">in</span> <span class="nx">G</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="nx">G</span><span class="p">.</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">do</span>
  <span class="nx">g</span> <span class="o">=</span> <span class="nx">here</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;The locales assigning to a slice of G were: &quot;</span><span class="p">,</span> <span class="nx">G</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="nx">G</span><span class="p">.</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
<p>As a final note, the following pattern can be a particularly
surprising instance of the above:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">loc</span> <span class="kd">in</span> <span class="nx">Locales</span> <span class="p">{</span>
  <span class="k">on</span> <span class="nx">loc</span> <span class="p">{</span>
    <span class="c1">// do some computation</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although the <cite>Locales</cite> array represents the set of distributed
locales on which the program is running, it is implemented using a
local array on each locale.  As a result, the parallelism generated
by this loop structure will once again be based on the number of
local cores, implying that if <code class="docutils literal notranslate"><span class="pre">numLocales</span> <span class="pre">&gt;&gt;</span> <span class="pre">here.maxTaskPar</span></code>, you
will not end up executing on all the locales simultaneously.</p>
<p>A better approach would be to use a coforall-loop:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">coforall</span> <span class="nx">loc</span> <span class="kd">in</span> <span class="nx">Locales</span> <span class="p">{</span>
  <span class="k">on</span> <span class="nx">loc</span> <span class="p">{</span>
    <span class="c1">// do some computation</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will create a task per locale regardless of the number of local
cores, ensuring that all locales end up computing simultaneously.</p>
<p>The lesson here is to make sure you’re iterating over a distributed
expression when you want your forall-loop to parallelize across a
number of locales greater than the number of local cores.</p>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h2>
<p>That wraps up this primer introducing Chapel’s various loop types.
For further details, refer to the Chapel language specification
or ask questions in our user support channels.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="variables.html" class="btn btn-neutral float-left" title="Variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="procedures.html" class="btn btn-neutral float-right" title="Procedures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>