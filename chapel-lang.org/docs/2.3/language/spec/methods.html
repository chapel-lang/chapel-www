<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Methods &mdash; Chapel Documentation 2.3</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=c3c8ae58"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Error Handling" href="error-handling.html" />
    <link rel="prev" title="Iterators" href="iterators.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.3
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.3";
$pagename = "language/spec/methods";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#code-structures">Code Structures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l3"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#method-calls">Method Calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-method-receiver-and-the-this-argument">The Method Receiver and the <em>this</em> Argument</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-this-in-methods">Implicit <em>this.</em> in Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-this-method">The <em>this</em> Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-these-method">The <em>these</em> Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#methods-without-parentheses">Methods without parentheses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Chapel Language Specification</a></li>
      <li class="breadcrumb-item active">Methods</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/methods.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="methods">
<span id="chapter-methods"></span><span id="index-0"></span><h1>Methods<a class="headerlink" href="#methods" title="Link to this heading">Â¶</a></h1>
<p>A <em>method</em> is a procedure or iterator that is associated with an
expression known as the <em>receiver</em>.</p>
<p>Methods are declared with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>method-declaration-statement:
  procedure-kind[OPT] proc-or-iter this-intent[OPT] type-binding[OPT] identifier argument-list[OPT]
    return-intent[OPT] return-type[OPT] where-clause[OPT] function-body

proc-or-iter:
  &#39;proc&#39;
  &#39;iter&#39;

this-intent:
  &#39;param&#39;
  &#39;type&#39;
  &#39;ref&#39;
  &#39;const ref&#39;
  &#39;const&#39;

type-binding:
  identifier .
  &#39;(&#39; expression &#39;)&#39; .
</pre></div>
</div>
<p>Methods defined within the lexical scope of a class, record, or union
are referred to as <em>primary methods</em>. For such methods, the
<code class="docutils literal notranslate"><span class="pre">type-binding</span></code> is omitted and is taken to be the innermost class,
record, or union in which the method is defined.</p>
<p>Methods defined outside of the lexical scope of a class, record, or union,
but within the scope where the type itself is defined are known as
<em>secondary methods</em>.  Methods defined outside of both the lexical scope and
the scope where the type itself is defined are known as <em>tertiary methods</em>.
Both secondary and tertiary methods must have a <code class="docutils literal notranslate"><span class="pre">type-binding</span></code> (otherwise,
they would simply be standalone functions rather than methods). Note that
secondary and tertiary methods can be defined not only for classes, records,
and unions, but also for any other type (e.g., integers, reals, strings).</p>
<p id="secondary-and-tertiary-methods-with-type-expressions">Secondary and tertiary methods can be declared with a type expression instead of
a type identifier. In particular, if the <code class="docutils literal notranslate"><span class="pre">type-binding</span></code> is a parenthesized
expression, the compiler will evaluate that expression to find the receiver type
for the method. In that case, the method applies only to receivers of that type.
See also <a class="reference internal" href="generics.html#creating-general-and-specialized-versions-of-a-function"><span class="std std-ref">Creating General and Specialized Versions of a Function</span></a>.</p>
<p>Method calls are described in <a class="reference internal" href="#method-calls"><span class="std std-ref">Method Calls</span></a>.</p>
<p>The use of <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is described in <a class="reference internal" href="#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>.</p>
<section id="method-calls">
<span id="index-1"></span><span id="id1"></span><h2>Method Calls<a class="headerlink" href="#method-calls" title="Link to this heading">Â¶</a></h2>
<p>A method is invoked with a method call, which is similar to a non-method
call expression, but it can include a receiver clause. The receiver
clause syntactically identifies a single argument by putting it before
the method name. That argument is the method receiver. When calling a
method from another method, or from within a class or record
declaration, the receiver clause can be omitted. See
<a class="reference internal" href="#implicit-this-dot-in-methods"><span class="std std-ref">Implicit this. in Methods</span></a>.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>method-call-expression:
  receiver-clause[OPT] expression ( named-expression-list )
  receiver-clause[OPT] expression [ named-expression-list ]
  receiver-clause[OPT] parenthesesless-function-identifier
</pre></div>
</div>
<p>The receiver-clause (or its absence) specifies the methodâs receiver
<a class="reference internal" href="#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>.</p>
<blockquote>
<div><p><em>Example (defineMethod.chpl)</em>.</p>
<p>A method to output information about an instance of the <code class="docutils literal notranslate"><span class="pre">Actor</span></code>
class can be defined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">Actor.print</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Actor &quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="s">&quot; is &quot;</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="s">&quot; years old&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method can be called on an instance of the <code class="docutils literal notranslate"><span class="pre">Actor</span></code> class,
<code class="docutils literal notranslate"><span class="pre">anActor</span></code>, with the call expression <code class="docutils literal notranslate"><span class="pre">anActor.print()</span></code>.</p>
</div></blockquote>
<p>The actual arguments supplied in the method call are bound to the formal
arguments in the method declaration following the rules specified for
procedures (<a class="reference internal" href="procedures.html#chapter-procedures"><span class="std std-ref">Procedures</span></a>). The exception is the
receiver <a class="reference internal" href="#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>.</p>
<p>A primary or secondary method is always visible when the receiver is of the type
to which the method is bound or of a subtype of such type.  Tertiary methods are
only visible if the module which defines them has been imported or used in such
a way that allows these methods to be called (see <a class="reference internal" href="modules.html#using-modules"><span class="std std-ref">Using Modules</span></a> and
<a class="reference internal" href="modules.html#importing-modules"><span class="std std-ref">Importing Modules</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Future work: the semantics of privacy specifiers for methods are still under
discussion.</p>
</div>
</section>
<section id="the-method-receiver-and-the-this-argument">
<span id="method-receiver-and-this"></span><span id="index-2"></span><h2>The Method Receiver and the <em>this</em> Argument<a class="headerlink" href="#the-method-receiver-and-the-this-argument" title="Link to this heading">Â¶</a></h2>
<p>A methodâs <em>receiver</em> is an implicit formal argument named <code class="docutils literal notranslate"><span class="pre">this</span></code>
representing the expression on which the method is invoked. The
receiverâs actual argument is specified by the <code class="docutils literal notranslate"><span class="pre">receiver-clause</span></code> of a
method-call-expression as specified in <a class="reference internal" href="#method-calls"><span class="std std-ref">Method Calls</span></a>.</p>
<blockquote>
<div><p><em>Example (implicitThis.chpl)</em>.</p>
<p>Let class <code class="docutils literal notranslate"><span class="pre">C</span></code>, method <code class="docutils literal notranslate"><span class="pre">foo</span></code>, and function <code class="docutils literal notranslate"><span class="pre">bar</span></code> be defined as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">bar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">bar</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>Then given an instance of <code class="docutils literal notranslate"><span class="pre">C</span></code> called <code class="docutils literal notranslate"><span class="pre">c1</span></code>, the method call
<code class="docutils literal notranslate"><span class="pre">c1.foo()</span></code> results in a call to <code class="docutils literal notranslate"><span class="pre">bar</span></code> where the argument is
<code class="docutils literal notranslate"><span class="pre">c1</span></code>. Within primary method <code class="docutils literal notranslate"><span class="pre">C.foo()</span></code>, the (implicit) receiver
formal has static type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> and is referred to as <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</div></blockquote>
<p>Methods whose receivers are objects are called <em>instance methods</em>.
Methods may also be defined to have <code class="docutils literal notranslate"><span class="pre">type</span></code> receiversâthese are known
as <em>type methods</em>.</p>
<p>Methods on a class <code class="docutils literal notranslate"><span class="pre">C</span></code> generally use a <code class="docutils literal notranslate"><span class="pre">this</span></code> type of <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>
but <code class="docutils literal notranslate"><span class="pre">this</span></code> will be more generic in some cases. See
<a class="reference internal" href="classes.html#class-methods"><span class="std std-ref">Class Methods</span></a>.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is used to specify type methods, to
constrain a receiver argument to be a <code class="docutils literal notranslate"><span class="pre">param</span></code>, or to specify how the
receiver argument should be passed to the method.</p>
<p>When no <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is used, a default this intent applies. For
methods on classes and other primitive types, the default this intent is
the same as the default intent for that type. For record methods, the
intent for the receiver formal argument is <code class="docutils literal notranslate"><span class="pre">const</span></code>.
See <a class="reference internal" href="procedures.html#the-default-intent"><span class="std std-ref">The Default Intent</span></a>.</p>
<p>A method whose <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is <code class="docutils literal notranslate"><span class="pre">type</span></code> defines a <em>type method</em>. It
can only be called on the type itself rather than on an instance of the
type. When <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is <code class="docutils literal notranslate"><span class="pre">param</span></code>, it specifies that the function
can only be applied to param objects of the given type binding.</p>
<blockquote>
<div><p><em>Example (paramTypeThisIntent.chpl)</em>.</p>
<p>In the following code, the <code class="docutils literal notranslate"><span class="pre">isOdd</span></code> method is defined with a
<code class="docutils literal notranslate"><span class="pre">this-intent</span></code> of <code class="docutils literal notranslate"><span class="pre">param</span></code>, permitting it to be called on params
only. The <code class="docutils literal notranslate"><span class="pre">size</span></code> method is defined with a <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> of
<code class="docutils literal notranslate"><span class="pre">type</span></code>, requiring it to be called on the <code class="docutils literal notranslate"><span class="pre">int</span></code> type itself, not
on integer values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">param</span> <span class="kt">int</span><span class="p">.</span><span class="nx">isOdd</span><span class="p">()</span> <span class="kd">param</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="o">==</span> <span class="mh">0x1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">type</span> <span class="kt">int</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="kd">param</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">64</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">param</span> <span class="nx">three</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">seven</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="m">42.i</span><span class="nx">sOdd</span><span class="p">());</span>          <span class="c1">// prints false</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">three</span><span class="p">.</span><span class="nx">isOdd</span><span class="p">());</span>       <span class="c1">// prints true</span>
<span class="nx">writeln</span><span class="p">((</span><span class="mi">42</span><span class="o">+</span><span class="nx">three</span><span class="p">).</span><span class="nx">isOdd</span><span class="p">());</span>  <span class="c1">// prints true</span>
<span class="c1">// writeln(seven.isOdd());    // illegal since &#39;seven&#39; is not a param</span>

<span class="nx">writeln</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="nx">size</span><span class="p">());</span>          <span class="c1">// prints 64</span>
<span class="c1">// writeln(42.size());        // illegal since &#39;size()&#39; is a type method</span>
</pre></div>
</div>
</div></blockquote>
<p>Type methods can also be iterators.</p>
<blockquote>
<div><p><em>Example (typeMethodIter.chpl)</em>.</p>
<p>In the following code, the class <code class="docutils literal notranslate"><span class="pre">C</span></code> defines a type method iterator
which can be invoked on the type itself:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>

  <span class="k">iter</span> <span class="nf">type</span> <span class="nx">myIter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">11</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">C</span><span class="p">.</span><span class="nx">myIter</span><span class="p">()</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>When <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is <code class="docutils literal notranslate"><span class="pre">ref</span></code>, the receiver argument will be passed by
reference, allowing modifications to <code class="docutils literal notranslate"><span class="pre">this</span></code>. If <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> is
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, the receiver argument is passed by reference but it
cannot be modified inside the method. The <code class="docutils literal notranslate"><span class="pre">this-intent</span></code> can also
describe an abstract intent as follows. If it is <code class="docutils literal notranslate"><span class="pre">const</span></code>, the receiver
argument will be passed with <code class="docutils literal notranslate"><span class="pre">const</span></code> intent. If it is left out
entirely, the receiver will be passed with a default intent. The default
<code class="docutils literal notranslate"><span class="pre">this</span></code> intent matches the default argument intent described in
<a class="reference internal" href="procedures.html#the-default-intent"><span class="std std-ref">The Default Intent</span></a>.</p>
<blockquote>
<div><p><em>Example (refThisIntent.chpl)</em>.</p>
<p>In the following code, the <code class="docutils literal notranslate"><span class="pre">doubleMe</span></code> function is defined with a
<code class="docutils literal notranslate"><span class="pre">this-intent</span></code> of <code class="docutils literal notranslate"><span class="pre">ref</span></code>, allowing variables of type <code class="docutils literal notranslate"><span class="pre">int</span></code> to
double themselves.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">ref</span> <span class="kt">int</span><span class="p">.</span><span class="nx">doubleMe</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Given a variable <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code>, a call to <code class="docutils literal notranslate"><span class="pre">x.doubleMe()</span></code> will set <code class="docutils literal notranslate"><span class="pre">x</span></code>
to <code class="docutils literal notranslate"><span class="pre">4</span></code>.</p>
</div></blockquote>
</section>
<section id="implicit-this-in-methods">
<span id="implicit-this-dot-in-methods"></span><span id="index-3"></span><h2>Implicit <em>this.</em> in Methods<a class="headerlink" href="#implicit-this-in-methods" title="Link to this heading">Â¶</a></h2>
<p>Within a method, an identifier can implicitly refer to a field or another
method. The compiler will implicitly add a <code class="docutils literal notranslate"><span class="pre">this.</span></code> in such cases.</p>
<blockquote>
<div><p><em>Example (implicitThis.chpl)</em>.</p>
<p>In the below example, within <code class="docutils literal notranslate"><span class="pre">proc</span> <span class="pre">R.method()</span></code>, the identifiers <code class="docutils literal notranslate"><span class="pre">field</span></code>,
<code class="docutils literal notranslate"><span class="pre">parenlessMethod</span></code>, and <code class="docutils literal notranslate"><span class="pre">parenfulMethod</span></code> will implicitly refer to
<code class="docutils literal notranslate"><span class="pre">this.field</span></code>, <code class="docutils literal notranslate"><span class="pre">this.parenlessMethod</span></code>, and <code class="docutils literal notranslate"><span class="pre">this.parenfulMethod</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">field</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">parenlessMethod</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">parenfulMethod</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">R.method</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">field</span> <span class="o">+</span> <span class="nx">parenlessMethod</span> <span class="o">+</span> <span class="nx">parenfulMethod</span><span class="p">();</span>
  <span class="c1">// the above behaves the same as the following:</span>
  <span class="c1">// var x = this.field + this.parenlessMethod + this.parenfulMethod();</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>When considering what an identifier might refer to in a method, the
compiler will consider scopes and parent scopes in turn and choose the
closest applicable match. During this process, it will consider fields
and methods available from the receiver typeâs definition point just
after considering a method scope.  This process does not apply to
parenful method calls; instead those are handled through overload
resolution (see <a class="reference internal" href="procedures.html#determining-most-specific-functions"><span class="std std-ref">Determining Most Specific Functions</span></a>).</p>
<blockquote>
<div><p><em>Example (shadowingAndImplicitThis.chpl)</em>.</p>
<p>In the below example, within <code class="docutils literal notranslate"><span class="pre">proc</span> <span class="pre">R.method()</span></code>, the identifiers
<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> could all refer to a field or to a variable.
In the example, the variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are considered closer
than the fields, but the variable <code class="docutils literal notranslate"><span class="pre">c</span></code> is considered further away.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">R.method</span><span class="p">(</span><span class="nx">b</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
  <span class="c1">// &#39;a&#39; here refers to the local variable &#39;a&#39;, because the lookup</span>
  <span class="c1">// process considers the method body before considering</span>
  <span class="c1">// fields and methods.</span>

  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
  <span class="c1">// &#39;b&#39; here refers to the formal argument &#39;b&#39;, because the</span>
  <span class="c1">// lookup process considers formal arguments before considering</span>
  <span class="c1">// fields and methods.</span>

  <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
  <span class="c1">// &#39;c&#39; here refers to &#39;this.c&#39;, because the lookup process</span>
  <span class="c1">// considers fields and methods just after reaching the method</span>
  <span class="c1">// declaration. Since a match is found with the field, it is used</span>
  <span class="c1">// before the &#39;var c&#39; declared outside this method is considered.</span>

  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="o">+</span><span class="nx">z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="the-this-method">
<span id="index-4"></span><span id="id2"></span><h2>The <em>this</em> Method<a class="headerlink" href="#the-this-method" title="Link to this heading">Â¶</a></h2>
<p>A procedure method declared with the name <code class="docutils literal notranslate"><span class="pre">this</span></code> allows the receiver
to be âindexedâ similarly to how an array is indexed. Indexing (as with
<code class="docutils literal notranslate"><span class="pre">A[1]</span></code>) has the semantics of calling a method named <code class="docutils literal notranslate"><span class="pre">this</span></code>. There is
no other way to call a method called <code class="docutils literal notranslate"><span class="pre">this</span></code>. The <code class="docutils literal notranslate"><span class="pre">this</span></code> method must
be declared with parentheses even if the argument list is empty.</p>
<blockquote>
<div><p><em>Example (thisMethod.chpl)</em>.</p>
<p>In the following code, the <code class="docutils literal notranslate"><span class="pre">this</span></code> method is used to create a class
that acts like a simple array that contains three integers indexed by
1, 2, and 3.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThreeArray</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">x3</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">this</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
    <span class="k">select</span> <span class="nx">i</span> <span class="p">{</span>
      <span class="k">when</span> <span class="mi">1</span> <span class="k">do</span> <span class="k">return</span> <span class="nx">x1</span><span class="p">;</span>
      <span class="k">when</span> <span class="mi">2</span> <span class="k">do</span> <span class="k">return</span> <span class="nx">x2</span><span class="p">;</span>
      <span class="k">when</span> <span class="mi">3</span> <span class="k">do</span> <span class="k">return</span> <span class="nx">x3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;ThreeArray index out of bounds: &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="the-these-method">
<span id="index-5"></span><span id="id3"></span><h2>The <em>these</em> Method<a class="headerlink" href="#the-these-method" title="Link to this heading">Â¶</a></h2>
<p>An iterator method declared with the name <code class="docutils literal notranslate"><span class="pre">these</span></code> allows the receiver
to be âiterated overâ similarly to how a domain or array supports
iteration. When a value supporting a <code class="docutils literal notranslate"><span class="pre">these</span></code> method is used as the
<code class="docutils literal notranslate"><span class="pre">iteratable-expression</span></code> of a loop, the loop proceeds in a manner
controlled by the <code class="docutils literal notranslate"><span class="pre">these</span></code> iterator.</p>
<blockquote>
<div><p><em>Example (theseIterator.chpl)</em>.</p>
<p>In the following code, the <code class="docutils literal notranslate"><span class="pre">these</span></code> method is used to create a class
that acts like a simple array that can be iterated over and contains
three integers.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThreeArray</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">x3</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">iter</span> <span class="nf">these</span><span class="p">()</span> <span class="kd">ref</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">x1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="nx">x2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="nx">x3</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>An iterator type method with the name <code class="docutils literal notranslate"><span class="pre">these</span></code> supports iteration over
the class type itself.</p>
<blockquote>
<div><p><em>Example (typeMethodIterThese.chpl)</em>.</p>
<p>In the following code, the class <code class="docutils literal notranslate"><span class="pre">C</span></code> defines a type method iterator
named <code class="docutils literal notranslate"><span class="pre">these</span></code>, supporting direct iteration over the type:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>

  <span class="k">iter</span> <span class="nf">type</span> <span class="nx">these</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">8</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">C</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="methods-without-parentheses">
<span id="id4"></span><h2>Methods without parentheses<a class="headerlink" href="#methods-without-parentheses" title="Link to this heading">Â¶</a></h2>
<p>Similarly to <a class="reference internal" href="procedures.html#functions-without-parentheses"><span class="std std-ref">Functions without Parentheses</span></a>, it is possible to
create methods that do not have parentheses. Such methods look similar to
field access when they are called. As a result, a method without
parentheses can be used to replace a field that was removed or renamed
while providing the same interface as the field accessor.</p>
<blockquote>
<div><p><em>Example (parenlessMethod.chpl)</em>.</p>
<p>For example, the following code shows a <code class="docutils literal notranslate"><span class="pre">record</span> <span class="pre">myType</span></code> that has a
field <code class="docutils literal notranslate"><span class="pre">x</span></code>. It also shows some code that operates on the field.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">myType</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">myType</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, suppose that as <code class="docutils literal notranslate"><span class="pre">myType</span></code> evolves, it is adjusted to compute the
value of <code class="docutils literal notranslate"><span class="pre">x</span></code> without storing it at all. In that case, a
method without parentheses can allow the code using <code class="docutils literal notranslate"><span class="pre">myType</span></code> to
function as it did before:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">myType</span> <span class="p">{</span>
  <span class="c1">// this parentheses-less function supports</span>
  <span class="c1">// a field-access syntax</span>
  <span class="k">proc</span> <span class="nf">x</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// compute ``x`` and return it</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">myType</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>One can create a method without parentheses to replace a field or
parenless method in a parent class. Such methods require the <code class="docutils literal notranslate"><span class="pre">override</span></code>
keyword (see <a class="reference internal" href="classes.html#overriding-base-class-methods"><span class="std std-ref">Overriding Base Class Methods</span></a>).</p>
<p>Note that class methods without parentheses that return with <code class="docutils literal notranslate"><span class="pre">type</span></code> or
<code class="docutils literal notranslate"><span class="pre">param</span></code> intent use a generic type for the <code class="docutils literal notranslate"><span class="pre">this</span></code> argument. See
<a class="reference internal" href="classes.html#class-methods"><span class="std std-ref">Class Methods</span></a> for more details.</p>
<p>It is a redeclaration error to define a method without parentheses with
the same name as a field.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="iterators.html" class="btn btn-neutral float-left" title="Iterators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="error-handling.html" class="btn btn-neutral float-right" title="Error Handling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>