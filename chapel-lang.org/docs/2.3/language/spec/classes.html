<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Classes &mdash; Chapel Documentation 2.3</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=c3c8ae58"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Records" href="records.html" />
    <link rel="prev" title="Bytes" href="bytes.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.3
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.3";
$pagename = "language/spec/classes";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-structures">Code Structures</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#composite-types">Composite Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="strings.html">Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="bytes.html">Bytes</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-declarations">Class Declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance">Inheritance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-new">Class New</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-initializers">Class Initializers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#field-accesses">Field Accesses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-method-calls">Class Method Calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#common-operations">Common Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deleting-unmanaged-class-instances">Deleting Unmanaged Class Instances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#owned-objects">Owned Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#methods-on-owned-classes">Methods on <cite>owned</cite> Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-objects">Shared Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#methods-on-shared-classes">Methods on <cite>shared</cite> Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l3"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.html">Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Chapel Language Specification</a></li>
      <li class="breadcrumb-item active">Classes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/classes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="classes">
<span id="chapter-classes"></span><span id="index-0"></span><h1>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h1>
<p>Classes are data structures with associated state and functions. A
variable of class type either refers to a class instance, or contains a
special <code class="docutils literal notranslate"><span class="pre">nil</span></code> value. Note that <em>object</em> is another name for a class
instance. Storage for a class instance is not necessarily tied to the
scope of the variable(s) referring to that class instance. It is
possible for multiple variables to refer to the same class instance.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">new-expression</span></code> can be used to create an instance of a class
(<a class="reference internal" href="#class-new"><span class="std std-ref">Class New</span></a>). Depending on the memory management strategy, a
class instance is either deleted automatically or can be deleted using
the <code class="docutils literal notranslate"><span class="pre">delete-statement</span></code> (<a class="reference internal" href="#class-delete"><span class="std std-ref">Deleting Unmanaged Class Instances</span></a>).</p>
<p>A class declaration (<a class="reference internal" href="#class-declarations"><span class="std std-ref">Class Declarations</span></a>) generates a class
type (<a class="reference internal" href="#class-types"><span class="std std-ref">Class Types</span></a>). A variable of a class type can refer
to an instance of that class or any of its derived classes.</p>
<p>A class is generic if it has generic fields. A class can also be generic
if it inherits from a generic class. Generic classes and fields are
discussed in <a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<section id="class-declarations">
<span id="index-1"></span><span id="id1"></span><h2>Class Declarations<a class="headerlink" href="#class-declarations" title="Link to this heading">¶</a></h2>
<p>A class is defined with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>class-declaration-statement:
  &#39;class&#39; identifier class-inherit[OPT] { class-statement-list[OPT] }

class-inherit:
  : basic-class-type

class-statement-list:
  class-statement
  class-statement class-statement-list

class-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">class-declaration-statement</span></code> defines a new class type symbol
specified by the identifier. It inherits from the class specified in the
<code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> clause, when provided (<a class="reference internal" href="#inheritance"><span class="std std-ref">Inheritance</span></a>).</p>
<p>The body of a class declaration consists of a sequence of statements
where each of the statements either defines a variable (called a field),
a procedure or iterator (called a method), or a type alias. In addition,
empty statements are allowed in class declarations, and they have no
effect.</p>
<p>If a class declaration contains a type alias or a parameter field, or it
contains a variable or constant without a specified type and without an
initialization expression, then it declares a generic class type.
Generic classes are described in <a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em>.</p>
<p>Privacy controls for classes and records are currently not specified,
as discussion is needed regarding its impact on inheritance, for
instance.</p>
</div>
</div></blockquote>
<section id="class-lifetime-and-borrows">
<span id="index-2"></span><span id="id2"></span><h3>Class Lifetime and Borrows<a class="headerlink" href="#class-lifetime-and-borrows" title="Link to this heading">¶</a></h3>
<p>The lifetime of a class instance is the time between its creation and
its deletion. It is legal to access the class fields or methods only
during its lifetime.</p>
<p>Each allocation of a class instance specifies a <em>memory management
strategy</em>. Three memory management strategies are available: <code class="docutils literal notranslate"><span class="pre">owned</span></code>,
<code class="docutils literal notranslate"><span class="pre">shared</span></code>, and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">owned</span></code> and <code class="docutils literal notranslate"><span class="pre">shared</span></code> class instances always have their lifetime
managed by the compiler. In other words, the compiler automatically calls
<code class="docutils literal notranslate"><span class="pre">delete</span></code> on these instances to reclaim their memory. For these
instances, <code class="docutils literal notranslate"><span class="pre">=</span></code> and copy initialization can result in the transfer or
sharing of ownership. See the <a class="reference internal" href="#owned-objects"><span class="std std-ref">Owned Objects</span></a> and <a class="reference internal" href="#shared-objects"><span class="std std-ref">Shared Objects</span></a>
sections for more details.</p>
<p>Class instances that are <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> have their lifetime managed
explicitly by the programmer. The <code class="docutils literal notranslate"><span class="pre">delete</span></code> keyword must be used to
reclaim their memory.</p>
<p>Regardless of the memory management strategy used, class types support
<em>borrowing</em>. A <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> class instance refers to the same class
instance as another variable but has no impact on the lifetime of that
instance. The process of getting such a reference to an instance is
called <em>borrowing</em>.</p>
<p>There are several ways to borrow an instance. To borrow explicitly the
instance managed by another variable, call the <code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method.
Additionally, coercions are available that are equivalent to calling the
<code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method. For example:</p>
<blockquote>
<div><p><em>Example (borrowing.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">own</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>   <span class="c1">// &#39;own&#39; manages the memory of the instance</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">own</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span>      <span class="c1">// &#39;b&#39; refers to the same instance but has no</span>
                             <span class="c1">// impact on the lifetime.</span>

  <span class="kd">var</span> <span class="nx">bc</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">own</span><span class="p">;</span>  <span class="c1">// &#39;bc&#39; stores the result of own.borrow()</span>
                             <span class="c1">// due to coercion from owned C to</span>
                             <span class="c1">// borrowed C</span>

                             <span class="c1">// Note that these coercions can also apply</span>
                             <span class="c1">// in the context of procedure calls.</span>

                             <span class="c1">// the instance referred to by &#39;own&#39; is</span>
                             <span class="c1">// deleted here, at the end of the containing</span>
                             <span class="c1">// block.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method is available on all class types (including
<code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> and <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>) in order to support generic programming.
For nilable class types, it returns the borrowed nilable class type.</p>
<p>Errors due to accessing an instance after the end of its lifetime are
particularly difficult to debug. For this reason, the compiler includes
a component called the lifetime checker. It identifies some cases where
a borrowing variable can be accessed beyond the lifetime of an instance
it refers to.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>The details of lifetime checking are not yet finalized or specified.
Additional syntax to specify the lifetimes of function returns will
probably be needed.</p>
</div>
</div></blockquote>
</section>
<section id="class-types">
<span id="index-3"></span><span id="id3"></span><h3>Class Types<a class="headerlink" href="#class-types" title="Link to this heading">¶</a></h3>
<p>A class type is formed by the combination of a basic class type and a
memory management strategy. Class types can be used in a variety of scenarios
such as variable declarations or type specifiers on formal arguments.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>class-type:
  basic-class-type
  &#39;owned&#39; basic-class-type
  &#39;shared&#39; basic-class-type
  &#39;borrowed&#39; basic-class-type
  &#39;unmanaged&#39; basic-class-type
</pre></div>
</div>
<p>A <cite>basic-class-type</cite> can be specified using the name of any non-generic class.
To use a generic class in a <cite>class-type</cite>, it must be fully-instantiated. More
information on instantiating generic types can be found in the
<a class="reference internal" href="generics.html#type-constructors"><span class="std std-ref">Type Constructors</span></a> Section.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>basic-class-type:
  identifier
  identifier ( named-expression-list )
</pre></div>
</div>
<p>A basic class type, including a generic class type that is not fully
specified, may appear in the inheritance lists of other class
declarations.</p>
<p>If a class type’s memory management strategy is unspecified, it will be
generic. (This is not the case for class instances created using the
<code class="docutils literal notranslate"><span class="pre">new</span></code> expression (see <a class="reference internal" href="#class-new"><span class="std std-ref">Class New</span></a>). When a <code class="docutils literal notranslate"><span class="pre">new</span></code> expression
does not specify a memory management strategy, then the management will
default to <code class="docutils literal notranslate"><span class="pre">owned</span></code>.)</p>
<p>Variables of class type cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code> unless the class type is
nilable (<a class="reference internal" href="#nilable-classes"><span class="std std-ref">Nilable Class Types</span></a>).</p>
<p>The memory management strategies have the following meaning:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span></code> the instance will be deleted automatically when the
<code class="docutils literal notranslate"><span class="pre">owned</span></code> variable goes out of scope, but only one <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable
can refer to the instance at a time. See the <a class="reference internal" href="#owned-objects"><span class="std std-ref">Owned Objects</span></a> section
for more details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared</span></code> will be deleted when all of the <code class="docutils literal notranslate"><span class="pre">shared</span></code> variables
referring to the instance go out of scope. See the <a class="reference internal" href="#shared-objects"><span class="std std-ref">Shared Objects</span></a>
section for more details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed</span></code> refers to a class instance that has a lifetime managed
by another variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> the instance must have <code class="docutils literal notranslate"><span class="pre">delete</span></code> called on it
explicitly to reclaim its memory.</p></li>
</ul>
<p>It is an error to apply more than one memory management strategy to a
class type. However, in some cases, generic code needs to compute a
variant of the class type using a different memory management strategy.
Casts from the class type to a different memory management strategy are
available for this purpose (see <a class="reference internal" href="conversions.html#explicit-class-conversions"><span class="std std-ref">Explicit Class Conversions</span></a>).</p>
<blockquote>
<div><p><em>Example (duplicate-management.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="k">borrowed</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (changing-management.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">borrowedC</span> <span class="o">=</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">ownedC</span> <span class="o">=</span> <span class="p">(</span><span class="nx">borrowedC</span><span class="p">:</span><span class="k">owned</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="nilable-class-types">
<span id="nilable-classes"></span><span id="index-4"></span><h3>Nilable Class Types<a class="headerlink" href="#nilable-class-types" title="Link to this heading">¶</a></h3>
<p>Variables of a class type cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code> and do not have a default
value unless the class type is nilable. To create a nilable class type,
use the postfix <code class="docutils literal notranslate"><span class="pre">?</span></code> operator. For example, if <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class, then
<code class="docutils literal notranslate"><span class="pre">C?</span></code> indicates the nilable class type with generic memory management strategy.
The <code class="docutils literal notranslate"><span class="pre">?</span></code> operator can be combined with memory management specifiers as
well. For example, <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code> indicates a nilable class using the
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code> memory management strategy. Note that the <code class="docutils literal notranslate"><span class="pre">?</span></code> operator
applies only to types.</p>
<p>A nilable type can also be created with a cast to <code class="docutils literal notranslate"><span class="pre">class?</span></code>. For example,
if <code class="docutils literal notranslate"><span class="pre">T</span></code> is a class type, then <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">class?</span></code> indicates its nilable counterpart,
or <code class="docutils literal notranslate"><span class="pre">T</span></code> itself if it is already nilable. <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">borrowed</span> <span class="pre">class?</span></code> produces
the nilable <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> variant of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>To create a non-nilable class type from a nilable class type, apply a
cast to <code class="docutils literal notranslate"><span class="pre">class</span></code> or to a more specific type. For example, if <code class="docutils literal notranslate"><span class="pre">T</span></code> is
a class type, then <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">class</span></code> indicates its non-nilable counterpart,
or <code class="docutils literal notranslate"><span class="pre">T</span></code> itself if it is already non-nilable. <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">borrowed</span> <span class="pre">class</span></code>
produces the non-nilable <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> variant of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>The postfix <code class="docutils literal notranslate"><span class="pre">!</span></code> operator converts a class value to a non-nilable type.
If the value is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>, it returns a copy of that value if it is
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code> or <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, or a borrow from it if it is <code class="docutils literal notranslate"><span class="pre">owned</span></code>
or <code class="docutils literal notranslate"><span class="pre">shared</span></code>. If the value is in fact <code class="docutils literal notranslate"><span class="pre">nil</span></code>, it halts.</p>
<p>An alternative to <code class="docutils literal notranslate"><span class="pre">!</span></code> is to use a cast to a non-nilable type. Such a
cast will throw <code class="docutils literal notranslate"><span class="pre">NilClassError</span></code> if the value was in fact <code class="docutils literal notranslate"><span class="pre">nil</span></code>.
See <a class="reference internal" href="conversions.html#explicit-class-conversions"><span class="std std-ref">Explicit Class Conversions</span></a>.</p>
<p>Non-nilable class types are implicitly convertible to nilable class
types. See <a class="reference internal" href="conversions.html#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>.</p>
<p>Class methods generally expect a receiver of type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>
(see <a class="reference internal" href="#class-methods"><span class="std std-ref">Class Methods</span></a>). Since such a class method call might
involve dynamic dispatch, it is a program error to call a class method
on a class receiver storing <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The compiler will not
resolve calls to class methods if the receiver has nilable type. If the
programmer knows that the receiver cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code> at that moment,
they can use <code class="docutils literal notranslate"><span class="pre">!</span></code> to assert that the receiver is not <code class="docutils literal notranslate"><span class="pre">nil</span></code> and to
convert it to the non-nilable borrowed type. For example:</p>
<blockquote>
<div><p><em>Example (nilable-classes-bang.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>

<span class="c1">// Invoke c.method() only when c is non-nil.</span>
<span class="k">if</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">c</span><span class="o">!</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span> <span class="c1">// c! converts from &#39;owned C?&#39; to &#39;borrowed C&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">borrow()</span></code> method is an exception. Suppose it is invoked on an
expression of a class type <code class="docutils literal notranslate"><span class="pre">C</span></code>. It will return <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> for any
non-nilable <code class="docutils literal notranslate"><span class="pre">C</span></code> type (e.g. <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>). It will return
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code> for any nilable <code class="docutils literal notranslate"><span class="pre">C</span></code> type (e.g. <code class="docutils literal notranslate"><span class="pre">C?</span></code>).</p>
</section>
<section id="class-values">
<span id="index-5"></span><span id="id4"></span><h3>Class Values<a class="headerlink" href="#class-values" title="Link to this heading">¶</a></h3>
<p>A class value is either a reference to an instance of a class or <code class="docutils literal notranslate"><span class="pre">nil</span></code>
(<a class="reference internal" href="#class-nil-value"><span class="std std-ref">The nil Value</span></a>). Class instances can be created using a
<code class="docutils literal notranslate"><span class="pre">new</span></code> expression (<a class="reference internal" href="#class-new"><span class="std std-ref">Class New</span></a>).</p>
<p>For a given class type, a legal value of that type is a reference to an
instance of either that class or a class inheriting, directly or
indirectly, from that class. <code class="docutils literal notranslate"><span class="pre">nil</span></code> is a legal value of any non-nilable
class type.</p>
<p>The default value of a concrete nilable class type is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Generic
class types and non-nilable class types do not have a default value.
For this reason, rectangular arrays of non-nilable classes cannot be
resized, since the new array values don’t have a logical default
value.  For similar reasons, associative and sparse arrays of
non-nilable classes are not currently supported.</p>
<blockquote>
<div><p><em>Example (declaration.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span>    <span class="c1">// c has class type owned C?, meaning</span>
                     <span class="c1">// the instance can be nil and is deleted automatically</span>
                     <span class="c1">// when it is not.</span>
<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>         <span class="c1">// Now c refers to an initialized instance of type C.</span>
<span class="kd">var</span> <span class="nx">c2</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span> <span class="c1">// The type of c2 is borrowed C?.</span>
                     <span class="c1">// c2 refers to the same object as c.</span>
<span class="k">class</span> <span class="nc">D</span> <span class="p">:</span> <span class="nx">C</span> <span class="p">{}</span>    <span class="c1">// Class D is derived from C.</span>
<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">D</span><span class="p">();</span>      <span class="c1">// Now c refers to an object of type D.</span>
                  <span class="c1">// Since c is owned, the previous is deleted.</span>
<span class="c1">// the C and D instances allocated above will be reclaimed</span>
<span class="c1">// at the end of this block.</span>
</pre></div>
</div>
<p>When the variable <code class="docutils literal notranslate"><span class="pre">c</span></code> is declared, it initially has the value of
<code class="docutils literal notranslate"><span class="pre">nil</span></code>. The next statement assigned to it an instance of the class
<code class="docutils literal notranslate"><span class="pre">C</span></code>. The declaration of variable <code class="docutils literal notranslate"><span class="pre">c2</span></code> shows that these steps can
be combined. The type of <code class="docutils literal notranslate"><span class="pre">c2</span></code> is also <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code>, determined
implicitly from the initialization expression. Finally, an object
of type <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">D</span></code> is created and assigned to <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</div></blockquote>
</section>
<section id="the-nil-value">
<span id="class-nil-value"></span><span id="index-6"></span><h3>The <em>nil</em> Value<a class="headerlink" href="#the-nil-value" title="Link to this heading">¶</a></h3>
<p>Chapel provides <code class="docutils literal notranslate"><span class="pre">nil</span></code> to indicate the absence of a reference to any
object. Invoking a class method or accessing a field of the <code class="docutils literal notranslate"><span class="pre">nil</span></code>
value results in a run-time or compile-time error.</p>
<p><code class="docutils literal notranslate"><span class="pre">nil</span></code> can be assigned to a variable of any nilable class type. There
is a restriction for using <code class="docutils literal notranslate"><span class="pre">nil</span></code> as the default value or the actual
argument of a function formal, or as the initializer for a variable or a
field. Such a use is disallowed when the declared type of the
formal/variable/field is non-nilable or generic, including generic
memory management.</p>
</section>
<section id="class-fields">
<span id="index-7"></span><span id="id5"></span><h3>Class Fields<a class="headerlink" href="#class-fields" title="Link to this heading">¶</a></h3>
<p>A variable declaration within a class declaration defines a <em>field</em>
within that class. Each class instance consists of one variable per each
<code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field in the class.</p>
<blockquote>
<div><p><em>Example (defineActor.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Actor</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">age</span><span class="p">:</span> <span class="kt">uint</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>defines a new class type called <code class="docutils literal notranslate"><span class="pre">Actor</span></code> that has two fields: the
string field <code class="docutils literal notranslate"><span class="pre">name</span></code> and the unsigned integer field <code class="docutils literal notranslate"><span class="pre">age</span></code>.</p>
</div></blockquote>
<p>Field access is described in <a class="reference internal" href="#class-field-accesses"><span class="std std-ref">Field Accesses</span></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p><code class="docutils literal notranslate"><span class="pre">ref</span></code> fields, which are fields corresponding to variable
declarations with <code class="docutils literal notranslate"><span class="pre">ref</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> keywords, are an area of
future work.</p>
</div>
</div></blockquote>
</section>
<section id="class-methods">
<span id="index-8"></span><span id="id6"></span><h3>Class Methods<a class="headerlink" href="#class-methods" title="Link to this heading">¶</a></h3>
<p>Methods on classes are referred to as <em>class methods</em>. They can be
instance methods or type methods.  See <a class="reference internal" href="methods.html#chapter-methods"><span class="std std-ref">Methods</span></a> for more
information about methods.</p>
<p>Within a class method, the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> is generally the non-nilable
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code> variant of the class type. It is different for type methods
and for methods without parentheses that return a <code class="docutils literal notranslate"><span class="pre">type</span></code> or <code class="docutils literal notranslate"><span class="pre">param</span></code>
(see below). Additionally, it might be a different type if the class
method is declared as a secondary method with a type expression.</p>
<p>For example:</p>
<blockquote>
<div><p><em>Example (class-method-this-type.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">primaryMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">C.secondaryMethod</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">assert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="p">(</span><span class="k">owned</span><span class="nx"> C?</span><span class="p">).</span><span class="nf">secondaryMethodWithTypeExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">assert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>
<span class="nx">x</span><span class="o">!</span><span class="p">.</span><span class="nx">primaryMethod</span><span class="p">();</span>   <span class="c1">// within the method, this: borrowed C</span>
<span class="nx">x</span><span class="o">!</span><span class="p">.</span><span class="nx">secondaryMethod</span><span class="p">();</span> <span class="c1">// within the method, this: borrowed C</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">secondaryMethodWithTypeExpression</span><span class="p">();</span> <span class="c1">// within the method, this: owned C?</span>
</pre></div>
</div>
</div></blockquote>
<p>For type methods on a class, <code class="docutils literal notranslate"><span class="pre">this</span></code> will accept any management or
nilability variant of the class type and it will refer to that type in
the body of the method. In other words, <code class="docutils literal notranslate"><span class="pre">this</span></code> will be instantiated to
match the receiver at the call site. For example:</p>
<blockquote>
<div><p><em>Example (class-type-method-this.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">type</span> <span class="nx">typeMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// print out &#39;this&#39;, which is a type</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">(</span><span class="nx">C</span><span class="p">).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;C&#39;</span>
<span class="p">(</span><span class="k">owned</span> <span class="nx">C</span><span class="p">).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;owned C&#39;</span>
<span class="p">(</span><span class="k">borrowed</span> <span class="nx">C</span><span class="p">?).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;borrowed C?&#39;</span>
</pre></div>
</div>
</div></blockquote>
<p>When a type method is defined only in a parent class, <code class="docutils literal notranslate"><span class="pre">this</span></code> will be a
type that is the corresponding variant of the parent class. For example:</p>
<blockquote>
<div><p><em>Example (class-type-method-inherit.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">type</span> <span class="nx">Parent</span><span class="p">.</span><span class="nx">typeMethod</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// print out &#39;this&#39;, which is a type</span>
<span class="p">}</span>

<span class="nx">Child</span><span class="p">.</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;Parent&#39;</span>
<span class="p">(</span><span class="k">borrowed</span> <span class="nx">Child</span><span class="p">?).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;borrowed Parent?&#39;</span>
</pre></div>
</div>
</div></blockquote>
<p>Similarly, a class method without parentheses that returns with <code class="docutils literal notranslate"><span class="pre">param</span></code>
or <code class="docutils literal notranslate"><span class="pre">type</span></code> intent will have a <code class="docutils literal notranslate"><span class="pre">this</span></code> that accepts any nilability or
management. See also <a class="reference internal" href="methods.html#methods-without-parentheses"><span class="std std-ref">Methods without parentheses</span></a>.</p>
<blockquote>
<div><p><em>Example (class-parenless-method-nilability.chpl)</em>.</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">parenlessParam</span> <span class="kd">param</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">parenlessType</span> <span class="kd">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?();</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">parenlessParam</span><span class="p">);</span> <span class="c1">// prints &#39;0&#39;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">parenlessType</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// prints &#39;owned C?&#39;</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</section>
<section id="nested-classes">
<span id="index-9"></span><span id="id7"></span><h3>Nested Classes<a class="headerlink" href="#nested-classes" title="Link to this heading">¶</a></h3>
<p>A class defined within another class or record is a nested class. A
nested class can be referenced only within its immediately enclosing
class or record.</p>
</section>
</section>
<section id="inheritance">
<span id="index-10"></span><span id="id8"></span><h2>Inheritance<a class="headerlink" href="#inheritance" title="Link to this heading">¶</a></h2>
<p>A class inherits, or <em>derives</em>, from the class specified in the class
declaration’s <code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> clause when such clause is present.
Otherwise the class inherits from the predefined <code class="docutils literal notranslate"><span class="pre">RootClass</span></code> class
(<a class="reference internal" href="#the-root-class"><span class="std std-ref">The Root Class</span></a>). In either case, there is exactly one
<em>parent</em> class. There can be many classes that inherit from a particular
parent class.</p>
<p>It is possible for a class to inherit from a generic class. Suppose for
example that <code class="docutils literal notranslate"><span class="pre">ParentC</span></code> is a generic class. A class <code class="docutils literal notranslate"><span class="pre">C</span></code> can inherits
from it by writing <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">C</span> <span class="pre">:</span> <span class="pre">ParentC(?)</span></code>. In this situation, <code class="docutils literal notranslate"><span class="pre">C</span></code>
will have type constructor arguments based upon generic fields in the
<code class="docutils literal notranslate"><span class="pre">ParentC</span></code> as described in <a class="reference internal" href="generics.html#type-constructors"><span class="std std-ref">The Type Constructor</span></a>. Furthermore, a
fully specified <code class="docutils literal notranslate"><span class="pre">C</span></code> will be a subclass of a corresponding fully
specified <code class="docutils literal notranslate"><span class="pre">ParentC</span></code>.</p>
<section id="the-root-class">
<span id="index-11"></span><span id="id9"></span><h3>The Root Class<a class="headerlink" href="#the-root-class" title="Link to this heading">¶</a></h3>
<p>All classes are derived from a base class named <code class="docutils literal notranslate"><span class="pre">RootClass</span></code>, either
directly or indirectly. If a class declaration does not contain a
<code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> clause, the class implicitly derives from
<code class="docutils literal notranslate"><span class="pre">RootClass</span></code>. Otherwise, the class derives from <code class="docutils literal notranslate"><span class="pre">RootClass</span></code>
indirectly through the class it inherits from. A variable of type
<code class="docutils literal notranslate"><span class="pre">RootClass</span></code> can hold a reference to an object of any class type.</p>
</section>
<section id="accessing-base-class-fields">
<span id="index-12"></span><span id="id10"></span><h3>Accessing Base Class Fields<a class="headerlink" href="#accessing-base-class-fields" title="Link to this heading">¶</a></h3>
<p>A derived class contains data associated with the fields in its base
classes. The fields can be accessed in the same way that they are
accessed in their base class unless a getter method is overridden in the
derived class, as discussed
in <a class="reference internal" href="#overriding-base-class-methods"><span class="std std-ref">Overriding Base Class Methods</span></a>.</p>
</section>
<section id="shadowing-base-class-fields">
<span id="index-13"></span><span id="id11"></span><h3>Shadowing Base Class Fields<a class="headerlink" href="#shadowing-base-class-fields" title="Link to this heading">¶</a></h3>
<p>A field in a derived class declared with the same name as a field in a
base class will cause a compilation error.</p>
</section>
<section id="overriding-base-class-methods">
<span id="index-14"></span><span id="id12"></span><h3>Overriding Base Class Methods<a class="headerlink" href="#overriding-base-class-methods" title="Link to this heading">¶</a></h3>
<p>If a method in a derived class is declared with a signature identical to
that of a method in a base class, then it is said to override the base
class’s method. Such methods may be considered for dynamic dispatch if
certain criteria are met. In particular, dynamic dispatch will be used
when the method receiver has a static type of the base class but refers
to an instance of a derived class type. Additionally, a method eligible
for dynamic dispatch must not be a class method (see <a class="reference internal" href="#class-methods"><span class="std std-ref">Class Methods</span></a>),
must not return <code class="docutils literal notranslate"><span class="pre">type</span></code>, and must not return <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Class methods, methods that return <code class="docutils literal notranslate"><span class="pre">type</span></code>, and methods that return
<code class="docutils literal notranslate"><span class="pre">param</span></code> are not considered as candidates for dynamic dispatch because
they are resolved at compile-time based on the static type of the
method receiver.</p>
</div></blockquote>
<p>In order to have identical signatures, two methods must have the same
names, and their formal arguments must have the same names, intents, types,
and order.</p>
<p>The return type of the overriding method must either be the same as the
return type of the base class’s method or be a subclass of the base class
method’s return type.</p>
<p>Methods that override a base class method must be marked with the
<code class="docutils literal notranslate"><span class="pre">override</span></code> keyword in the <code class="docutils literal notranslate"><span class="pre">procedure-kind</span></code>. Additionally, methods
marked with <code class="docutils literal notranslate"><span class="pre">override</span></code> but for which there is no parent class method
with an identical signature will result in a compiler error.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>This feature is designed to help avoid cases where class authors
accidentally override a method without knowing it; or fail to
override a method that they intended to due to not meeting the
identical signature condition.</p>
</div></blockquote>
<p>Methods without parentheses are not candidates for dynamic dispatch.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Methods without parentheses are primarily used for field accessors. A
default is created if none is specified. The field accessor should
not dispatch dynamically since that would make it impossible to
access a base field within a base method should that field be
shadowed by a subclass.</p>
</div></blockquote>
</section>
</section>
<section id="class-new">
<span id="index-15"></span><span id="id13"></span><h2>Class New<a class="headerlink" href="#class-new" title="Link to this heading">¶</a></h2>
<p>To create an instance of a class, use a <code class="docutils literal notranslate"><span class="pre">new</span></code> expression. For example:</p>
<blockquote>
<div><p><em>Example (class-new.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The new expression can be defined by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>new-expression:
  &#39;new&#39; type-expression ( argument-list )
</pre></div>
</div>
<p>An initializer for a given class is called by placing the <code class="docutils literal notranslate"><span class="pre">new</span></code>
operator in front of a type expression. Any initializer arguments follow
the class name in a parenthesized list.</p>
<p>Syntactically, the <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> includes <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>. However these have important
consequences for class new expressions. In particular, suppose <code class="docutils literal notranslate"><span class="pre">C</span></code> is
a <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> that results in a class type. Then:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C()</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">owned</span> <span class="pre">C()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">owned</span> <span class="pre">C()</span></code> allocates and initializes an instance that will be
deleted at the end of the current block unless it is transferred to
another <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable. It results in something of type
<code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">shared</span> <span class="pre">C()</span></code> allocates and initializes the instance that will
be deleted when the last <code class="docutils literal notranslate"><span class="pre">shared</span></code> variable referring to it goes out
of scope. Results in something of type <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">unmanaged</span> <span class="pre">C()</span></code> allocates and initializes an instance that must
have <code class="docutils literal notranslate"><span class="pre">delete</span></code> called on it explicitly to avoid a memory leak. It
results in something of type <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C</span></code>.</p></li>
</ul>
<p>See also <a class="reference internal" href="#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a> and
<a class="reference internal" href="#class-types"><span class="std std-ref">Class Types</span></a>.</p>
</section>
<section id="class-initializers">
<span id="index-16"></span><span id="id14"></span><h2>Class Initializers<a class="headerlink" href="#class-initializers" title="Link to this heading">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">new</span></code> expression allocates memory for the desired class and invokes
an <em>initializer</em> method on the uninitialized memory, passing any
arguments following the class name. An initializer is implemented by a
method named <code class="docutils literal notranslate"><span class="pre">init</span></code> and is responsible for initializing the fields of
the class.</p>
<p>Any initializers declared in a program are <em>user-defined</em> initializers.
If the program declares no initializers for a class, the compiler must
generate an initializer for that class based on the types and
initialization expressions of fields defined by that class.</p>
<section id="user-defined-initializers">
<span id="index-17"></span><span id="id15"></span><h3>User-Defined Initializers<a class="headerlink" href="#user-defined-initializers" title="Link to this heading">¶</a></h3>
<p>A user-defined initializer is an initializer method explicitly declared
in the program. An initializer declaration has the same syntax as a
method declaration, with the restrictions that the name of the method
must be <code class="docutils literal notranslate"><span class="pre">init</span></code> and there must not be a return type specifier. When an
initializer is called, the usual function resolution mechanism
(<a class="reference internal" href="procedures.html#function-resolution"><span class="std std-ref">Function Resolution</span></a>) is applied with the exception that
an initializer may not be virtually dispatched.</p>
<p>A user-defined initializer is responsible for initializing all fields.
An initializer may omit initialization of fields, but all fields that
are initialized must be initialized in declaration order.</p>
<p>Initializers for generic classes (<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>) handle
generic fields without default values differently and may need to
satisfy additional requirements. See
Section <a class="reference internal" href="generics.html#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a> for details.</p>
<blockquote>
<div><p><em>Example (simpleInitializers.chpl)</em>.</p>
<p>The following example shows a class with two initializers:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MessagePoint</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">message</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="s">&quot;a point&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// class MessagePoint</span>

<span class="c1">// create two objects</span>
<span class="kd">var</span> <span class="nx">mp1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MessagePoint</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">mp2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MessagePoint</span><span class="p">(</span><span class="s">&quot;point mp2&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer lets the user specify the initial coordinates
and the second initializer lets the user specify the initial message
when creating a MessagePoint.</p>
</div></blockquote>
<section id="field-initialization-versus-assignment">
<span id="index-18"></span><span id="id16"></span><h4>Field Initialization Versus Assignment<a class="headerlink" href="#field-initialization-versus-assignment" title="Link to this heading">¶</a></h4>
<p>Within the body of an initializer, the first use of a field as the
left-hand side of an assignment statement will be considered
initialization. Subsequent uses of the assignment operator on the field
will invoke regular assignment as defined by the language.</p>
<blockquote>
<div><p><em>Example (fieldInitAssignment.chpl)</em>.</p>
<p>The following example documents the difference between field
initialization and field assignment.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PointDoubleX</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>              <span class="c1">// initialization</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;x = &quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// use of initialized field</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">// assignment, use of initialized field</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>              <span class="c1">// initialization</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PointDoubleX</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first statement in the initializer initializes field <code class="docutils literal notranslate"><span class="pre">x</span></code> to the
value of the formal <code class="docutils literal notranslate"><span class="pre">x</span></code>. The second statement simply reads the
value of the initialized field. The third statement reads the value
of the field, doubles it, and <em>assigns</em> the result to the field
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div></blockquote>
<p>If a field is used before it is initialized, an compile-time error will
be issued.</p>
<blockquote>
<div><p><em>Example (usedBeforeInitialized.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// Error: use of uninitialized field!</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first statement in the initializer reads the value of
uninitialized field <code class="docutils literal notranslate"><span class="pre">x</span></code>, so the compiler will issue an error:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>usedBeforeInitialized.chpl:4: In initializer:
usedBeforeInitialized.chpl:5: error: field &quot;x&quot; used before it is initialized
</pre></div>
</div>
</div></blockquote>
</section>
<section id="omitting-field-initializations">
<span id="index-19"></span><span id="id17"></span><h4>Omitting Field Initializations<a class="headerlink" href="#omitting-field-initializations" title="Link to this heading">¶</a></h4>
<p>In order to support productive and elegant initializers, the language
allows field initializations to be omitted if the field has a type or if
the field has an initialization expression. The compiler will insert
initialization statements for such fields based on their types and
default values.</p>
<blockquote>
<div><p><em>Example (fieldInitOmitted.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LabeledPoint</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&#39;Unlabeled&#39;</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="c1">// compiler inserts &quot;this.msg = &#39;Unlabeled&#39;&quot;;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// compiler inserts &quot;this.x = 0.0;&quot;</span>
    <span class="c1">// compiler inserts &quot;this.y = 0.0;&quot;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="s">&quot;Origin&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer initializes the values of fields <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code>, and the compiler inserts initialization for the <code class="docutils literal notranslate"><span class="pre">msg</span></code> field
by using its default value. The second initializer initializes the
<code class="docutils literal notranslate"><span class="pre">msg</span></code> field, and the compiler inserts initialization for fields
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> based on the type of those fields
(<a class="reference internal" href="variables.html#default-values-for-types"><span class="std std-ref">Default Initialization</span></a>).</p>
</div></blockquote>
<p>In order to reduce ambiguity and to ensure a well-defined order for
side-effects, the language requires that all fields be initialized in
field declaration order. This applies regardless of whether field
initializations are omitted from the initializer body. If fields are
initialized out of order, a compile-time error will be issued.</p>
<blockquote>
<div><p><em>Example (fieldsOutOfOrder.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="c1">// compiler inserts &quot;this.y = 1.0;&quot;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// Error!</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer leverages the well-defined order of omitted
field initialization to use the default value of field <code class="docutils literal notranslate"><span class="pre">y</span></code> in order
to explicitly initialize field <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>The second initializer initializes field <code class="docutils literal notranslate"><span class="pre">z</span></code> before field <code class="docutils literal notranslate"><span class="pre">y</span></code>,
causing a compile-time error to be issued.</p>
</div></blockquote>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Without this rule the compiler could insert default initialization
for field <code class="docutils literal notranslate"><span class="pre">y</span></code> before <code class="docutils literal notranslate"><span class="pre">z</span></code> is explicitly initialized. The following
statement would then be <em>assignment</em> to field <code class="docutils literal notranslate"><span class="pre">y</span></code>, despite
appearing to be initialization. This subtle difference may be
confusing and surprising, and is avoided by requiring fields to be
initialized in field declaration order.</p>
</div></blockquote>
</section>
<section id="limitations-on-instance-usage-in-initializers">
<span id="index-20"></span><span id="id18"></span><h4>Limitations on Instance Usage in Initializers<a class="headerlink" href="#limitations-on-instance-usage-in-initializers" title="Link to this heading">¶</a></h4>
<p>As the initializer makes progress, the class instance is incrementally
initialized. In order to prevent usage of uninitialized memory, there
are restrictions on usage of the class instance before it is fully
initialized:</p>
<ul class="simple">
<li><p>Methods may not be invoked on partially-initialized instances</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> may not be passed to functions while partially-initialized</p></li>
</ul>
<p>These rules allow all methods and functions to assume that class
instances have been initialized, provided their value is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The compiler could conceivably attempt to analyze methods and
functions to determine which fields are used, and selectively allow
method calls on partially-initialized class instances. Instead, it is
simpler for the language to forbid method calls on
partially-initialized instances.</p>
</div></blockquote>
<p>Methods may be called and <code class="docutils literal notranslate"><span class="pre">this</span></code> may be passed to functions only after
the special <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement is used. If any fields have not been
initialized by the time the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement is used, they will be
considered omitted and the compiler will insert initialization statements as
described earlier. If the user does not use <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> explicitly, the
compiler will insert it at the end of the initializer.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Due to support for omitted field initialization, there is potential
for confusion regarding the overall status of initialization. This
confusion is addressed in the design by requiring <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> to
explicitly mark the transition between partially and fully
initialized instances.</p>
</div></blockquote>
<blockquote>
<div><p><em>Implementors’ note</em>.</p>
<p>Even if the user explicitly initializes every field, the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code>
statement is still required to invoke other methods.</p>
<p><em>Example (thisDotComplete.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LabeledPoint</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&#39;Unlabeled&#39;</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="c1">// compiler inserts initialization for &#39;max&#39; and &#39;msg&#39;</span>

    <span class="k">init</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// &#39;this&#39; is now considered to be fully initialized</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">verify</span><span class="p">();</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// compiler inserts initialization for fields &#39;x&#39;, &#39;y&#39;, and &#39;max&#39;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>

    <span class="c1">// Illegal: this.verify();</span>
    <span class="c1">// Implicit &#39;init this;&#39;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">verify</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="k">then</span>
      <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;LabeledPoint out of bounds!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="s">&quot;Origin&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer leverages the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement to initialize
the remaining fields and to allow for the usage of the <code class="docutils literal notranslate"><span class="pre">verify</span></code>
method. Calling the <code class="docutils literal notranslate"><span class="pre">verify</span></code> method or passing <code class="docutils literal notranslate"><span class="pre">this</span></code> to
<code class="docutils literal notranslate"><span class="pre">writeln</span></code> before the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement is used would result in
a compile-time error.</p>
<p>The second initializer exists to emphasize the rule that even though
all fields are initialized after the initialization of the <code class="docutils literal notranslate"><span class="pre">msg</span></code>
field, the compiler does not consider the type initialized until the
<code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement is used. If the second initializer tried to
invoke the <code class="docutils literal notranslate"><span class="pre">verify</span></code> method, a compile-time error would be issued.</p>
</div></blockquote>
</section>
<section id="invoking-other-initializers">
<span id="index-21"></span><span id="id19"></span><h4>Invoking Other Initializers<a class="headerlink" href="#invoking-other-initializers" title="Link to this heading">¶</a></h4>
<p>In order to allow for code-reuse, an initializer may invoke another
initializer implemented for the same type. Because the invoked
initializer must operate on completely uninitialized memory, a
compile-time error will be issued for field initialization before a call
to <code class="docutils literal notranslate"><span class="pre">init</span></code>. Because each initializer either explicitly or implicitly
uses the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement, all fields and methods may be used
after such a call to <code class="docutils literal notranslate"><span class="pre">init</span></code>.</p>
<blockquote>
<div><p><em>Example (thisDotInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="c1">// implicit &#39;init this;&#39;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">u</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">u</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The second initializer leverages the first initializer to initialize
all fields with the same value. After the <code class="docutils literal notranslate"><span class="pre">init</span></code> call the type is
fully initialized, the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement has been used, and so
<code class="docutils literal notranslate"><span class="pre">this</span></code> can be passed to the <code class="docutils literal notranslate"><span class="pre">writeln</span></code> function.</p>
</div></blockquote>
</section>
<section id="initializing-fields-in-conditional-statements">
<span id="index-22"></span><span id="id20"></span><h4>Initializing Fields in Conditional Statements<a class="headerlink" href="#initializing-fields-in-conditional-statements" title="Link to this heading">¶</a></h4>
<p>Fields may be initialized inside of conditional statements, with the
restriction that the same set of fields must be initialized in every
branch. If the user omits any field initializations, the compiler will
insert field initializations up to and including the field furthest in
field declaration order between the conditional branches. If the else
branch of a conditional statement is omitted, the compiler will generate
an empty else branch and insert field initialization statements as
needed.</p>
<blockquote>
<div><p><em>Example (initFieldConditional.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">theta</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">polar</span> <span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">val</span> <span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">polar</span> <span class="p">{</span>
      <span class="c1">// compiler inserts initialization for fields &#39;x&#39; and &#39;y&#39;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">r</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="c1">// compiler inserts initialization for field &#39;r&#39;</span>
    <span class="p">}</span>
    <span class="c1">// compiler inserts initialization for field &#39;theta&#39;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler identifies field <code class="docutils literal notranslate"><span class="pre">r</span></code> as the latest field in both
branches, and inserts omitted field initialization statements as
needed to ensure that fields <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">r</span></code> are all
initialized by the end of the conditional.</p>
</div></blockquote>
<p>Conditionals may also contain calls to parent initializers
(<a class="reference internal" href="#initializing-inherited"><span class="std std-ref">Initializing Inherited Classes</span></a>) and other initializers defined
for the current type, provided that the initialization state is the same
at the end of the conditional statement.</p>
<blockquote>
<div><p><em>Example (thisDotInitConditional.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">cond</span> <span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">val</span> <span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">cond</span> <span class="p">{</span>
      <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="k">init</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer must use <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement at the end
of the if-branch in order to match the state at the end of the
else-branch.</p>
</div></blockquote>
</section>
<section id="miscellaneous-field-initialization-rules">
<span id="index-23"></span><h4>Miscellaneous Field Initialization Rules<a class="headerlink" href="#miscellaneous-field-initialization-rules" title="Link to this heading">¶</a></h4>
<p>Fields may not be initialized within loop statements or parallel
statements.</p>
</section>
</section>
<section id="the-compiler-generated-initializer">
<span id="index-24"></span><span id="id21"></span><h3>The Compiler-Generated Initializer<a class="headerlink" href="#the-compiler-generated-initializer" title="Link to this heading">¶</a></h3>
<p>A compiler-generated initializer for a class is created automatically if
there are no initializers for that class in the program. The
compiler-generated initializer has one argument for every field in the
class, each of which has a default value equal to the field’s default
value (if present) or the default value of the field’s type (if not).
The order and names of arguments matches the order and names of field
declarations within the class.</p>
<p>Generic fields are discussed in
Section <a class="reference internal" href="generics.html#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Generic Initializer</span></a>.</p>
<p>The compiler-generated initializer will initialize each field to the
value of the corresponding actual argument.</p>
<blockquote>
<div><p><em>Example (defaultInitializer.chpl)</em>.</p>
<p>Given the class</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;Hello, World!&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>there are no user-defined initializers for <code class="docutils literal notranslate"><span class="pre">C</span></code>, so <code class="docutils literal notranslate"><span class="pre">new</span></code>
expressions will invoke <code class="docutils literal notranslate"><span class="pre">C</span></code>’s compiler-generated initializer. The
<code class="docutils literal notranslate"><span class="pre">x</span></code> argument of the compiler-generated initializer has the default
value <code class="docutils literal notranslate"><span class="pre">0</span></code>. The <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> arguments have the default values
<code class="docutils literal notranslate"><span class="pre">3.14</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;Hello,</span> <span class="pre">World!</span></code>”, respectively.</p>
<p><code class="docutils literal notranslate"><span class="pre">C</span></code> instances can be created by calling the compiler-generated
initializer as follows:</p>
<ul class="simple">
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C()</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(0,3.14,&quot;Hello,</span> <span class="pre">World!&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2,3.14,&quot;Hello,</span> <span class="pre">World!&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(z=&quot;&quot;)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(0,3.14,&quot;&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2,</span> <span class="pre">z=&quot;&quot;)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2,3.14,&quot;&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(0,0.0,&quot;&quot;)</span></code> specifies the initial values for all
fields explicitly.</p></li>
</ul>
</div></blockquote>
</section>
<section id="the-postinit-method">
<span id="index-25"></span><span id="id22"></span><h3>The postinit Method<a class="headerlink" href="#the-postinit-method" title="Link to this heading">¶</a></h3>
<p>The compiler-generated initializer is powerful and flexible, but cannot
satisfy all initialization patterns desired by users. One way for users
to leverage the compiler-generated initializer while adding their own
functionality is to implement a method named <code class="docutils literal notranslate"><span class="pre">postinit</span></code>. The
<code class="docutils literal notranslate"><span class="pre">postinit</span></code> method may also be implemented for types with user-defined
initializers.</p>
<p>The compiler will insert a call to the <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method after the
initializer invoked by the <code class="docutils literal notranslate"><span class="pre">new</span></code> expression finishes, if the method
exists. The <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method accepts zero arguments and may not
return anything. Otherwise, this method behaves like any other method.</p>
<blockquote>
<div><p><em>Example (postinit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">postinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">verify</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">verify</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="k">then</span>
      <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;  Point out of bounds!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">5.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Each of the <code class="docutils literal notranslate"><span class="pre">new</span></code> expressions invokes the compiler-generated
initializer, then invokes the <code class="docutils literal notranslate"><span class="pre">verify</span></code> method via the <code class="docutils literal notranslate"><span class="pre">postinit</span></code>
method:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>(0.0, 0.0)
(1.0, 2.0)
(0.0, 5.0)
(50.0, 50.0)
  Point out of bounds!
</pre></div>
</div>
</div></blockquote>
<p>For classes that inherit, the user may invoke the parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code>
method or let the compiler insert a call automatically
(<a class="reference internal" href="#the-postinit-method-for-inheriting-classes"><span class="std std-ref">The postinit Method for Inheriting Classes</span></a>).</p>
</section>
<section id="initializing-inherited-classes">
<span id="initializing-inherited"></span><span id="index-26"></span><h3>Initializing Inherited Classes<a class="headerlink" href="#initializing-inherited-classes" title="Link to this heading">¶</a></h3>
<p>User-defined initializers also allow for control over initialization of
parent classes. All the fields of the parent type must be initialized
before any fields of the child type, otherwise a compile-time error is
issued. This allows for parent fields to be used in the definition of
child fields. An initializer may invoke a parent’s initializer using the
<code class="docutils literal notranslate"><span class="pre">super</span></code> keyword.</p>
<p>If the user does not explicitly call the parent’s initializer, the
compiler will insert a call to the parent initializer with zero
arguments at the start of the initializer.</p>
<blockquote>
<div><p><em>Example (simpleSuperInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">val</span> <span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">:</span> <span class="nx">A</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// implicit super.init();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">b</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">b1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">b2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
</pre></div>
</div>
<p>The first initializer explicitly calls an initializer for class
<code class="docutils literal notranslate"><span class="pre">A</span></code>. Once the parent’s initializer is complete, fields of class
<code class="docutils literal notranslate"><span class="pre">B</span></code> may be initialized.</p>
<p>The second initializer implicitly invokes the parent’s initializer
with zero arguments, and then uses the parent’s fields to initialize
its own fields.</p>
</div></blockquote>
<p>As stated earlier, the compiler will insert a zero-argument call to the
parent’s initializer if the user has not explicitly written one
themselves. The exception to this rule is if the initializer body
invokes another initializer on the current type
(<a class="reference internal" href="#invoking-other-initializers"><span class="std std-ref">Invoking Other Initializers</span></a>). This other initializer
will either contain an implicit or explicit call to the parent
initializer, and so the calling initializer should not attempt to
initialize the parent itself. This also means that parent fields may not
be accessed before explicit calls to <code class="docutils literal notranslate"><span class="pre">init</span></code>.</p>
<blockquote>
<div><p><em>Example (superInitThisInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The second initializer does not contain an implicit call to the
parent’s initializer because it explicitly invokes another
initializer.</p>
</div></blockquote>
<section id="calling-methods-on-parent-classes">
<span id="index-27"></span><span id="id23"></span><h4>Calling Methods on Parent Classes<a class="headerlink" href="#calling-methods-on-parent-classes" title="Link to this heading">¶</a></h4>
<p>Once <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> returns, the dynamic type of <code class="docutils literal notranslate"><span class="pre">this</span></code> is the
parent’s type until the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement
(<a class="reference internal" href="#limitations-on-instance-usage-in-initializers"><span class="std std-ref">Limitations on Instance Usage in Initializers</span></a>) is
used (except when the child’s fields are initialized and used). As a
result, the parent’s methods may be called and <code class="docutils literal notranslate"><span class="pre">this</span></code> may be passed to
functions as though it were of the parent type.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>After <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> returns the instance is in some
partially-initialized, but valid, state. Allowing <code class="docutils literal notranslate"><span class="pre">this</span></code> to be
treated as the parent allows for additional functionality and
flexibility for users.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (dynamicThisInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parent.foo&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// parent&#39;s compiler-generated initializer</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// Parent.foo()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="k">init</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// Child.foo()</span>
  <span class="p">}</span>

  <span class="k">override</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Child.foo&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Once the parent’s initializer is finished, the parent method <code class="docutils literal notranslate"><span class="pre">foo</span></code>
may be called. After the <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">this</span></code> statement is used, a call to
<code class="docutils literal notranslate"><span class="pre">foo</span></code> resolves to the child’s overridden
(<a class="reference internal" href="#overriding-base-class-methods"><span class="std std-ref">Overriding Base Class Methods</span></a>) implementation:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>Parent.foo
Child.foo
{x = 1.0, y = 2.0, z = 3.0}
</pre></div>
</div>
</div></blockquote>
</section>
<section id="the-compiler-generated-initializer-for-inheriting-classes">
<span id="index-28"></span><span id="id24"></span><h4>The Compiler Generated Initializer for Inheriting Classes<a class="headerlink" href="#the-compiler-generated-initializer-for-inheriting-classes" title="Link to this heading">¶</a></h4>
<p>The compiler-generated initializer for inheriting classes will have
arguments with default values and names based on the field declarations
in the parent class. Formals for the parent type will be listed before
formals for the child type.</p>
<blockquote>
<div><p><em>Example (compilerGeneratedInheritanceInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span> <span class="c1">// x=1.0, y=2.0, z=3.0</span>
<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">10.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Any <code class="docutils literal notranslate"><span class="pre">new</span></code> expressions using the <code class="docutils literal notranslate"><span class="pre">Child</span></code> type can invoke an
initializer with three formals named <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> that all
have default values based on their types.</p>
</div></blockquote>
</section>
<section id="the-postinit-method-for-inheriting-classes">
<span id="index-29"></span><span id="id25"></span><h4>The postinit Method for Inheriting Classes<a class="headerlink" href="#the-postinit-method-for-inheriting-classes" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method on inheriting classes allows users to invoke the
parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method using the <code class="docutils literal notranslate"><span class="pre">super</span></code> keyword. If the user
does not explicitly invoke the parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code>, the compiler will
insert the call at the top of the user’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method. If the
parent type has a <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method but the inheriting class does not,
the compiler will generate a <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method that simply invokes the
parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method.</p>
<blockquote>
<div><p><em>Example (inheritancePostinit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">postinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parent.postinit: &quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">postinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// compiler inserts &quot;super.postinit();&quot;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Child.postinit: &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler inserts a call to the parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method in
the child’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method, and invokes the child’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code>
method after the compiler-generated initializer finishes:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>Parent.postinit: 1.0, 2.0
Child.postinit: 3.0, 4.0
</pre></div>
</div>
</div></blockquote>
</section>
</section>
</section>
<section id="field-accesses">
<span id="class-field-accesses"></span><span id="index-30"></span><h2>Field Accesses<a class="headerlink" href="#field-accesses" title="Link to this heading">¶</a></h2>
<p>The field in a class is accessed via a field access expression.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>field-access-expression:
  receiver-clause[OPT] identifier

receiver-clause:
  expression .
</pre></div>
</div>
<p>The receiver-clause specifies the <em>receiver</em>, which is the class
instance whose field is being accessed. The receiver clause can be
omitted when the field access is within a method. In this case the
receiver is the method’s receiver. The receiver clause can also be
omitted when the field access is within a class declaration. In this
case the receiver is the instance being implicitly defined or
referenced. When the receiver clause is omitted, the compiler will
consider the possibility that the identifier refers to a field, but in
that case, it could also refer to something declared outside of the
class. In particular, a local variable or formal will shadow a field,
but a field will shadow a module-scope variable declared outside of the method.</p>
<p>The identifier in the field access expression indicates which field is
accessed.</p>
<p>A field can be modified via an assignment statement where the left-hand
side of the assignment is a field access expression.</p>
<p>Accessing a parameter or type field returns a parameter or type,
respectively. In addition to being available for access with a class
instance receiver, parameter and type fields can be accessed from the
instantiated class type itself.</p>
<blockquote>
<div><p><em>Example (useActor1.chpl)</em>.</p>
<p>Given a variable <code class="docutils literal notranslate"><span class="pre">anActor</span></code> of type <code class="docutils literal notranslate"><span class="pre">Actor</span></code> as defined above, the
code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="nx">anActor</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="nx">anActor</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</pre></div>
</div>
<p>reads the field <code class="docutils literal notranslate"><span class="pre">name</span></code> and assigns the value to the variable <code class="docutils literal notranslate"><span class="pre">s</span></code>,
and assigns the field <code class="docutils literal notranslate"><span class="pre">age</span></code> in the object <code class="docutils literal notranslate"><span class="pre">anActor</span></code> the value
<code class="docutils literal notranslate"><span class="pre">27</span></code>.</p>
</div></blockquote>
<section id="field-getter-methods">
<span id="getter-methods"></span><span id="index-31"></span><h3>Field Getter Methods<a class="headerlink" href="#field-getter-methods" title="Link to this heading">¶</a></h3>
<p>The compiler implements field access as calls to a compiler-generated
methods without parentheses that have the same name as the field. See
also <a class="reference internal" href="methods.html#methods-without-parentheses"><span class="std std-ref">Methods without parentheses</span></a>.</p>
</section>
</section>
<section id="class-method-calls">
<span id="index-32"></span><span id="id26"></span><h2>Class Method Calls<a class="headerlink" href="#class-method-calls" title="Link to this heading">¶</a></h2>
<p>Class method calls are similar to other method calls which are described
in <a class="reference internal" href="methods.html#method-calls"><span class="std std-ref">Method Calls</span></a>. However, class method calls are subject
to dynamic dispatch.</p>
<p>The receiver-clause (or its absence) specifies the method’s receiver in
the same way it does for field accesses
<a class="reference internal" href="#class-field-accesses"><span class="std std-ref">Field Accesses</span></a>.</p>
<p>See (<a class="reference internal" href="methods.html#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>) for more details of about
method receivers.</p>
</section>
<section id="common-operations">
<h2>Common Operations<a class="headerlink" href="#common-operations" title="Link to this heading">¶</a></h2>
<section id="class-assignment">
<span id="index-33"></span><span id="id27"></span><h3>Class Assignment<a class="headerlink" href="#class-assignment" title="Link to this heading">¶</a></h3>
<p>Classes are assigned by reference. After an assignment from one variable
of a class type to another, both variables reference the same class
instance. Assignments from an <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable to another <code class="docutils literal notranslate"><span class="pre">owned</span></code> or
<code class="docutils literal notranslate"><span class="pre">shared</span></code> variable are an exception. They transfer ownership, leaving
the source variable empty i.e. storing <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<blockquote>
<div><p><em>Example (owned-assignment.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// assume that C is a class</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">b</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span> <span class="c1">// default initialized to store `nil`</span>
<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// transfers ownership from a to b</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// a is left storing `nil`</span>
</pre></div>
</div>
</div></blockquote>
<p>In contrast, assignment for <code class="docutils literal notranslate"><span class="pre">shared</span></code> variables allows both variables
to refer to the same class instance.</p>
<p>The following assignments between variables or expressions with
different memory management strategies are disallowed:</p>
<ul class="simple">
<li><p>to <code class="docutils literal notranslate"><span class="pre">owned</span></code> from <code class="docutils literal notranslate"><span class="pre">shared</span></code> or <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, as it would not ensure
unique ownership of the instance</p></li>
<li><p>to <code class="docutils literal notranslate"><span class="pre">shared</span></code> from <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, as the original owner would be
unaware of the shared ownership</p></li>
<li><p>to <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, or <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> from <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, as both
the source and the destination would appear responsible for deleting
the instance</p></li>
</ul>
</section>
</section>
<section id="deleting-unmanaged-class-instances">
<span id="class-delete"></span><span id="index-34"></span><h2>Deleting Unmanaged Class Instances<a class="headerlink" href="#deleting-unmanaged-class-instances" title="Link to this heading">¶</a></h2>
<p>Memory associated with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> class instances can be reclaimed
with the <code class="docutils literal notranslate"><span class="pre">delete</span></code> statement:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>delete-statement:
  &#39;delete&#39; expression-list ;
</pre></div>
</div>
<p>where the expression-list specifies the class objects whose memory will
be reclaimed. Prior to releasing their memory, the deinitialization
routines for these objects will be executed
(<a class="reference internal" href="#class-deinitializer"><span class="std std-ref">Class Deinitializer</span></a>). The expression-list can contain
array expressions, in which case each element of that array will be
deleted in parallel using a <code class="docutils literal notranslate"><span class="pre">forall</span></code> loop over the array. It is legal
to delete a class variable whose value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, though this has no
effect. If a class instance is referenced after it has been deleted, the
behavior is undefined.</p>
<blockquote>
<div><p><em>Example (delete.chpl)</em>.</p>
<p>The following example allocates a new object <code class="docutils literal notranslate"><span class="pre">c</span></code> of class type
<code class="docutils literal notranslate"><span class="pre">C</span></code> and then deletes it.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">c</span> <span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>              <span class="c1">// Does nothing: c is nil.</span>

<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">();</span> <span class="c1">// Creates a new object.</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>              <span class="c1">// Deletes that object.</span>

<span class="c1">// The following statements reference an object after it has been deleted, so</span>
<span class="c1">// the behavior of each is &quot;undefined&quot;:</span>
<span class="c1">// writeln(c.i); // May read from freed memory.</span>
<span class="c1">// c.i = 3;      // May overwrite freed memory.</span>
<span class="c1">// delete c;     // May confuse some allocators.</span>
</pre></div>
</div>
</div></blockquote>
<section id="class-deinitializer">
<span id="index-35"></span><span id="id28"></span><h3>Class Deinitializer<a class="headerlink" href="#class-deinitializer" title="Link to this heading">¶</a></h3>
<p>A class author may create a deinitializer to specify additional actions
to be performed when a class instance is deleted. A class deinitializer
is a method named <code class="docutils literal notranslate"><span class="pre">deinit()</span></code>. It must take no arguments (aside from the
implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument). If defined, the deinitializer is called each
time a <code class="docutils literal notranslate"><span class="pre">delete</span></code> statement is invoked with a valid instance of that
class type. The deinitializer is not called if the argument of <code class="docutils literal notranslate"><span class="pre">delete</span></code>
evaluates to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Note that when an <code class="docutils literal notranslate"><span class="pre">owned</span></code> or <code class="docutils literal notranslate"><span class="pre">shared</span></code> reaches
its deinit point (see <a class="reference internal" href="variables.html#deinit-points"><span class="std std-ref">Deinit Points</span></a>), it may call <code class="docutils literal notranslate"><span class="pre">delete</span></code> on a
class instance which in turn will run the deinitializer and then reclaim
the memory.</p>
<blockquote>
<div><p><em>Example (classDeinitializer.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">deinit</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Bye, bye &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>              <span class="c1">// Does nothing: c is nil.</span>

<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Creates a new instance.</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>               <span class="c1">// Deletes that instance: Writes out &quot;Bye, bye 1&quot;</span>
                        <span class="c1">// and reclaims the memory that was held by c.</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">own</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Creates a new owned instance</span>
                            <span class="c1">// The instance is automatically deleted at</span>
                            <span class="c1">// the end of this block, so &quot;Bye, bye 2&quot; is</span>
                            <span class="c1">// output and then the memory is reclaimed.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="owned-objects">
<span id="index-36"></span><span id="id29"></span><h2>Owned Objects<a class="headerlink" href="#owned-objects" title="Link to this heading">¶</a></h2>
<p>Including <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> (or <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a>) in a
class type directs the compiler to manage the deallocation of a class instances
of that type. <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> is meant to be used when only one
reference to an object needs to manage that object’s storage at a time.</p>
<p>Also see the above section on <a class="reference internal" href="#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a>.</p>
<section id="using-owned">
<h3>Using <cite>owned</cite><a class="headerlink" href="#using-owned" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">new</span></code> keyword allocates <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> classes by default.
Additionally, it is possible to explicitly request an <code class="docutils literal notranslate"><span class="pre">owned</span></code> class instance</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">myOwnedObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="c1">// or, equivalently</span>
<span class="kd">var</span> <span class="nx">myOwnedObject</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">MyClass</span><span class="p">();</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">myOwnedObject</span></code> goes out of scope, the class instance it refers to will
be deleted. It is possible to transfer the ownership to another
<a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> variable before that happens.</p>
<p>Copy initializing from <code class="docutils literal notranslate"><span class="pre">myOwnedObject</span></code> or assigning it to another
<a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> will leave <code class="docutils literal notranslate"><span class="pre">myOwnedObject</span></code> storing a nil value
and transfer the owned class instance to the other value.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">otherOwnedObject</span> <span class="o">=</span> <span class="nx">myOwnedObject</span><span class="p">;</span>
<span class="c1">// now myOwnedObject stores nil</span>
<span class="c1">// the value it stored earlier has moved to otherOwnedObject</span>

<span class="nx">myOwnedObject</span> <span class="o">=</span> <span class="nx">otherOwnedObject</span><span class="p">;</span>
<span class="c1">// this assignment moves the value from the right-hand-side</span>
<span class="c1">// to the left-hand-side, leaving the right-hand-side empty.</span>
<span class="c1">// after the assignment, otherOwnedObject stores nil</span>
<span class="c1">// and myOwnedObject stores a value that will be deleted</span>
<span class="c1">// when myOwnedObject goes out of scope.</span>
</pre></div>
</div>
<p><a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> forms part of a type and can be used in type expressions:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">emptyOwnedObject</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">MyClass</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="borrowing-from-owned">
<span id="about-owned-borrowing"></span><span id="index-37"></span><h3>Borrowing from <cite>owned</cite><a class="headerlink" href="#borrowing-from-owned" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#OwnedObject.owned.borrow" title="OwnedObject.owned.borrow"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">borrow</span></code></a> method returns the pointer managed by the
<a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a>. This pointer is only valid as long as the
<a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> is storing that pointer.</p>
<p>The compiler includes a component called the lifetime checker that
can, in many cases, check that a <cite>borrow</cite> does not refer to an object
that could be deleted before the <cite>borrow</cite>. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">MyClass</span><span class="p">();</span>
  <span class="c1">// the instance referred to by a is deleted at end of scope</span>
  <span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span>
  <span class="c1">// c &quot;borrows&quot; to the instance managed by a</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// lifetime checker error! returning borrow from local variable</span>
  <span class="c1">// a is deleted here</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="coercions-for-owned">
<span id="about-owned-coercions"></span><span id="index-38"></span><h3>Coercions for <cite>owned</cite><a class="headerlink" href="#coercions-for-owned" title="Link to this heading">¶</a></h3>
<p>The compiler includes support for introducing automatic coercions
from <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> to the borrow type. This is equivalent
to calling the <a class="reference internal" href="#OwnedObject.owned.borrow" title="OwnedObject.owned.borrow"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">borrow</span></code></a> method. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">MyClass</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myOwned</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">myOwned</span><span class="p">);</span> <span class="c1">// compiler coerces to borrowed MyClass via borrow()</span>
</pre></div>
</div>
<p>Additionally, the compiler includes support for coercing a value
of type <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">T</span></code> to <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">U</span></code> when <code class="docutils literal notranslate"><span class="pre">T</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">U</span></code>.
For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Student</span> <span class="p">:</span> <span class="nx">Person</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">myStudent</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">Student</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">myPerson</span><span class="p">:</span><span class="k">owned</span> <span class="nx">Person</span> <span class="o">=</span> <span class="nx">myStudent</span><span class="p">;</span>
<span class="c1">// relies on coercion from owned Student to owned Person</span>
<span class="c1">// moves the instance from myStudent to myPerson, leaving</span>
<span class="c1">// myStudent containing nil.</span>
</pre></div>
</div>
</section>
<section id="owned-default-intent">
<span id="index-39"></span><h3><cite>owned</cite> Default Intent<a class="headerlink" href="#owned-default-intent" title="Link to this heading">¶</a></h3>
<p>The default intent for <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> is <code class="docutils literal notranslate"><span class="pre">const</span></code>. See more on
argument intents in the <a class="reference internal" href="../../primers/procedures.html#primers-procedures"><span class="std std-ref">Procedures Primer</span></a> and see
more on the default intent in the <a class="reference internal" href="procedures.html#intents-for-owned-and-shared"><span class="std std-ref">Default and ‘const’ Intents for ’owned’ and ’shared’</span></a>.</p>
</section>
</section>
<section id="methods-on-owned-classes">
<span id="owned-methods"></span><span id="index-40"></span><h2>Methods on <cite>owned</cite> Classes<a class="headerlink" href="#methods-on-owned-classes" title="Link to this heading">¶</a></h2>
<dl class="chpl type">
<dt class="sig sig-object chpl" id="OwnedObject.owned">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">owned</span></span><em class="property"> <span class="pre">:</span> <span class="pre">writeSerializable,</span> <span class="pre">readDeserializable</span></em><a class="headerlink" href="#OwnedObject.owned" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> manages the deletion of a class instance assuming
that this <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> is the only thing responsible for
managing the lifetime of the class instance.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="OwnedObject.owned.init=">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">owned.</span></span><span class="sig-name descname"><span class="pre">init=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">src:</span> <span class="pre">owned</span></em><span class="sig-paren">)</span><a class="headerlink" href="#OwnedObject.owned.init=" title="Link to this definition">¶</a></dt>
<dd><p>Copy-initializer. Creates a new <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> that takes over ownership
from <cite>src</cite>. <cite>src</cite> will refer to <cite>nil</cite> after this call.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="OwnedObject.owned.adopt">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">owned.</span></span><span class="sig-name descname"><span class="pre">adopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">obj:</span> <span class="pre">unmanaged</span></em><span class="sig-paren">)</span><a class="headerlink" href="#OwnedObject.owned.adopt" title="Link to this definition">¶</a></dt>
<dd><p>Starts managing the argument class instance <cite>obj</cite>
using the <cite>owned</cite> memory management strategy.
The result type preserves nilability of the argument type.</p>
<p>It is an error to directly delete the class instance
after passing it to <cite>owned.adopt()</cite>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="OwnedObject.owned.release">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">owned.</span></span><span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">obj:</span> <span class="pre">owned</span></em><span class="sig-paren">)</span><a class="headerlink" href="#OwnedObject.owned.release" title="Link to this definition">¶</a></dt>
<dd><p>Empty <cite>obj</cite> so that it manages <cite>nil</cite> and
return the instance previously managed by this owned object.</p>
<p>If the argument is <cite>nil</cite> it returns <cite>nil</cite>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="OwnedObject.owned.deinit">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">owned.</span></span><span class="sig-name descname"><span class="pre">deinit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OwnedObject.owned.deinit" title="Link to this definition">¶</a></dt>
<dd><p>The deinitializer for <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> will destroy the class
instance it manages when the <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> goes out of scope.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="OwnedObject.owned.borrow">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">owned.</span></span><span class="sig-name descname"><span class="pre">borrow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OwnedObject.owned.borrow" title="Link to this definition">¶</a></dt>
<dd><p>Return the object managed by this <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> without impacting its
lifetime at all. It is an error to use the value returned by this function
after the <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> goes out of scope or deletes the contained class
instance for another reason, such as with <cite>=</cite> or <a class="reference internal" href="#OwnedObject.owned.adopt" title="OwnedObject.owned.adopt"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">owned.adopt</span></code></a>. In some
cases such errors are caught at compile-time.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="OwnedObject.=">
<em class="property"><span class="pre">operator</span> </em><span class="sig-name descname"><span class="pre">=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">lhs:</span> <span class="pre">owned</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">rhs:</span> <span class="pre">owned</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">!(isNonNilableClass(lhs)</span> <span class="pre">&amp;&amp;</span> <span class="pre">isNilableClass(rhs))</span></em><a class="headerlink" href="#OwnedObject.=" title="Link to this definition">¶</a></dt>
<dd><p>Assignment between two <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> transfers ownership of the object
managed by <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to <code class="docutils literal notranslate"><span class="pre">lhs</span></code>. This is done by setting <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to <cite>nil</cite> and
then setting <code class="docutils literal notranslate"><span class="pre">lhs</span></code> to point to the object that <code class="docutils literal notranslate"><span class="pre">rhs</span></code> managed before,
if any. After that, it deletes the object previously managed by <code class="docutils literal notranslate"><span class="pre">lhs</span></code>,
if any.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="OwnedObject.&lt;=&gt;">
<em class="property"><span class="pre">operator</span> </em><span class="sig-name descname"><span class="pre">&lt;=&gt;</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">lhs:</span> <span class="pre">owned</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">rhs:</span> <span class="pre">lhs.type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#OwnedObject.<=>" title="Link to this definition">¶</a></dt>
<dd><p>Swap two <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a> objects.</p>
</dd></dl>

</section>
<section id="shared-objects">
<span id="index-41"></span><span id="id30"></span><h2>Shared Objects<a class="headerlink" href="#shared-objects" title="Link to this heading">¶</a></h2>
<p>Including <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> (or <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a>) in a
class type directs the compiler to manage the deallocation of a class instances
of that type. <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> is meant to be used when many
different references will exist to the object at the same time and these
references need to keep the object alive.</p>
<p>Also see the above section on <a class="reference internal" href="#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a>.</p>
<section id="using-shared">
<h3>Using <cite>shared</cite><a class="headerlink" href="#using-shared" title="Link to this heading">¶</a></h3>
<p>To use <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a>, allocate a class instance following this
pattern:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mySharedObject</span> <span class="o">=</span> <span class="k">new</span> <span class="k">shared</span> <span class="nx">MyClass</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">mySharedObject</span></code> and any copies of it go out of scope, the class
instance it refers to will be deleted.</p>
<p>Copy initializing or assigning from mySharedObject will make
other variables refer to the same class instance. The class instance
will be deleted after all of these references go out of scope.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">globalSharedObject</span><span class="p">:</span><span class="k">shared</span> <span class="nx">MyClass</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">makeGlobalSharedObject</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">mySharedObject</span> <span class="o">=</span> <span class="k">new</span> <span class="k">shared</span> <span class="nx">MyClass</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
  <span class="nx">globalSharedObject</span> <span class="o">=</span> <span class="nx">mySharedObject</span><span class="p">;</span>
  <span class="c1">// the reference count is decremented when mySharedObject</span>
  <span class="c1">// goes out of scope. Since it&#39;s not zero after decrementing, the</span>
  <span class="c1">// MyClass instance is not deleted until globalSharedObject</span>
  <span class="c1">// goes out of scope.</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="borrowing-from-shared">
<span id="index-42"></span><h3>Borrowing from <cite>shared</cite><a class="headerlink" href="#borrowing-from-shared" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#SharedObject.shared.borrow" title="SharedObject.shared.borrow"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">borrow</span></code></a> method returns the pointer managed by
the <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a>. This pointer is only valid as long as the
<a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> is storing that pointer. The compiler includes
some checking for errors in this case. In these ways,
<a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> is similar to <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a>.</p>
<p>See <a class="reference internal" href="#about-owned-borrowing"><span class="std std-ref">Borrowing from owned</span></a> for more details and examples.</p>
</section>
<section id="coercions-for-shared">
<span id="index-43"></span><h3>Coercions for <cite>shared</cite><a class="headerlink" href="#coercions-for-shared" title="Link to this heading">¶</a></h3>
<p>As with <a class="reference internal" href="#OwnedObject.owned" title="OwnedObject.owned"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">owned</span></code></a>, <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> supports
coercions to the class type, as well as
coercions from a <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">T</span></code> to <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">U</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a
subclass of <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
<p>See <a class="reference internal" href="#about-owned-coercions"><span class="std std-ref">Coercions for owned</span></a> for more details and examples.</p>
</section>
<section id="shared-default-intent">
<span id="index-44"></span><h3><cite>shared</cite> Default Intent<a class="headerlink" href="#shared-default-intent" title="Link to this heading">¶</a></h3>
<p>The default intent for <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> is <code class="docutils literal notranslate"><span class="pre">const</span></code>. See more on
argument intents in the <a class="reference internal" href="../../primers/procedures.html#primers-procedures"><span class="std std-ref">Procedures Primer</span></a> and see
more on the default intent in the <a class="reference internal" href="procedures.html#intents-for-owned-and-shared"><span class="std std-ref">Default and ‘const’ Intents for ’owned’ and ’shared’</span></a>.</p>
</section>
</section>
<section id="methods-on-shared-classes">
<span id="shared-methods"></span><span id="index-45"></span><h2>Methods on <cite>shared</cite> Classes<a class="headerlink" href="#methods-on-shared-classes" title="Link to this heading">¶</a></h2>
<dl class="chpl type">
<dt class="sig sig-object chpl" id="SharedObject.shared">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">shared</span></span><em class="property"> <span class="pre">:</span> <span class="pre">writeSerializable,</span> <span class="pre">readDeserializable</span></em><a class="headerlink" href="#SharedObject.shared" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> manages the deletion of a class instance in a way
that supports multiple owners of the class instance.</p>
<p>This is currently implemented with task-safe reference counting.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="SharedObject.shared.init=">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">shared.</span></span><span class="sig-name descname"><span class="pre">init=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">src:</span> <span class="pre">shared</span></em><span class="sig-paren">)</span><a class="headerlink" href="#SharedObject.shared.init=" title="Link to this definition">¶</a></dt>
<dd><p>Copy-initializer. Creates a new <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a>
that refers to the same class instance as <cite>src</cite>.
These will share responsibility for managing the instance.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="SharedObject.shared.adopt">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">shared.</span></span><span class="sig-name descname"><span class="pre">adopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">obj:</span> <span class="pre">owned</span></em><span class="sig-paren">)</span><a class="headerlink" href="#SharedObject.shared.adopt" title="Link to this definition">¶</a></dt>
<dd><p>Changes the memory management strategy of the argument from <cite>owned</cite>
to <cite>shared</cite>, taking over the ownership of the argument.
The result type preserves nilability of the argument type.
If the argument is non-nilable, it must be recognized by the compiler
as an expiring value.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">shared.</span></span><span class="sig-name descname"><span class="pre">adopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">obj:</span> <span class="pre">unmanaged</span></em><span class="sig-paren">)</span></dt>
<dd><p>Starts managing the argument class instance <cite>obj</cite>
using the <cite>shared</cite> memory management strategy.
The result type preserves nilability of the argument type.</p>
<p>It is an error to directly delete the class instance
after passing it to <cite>shared.adopt()</cite>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="SharedObject.shared.deinit">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-prename descclassname"><span class="pre">shared.</span></span><span class="sig-name descname"><span class="pre">deinit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SharedObject.shared.deinit" title="Link to this definition">¶</a></dt>
<dd><p>The deinitializer for <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> will destroy the class
instance once there are no longer any copies of this
<a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> that refer to it.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="SharedObject.shared.borrow">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">shared.</span></span><span class="sig-name descname"><span class="pre">borrow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SharedObject.shared.borrow" title="Link to this definition">¶</a></dt>
<dd><p>Return the object managed by this <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> without
impacting its lifetime at all. It is an error to use the
value returned by this function after the last <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a>
goes out of scope or deletes the contained class instance
for another reason, including calls to
<cite>=</cite>, or <code class="docutils literal notranslate"><span class="pre">shared.retain</span></code> when this is the last <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a>
referring to the instance.
In some cases such errors are caught at compile-time.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="SharedObject.shared.downgrade">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">shared.</span></span><span class="sig-name descname"><span class="pre">downgrade</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SharedObject.shared.downgrade" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <cite>weak</cite> type is experimental; expect this method to change in the future.</p>
</div>
<p>Create a <a class="reference internal" href="../../modules/standard/WeakPointer.html#WeakPointer.weak" title="WeakPointer.weak"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">weak</span></code></a> reference to this object</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="SharedObject.=">
<em class="property"><span class="pre">operator</span> </em><span class="sig-name descname"><span class="pre">=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">lhs:</span> <span class="pre">shared</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">shared</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">!(isNonNilableClass(lhs)</span> <span class="pre">&amp;&amp;</span> <span class="pre">isNilableClass(rhs))</span></em><a class="headerlink" href="#SharedObject.=" title="Link to this definition">¶</a></dt>
<dd><p>Assign one <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> to another.
Deletes the object managed by <code class="docutils literal notranslate"><span class="pre">lhs</span></code> if there are
no other <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> referring to it. On return,
<code class="docutils literal notranslate"><span class="pre">lhs</span></code> will refer to the same object as <code class="docutils literal notranslate"><span class="pre">rhs</span></code>.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="SharedObject.&lt;=&gt;">
<em class="property"><span class="pre">operator</span> </em><span class="sig-name descname"><span class="pre">&lt;=&gt;</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">lhs:</span> <span class="pre">shared</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">rhs:</span> <span class="pre">shared</span></em><span class="sig-paren">)</span><a class="headerlink" href="#SharedObject.<=>" title="Link to this definition">¶</a></dt>
<dd><p>Swap two <a class="reference internal" href="#SharedObject.shared" title="SharedObject.shared"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">shared</span></code></a> objects.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="bytes.html" class="btn btn-neutral float-left" title="Bytes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="records.html" class="btn btn-neutral float-right" title="Records" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>