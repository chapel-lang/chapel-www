

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IO &mdash; Chapel Documentation 1.15</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  

  
    <link rel="top" title="Chapel Documentation 1.15" href="../../index.html"/>
        <link rel="up" title="Standard Modules" href="../standard.html"/>
        <link rel="next" title="List" href="List.html"/>
        <link rel="prev" title="Help" href="Help.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Chapel Documentation
          

          
          </a>

          
            
            
          

          
<?php   // Variables given by sphinx 
   $chplTitle = "1.15";   $pagename = "./modules/standard/IO";   include "../../versionButton.php";   ?>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assert.html">Assert</a></li>
<li class="toctree-l2"><a class="reference internal" href="Barrier.html">Barrier</a></li>
<li class="toctree-l2"><a class="reference internal" href="BigInteger.html">BigInteger</a></li>
<li class="toctree-l2"><a class="reference internal" href="BitOps.html">BitOps</a></li>
<li class="toctree-l2"><a class="reference internal" href="Buffers.html">Buffers</a></li>
<li class="toctree-l2"><a class="reference internal" href="CommDiagnostics.html">CommDiagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="DateTime.html">DateTime</a></li>
<li class="toctree-l2"><a class="reference internal" href="DynamicIters.html">DynamicIters</a></li>
<li class="toctree-l2"><a class="reference internal" href="FileSystem.html">FileSystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="GMP.html">GMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="Help.html">Help</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">IO</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#i-o-overview">I/O Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#design-rationale">Design Rationale</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-o-styles">I/O Styles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions-for-channel-creation">Functions for Channel Creation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronization-of-channel-data-and-avoiding-data-races">Synchronization of Channel Data and Avoiding Data Races</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-i-o-with-channels">Performing I/O with Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions-for-closing-channels">Functions for Closing Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-stdin-stdout-and-stderr-channels">The <code class="docutils literal"><span class="pre">stdin</span></code>, <code class="docutils literal"><span class="pre">stdout</span></code>, and <code class="docutils literal"><span class="pre">stderr</span></code> Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ensuring-successful-i-o">Ensuring Successful I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="#correspondence-to-c-i-o">Correspondence to C I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bytes-type">Bytes Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffers">Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#formatted-i-o">Formatted I/O</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview-of-format-strings">Overview of Format Strings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formatted-i-o-for-c-programmers">Formatted I/O for C Programmers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-numeric-conversions">Generic Numeric Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integral-conversions">Integral Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real-conversions">Real Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complex-and-imaginary-conversions">Complex and Imaginary Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string-and-bytes-conversions">String and Bytes Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-conversions">General Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#note-about-whitespace">Note About Whitespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-string-syntax-in-detail">Format String Syntax in Detail</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specifiers"># Specifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">% Specifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formatted-i-o-examples">Formatted I/O Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#io-functions-and-types">IO Functions and Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="List.html">List</a></li>
<li class="toctree-l2"><a class="reference internal" href="Math.html">Math</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="Path.html">Path</a></li>
<li class="toctree-l2"><a class="reference internal" href="Random.html">Random</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reflection.html">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="Regexp.html">Regexp</a></li>
<li class="toctree-l2"><a class="reference internal" href="Spawn.html">Spawn</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sys.html">Sys</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysBasic.html">SysBasic</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysCTypes.html">SysCTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysError.html">SysError</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="UtilReplicatedVar.html">UtilReplicatedVar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Archived Language Specifications</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Chapel Documentation 1.15</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
      
    <li>IO</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/modules/standard/IO.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-IO"></span><div class="section" id="io">
<h1>IO<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p>Support for a variety of kinds of input and output.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All Chapel programs automatically <code class="docutils literal"><span class="pre">use</span></code> this module by default.
An explicit <code class="docutils literal"><span class="pre">use</span></code> statement is not necessary.</p>
</div>
<p>Input/output (I/O) facilities in Chapel include the types <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> and
<a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a>; the constants <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-record docutils literal"><span class="pre">stdin</span></code></a>, <a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-record docutils literal"><span class="pre">stdout</span></code></a> and
<a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-record docutils literal"><span class="pre">stderr</span></code></a>; the functions <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal"><span class="pre">open</span></code></a>, <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.close</span></code></a>,
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a>, <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a>, <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a>,
<a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a>, and many others.</p>
<div class="section" id="i-o-overview">
<span id="about-io-overview"></span><h2>I/O Overview<a class="headerlink" href="#i-o-overview" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> in Chapel identifies a file in the underlying operating
system.  Reads and writes to a file are done via one or more channels
associated with the file.  Each <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> uses a buffer to provide
sequential read or write access to its file, optionally starting at an offset.</p>
<p>For example, the following program opens a file and writes an integer to it:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="c1">// open the file &quot;test-file.txt&quot; for writing, creating it if</span>
<span class="c1">// it does not exist yet.</span>
<span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">iomode</span><span class="p">.</span><span class="nx">cw</span><span class="p">);</span>

<span class="c1">// create a writing channel starting at file offset 0</span>
<span class="c1">// (start and end offsets can be specified when creating the</span>
<span class="c1">// channel)</span>
<span class="kd">var</span> <span class="nx">myWritingChannel</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">writer</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>

<span class="c1">// This function will write the human-readable text version of x;</span>
<span class="c1">// binary I/O is also possible.</span>
<span class="nx">myWritingChannel</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="c1">// Now test-file.txt contains:</span>
<span class="c1">// 17</span>
</pre></div>
</div>
<p>Then, the following program can be used to read the integer:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="c1">// open the file &quot;test-file.txt&quot; for reading only</span>
<span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">iomode</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>

<span class="c1">// create a reading channel starting at file offset 0</span>
<span class="c1">// (start and end offsets can be specified when creating the</span>
<span class="c1">// channel)</span>
<span class="kd">var</span> <span class="nx">myReadingChannel</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">reader</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

<span class="c1">// Now read a textual integer. Note that the</span>
<span class="c1">// channel.read function returns a bool to indicate</span>
<span class="c1">// if it read something or if the end of the file</span>
<span class="c1">// was reached before something could be read.</span>
<span class="kd">var</span> <span class="nx">readSomething</span> <span class="o">=</span> <span class="nx">myReadingChannel</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Read integer &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
<span class="c1">// prints out:</span>
<span class="c1">// 17</span>
</pre></div>
</div>
</div>
<div class="section" id="design-rationale">
<h2>Design Rationale<a class="headerlink" href="#design-rationale" title="Permalink to this headline">¶</a></h2>
<p>Since channels operate independently, concurrent I/O to the same open file is
possible without contending for locks.  Furthermore, since the channel (and not
the file) stores the current file offset, it is straightforward to create
programs that access the same open file in parallel. Note that such parallel
access is not possible in C when multiple threads are using the same <code class="docutils literal"><span class="pre">FILE*</span></code>
to write to different regions of a file because of the race condition between
<code class="docutils literal"><span class="pre">fseek</span></code> and <code class="docutils literal"><span class="pre">fwrite</span></code>. Because of these issues, Chapel programmers wishing
to perform I/O will need to know how to open files as well as create channels.</p>
</div>
<div class="section" id="i-o-styles">
<span id="about-io-styles"></span><h2>I/O Styles<a class="headerlink" href="#i-o-styles" title="Permalink to this headline">¶</a></h2>
<p>Reading and writing of Chapel's basic types is regulated by an applicable
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a>.  In particular, the I/O style controls whether binary or
text I/O should be performed. For binary I/O it specifies, for example, byte
order and string encoding. For text I/O it specifies string representation; the
base, field width and precision for numeric types; and so on.  Each channel has
an associated I/O style.  It applies to all read/write operations on that
channel, except when the program specifies explicitly an I/O style for a
particular read or write.</p>
<p>See the definition for the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> type. This type represents I/O
styles and provides details on formatting and other representation choices.</p>
<p>The default value of the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> type is undefined.  However, the
compiler-generated constructor is available.  It can be used to generate the
default I/O style, with or without modifications. In addition, the function
<a class="reference internal" href="#IO.defaultIOStyle" title="IO.defaultIOStyle"><code class="xref chpl chpl-proc docutils literal"><span class="pre">defaultIOStyle</span></code></a> will return the default I/O style just as <code class="docutils literal"><span class="pre">new</span>
<span class="pre">iostyle()</span></code> will.</p>
<p>The I/O style for an I/O operation can be provided through an optional
<code class="docutils literal"><span class="pre">style=</span></code> argument in a variety of places:</p>
<blockquote>
<div><ul class="simple">
<li>when performing the I/O, e.g. in calls to <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a> or
<a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a></li>
<li>when creating the channel with <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a></li>
<li>or when creating the file with e.g. <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal"><span class="pre">open</span></code></a></li>
</ul>
</div></blockquote>
<p>Note that <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a>, or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> will copy the file's I/O
style if a <code class="docutils literal"><span class="pre">style=</span></code> argument is not provided. Also note that I/O functions on
channels will by default use the I/O style stored with that channel.</p>
<p>A channel's I/O style may be retrieved using <a class="reference internal" href="#IO.channel._style" title="IO.channel._style"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._style</span></code></a> and set
using <a class="reference internal" href="#IO.channel._set_style" title="IO.channel._set_style"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._set_style</span></code></a>. These functions should only be called while
the channel lock is held, however. See <a class="reference internal" href="#about-io-channel-synchronization"><span>Synchronization of Channel Data and Avoiding Data Races</span></a>
for more information on channel locks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> is work in progress: the fields and/or their types may
change. Among other changes, we expect to be replacing the types of some
multiple-choice fields from integral to enums.</p>
</div>
<p>As an example for specifying an I/O style, the code below specifies the minimum width for writing numbers so array elements are aligned in the output:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="nx">MyArray</span><span class="p">,</span> <span class="k">new</span> <span class="nx">iostyle</span><span class="p">(</span><span class="nx">min_width</span><span class="o">=</span><span class="mi">10</span><span class="p">));</span>
</pre></div>
</div>
<p>I/O facilities in Chapel also include several other ways to control I/O
formatting. There is support for <a class="reference internal" href="#about-io-formatted-io"><span>formatted I/O</span></a>
with <a class="reference internal" href="#IO.channel.readf" title="IO.channel.readf"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readf</span></code></a> and <a class="reference internal" href="#IO.channel.writef" title="IO.channel.writef"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writef</span></code></a>.  It is possible to write
data to strings (see &quot;The write and writeln Methods on Strings&quot; in the Chapel
language specification) which can then be further modified or combined
programmatically. Lastly, record or class implementations can provide custom
functions implementing read or write operations for that type (see &quot;The
readThis, writeThis, and readWriteThis Methods&quot; in the Chapel language
specification).</p>
</div>
<div class="section" id="files">
<span id="about-io-files"></span><h2>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h2>
<p>There are several functions that open a file and return a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> including <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal"><span class="pre">open</span></code></a>, <a class="reference internal" href="#IO.opentmp" title="IO.opentmp"><code class="xref chpl chpl-proc docutils literal"><span class="pre">opentmp</span></code></a>, <a class="reference internal" href="#IO.openmem" title="IO.openmem"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openmem</span></code></a>, <a class="reference internal" href="#IO.openfd" title="IO.openfd"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openfd</span></code></a>, and <a class="reference internal" href="#IO.openfp" title="IO.openfp"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openfp</span></code></a>.</p>
<p>Once a file is open, it is necessary to create associated channel(s) - see
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> and <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> - to write to and/or read from the
file.</p>
<p>Use the <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a> function to explicitly synchronize the file to
ensure that file data is committed to the file's underlying device for
persistence.</p>
<p>To release any resources associated with a file, it is necessary to first close
any channels using that file (with <a class="reference internal" href="#IO.channel.close" title="IO.channel.close"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.close</span></code></a>) and then the file
itself (with <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.close</span></code></a>).</p>
</div>
<div class="section" id="functions-for-channel-creation">
<span id="about-io-channel-creation"></span><h2>Functions for Channel Creation<a class="headerlink" href="#functions-for-channel-creation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> creates a channel for writing to a file, and
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> create a channel for reading from a file.</p>
</div>
<div class="section" id="synchronization-of-channel-data-and-avoiding-data-races">
<span id="about-io-channel-synchronization"></span><h2>Synchronization of Channel Data and Avoiding Data Races<a class="headerlink" href="#synchronization-of-channel-data-and-avoiding-data-races" title="Permalink to this headline">¶</a></h2>
<p>Channels (and files) contain locks in order to keep their operation safe for
multiple tasks. When creating a channel, it is possible to disable the lock
(for performance reasons) by passing <code class="docutils literal"><span class="pre">locking=false</span></code> to e.g.  file.writer().
Some channel methods - in particular those beginning with the underscore -
should only be called on locked channels.  With these methods, it is possible
to get or set the channel style, or perform I/O &quot;transactions&quot; (see
<a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._mark</span></code></a>). To use these methods, first lock the channel with
channel.lock(), call the methods you need, and then unlock the channel with
channel.unlock(). Note that in the future, we may move to alternative ways of
calling these functions that guarantee that they are not called on a channel
without the appropriate locking.</p>
<p>Besides data races that can occur if locking is not used in channels when it
should be, it is also possible for there to be data races on file data that is
buffered simultaneously in multiple channels.  The main way to avoid such data
races is the <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> synchronization operation.
<a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> will make all writes to the channel, if any, available to
concurrent viewers of its associated file, such as other channels or other
applications accessing this file concurrently. See the note below for
more details on the situation in which this kind of data race can occur.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Since channels can buffer data until <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> is called, it is
possible to write programs that have undefined behaviour because of race
conditions on channel buffers. In particular, the problem comes up for
programs that make:</p>
<blockquote>
<div><ul class="simple">
<li>concurrent operations on multiple channels that operate on overlapping
regions of a file</li>
<li>where at least one of the overlapping channels is a writing channel</li>
<li>and where data could be stored more than one of the overlapping channel's
buffers at the same time (ie, write and read ordering are not enforced
through <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> and other mean such as sync variables).</li>
</ul>
</div></blockquote>
<p>Note that it is possible in some cases to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> that does
not allow multiple channels at different offsets. Channels created on such
files will not change the file's position based on a <code class="docutils literal"><span class="pre">start=</span></code> offset
arguments. Instead, each read or write operation will use the file
descriptor's current position. Therefore, only one channel should be created
for files created in the following situations:</p>
<blockquote class="last">
<div><ul class="simple">
<li>with <a class="reference internal" href="#IO.openfp" title="IO.openfp"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openfp</span></code></a></li>
<li>with <a class="reference internal" href="#IO.openfd" title="IO.openfd"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openfd</span></code></a> when provided a non-seekable system file descriptor</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="performing-i-o-with-channels">
<h2>Performing I/O with Channels<a class="headerlink" href="#performing-i-o-with-channels" title="Permalink to this headline">¶</a></h2>
<p>Channels contain read and write methods, which are generic methods that can
read or write anything, and can also take optional arguments such as I/O style
or to return an error instead of halting. These functions generally take any
number of arguments. See:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a></li>
<li><a class="reference internal" href="#IO.channel.writeln" title="IO.channel.writeln"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writeln</span></code></a></li>
<li><a class="reference internal" href="#IO.channel.writebits" title="IO.channel.writebits"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writebits</span></code></a></li>
<li><a class="reference internal" href="#IO.channel.writef" title="IO.channel.writef"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writef</span></code></a> (see also <a class="reference internal" href="#about-io-formatted-io"><span>Formatted I/O</span></a>)</li>
<li><a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a></li>
<li><a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readln</span></code></a></li>
<li><a class="reference internal" href="#IO.channel.readbits" title="IO.channel.readbits"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readbits</span></code></a></li>
<li><a class="reference internal" href="#IO.channel.readf" title="IO.channel.readf"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readf</span></code></a> (see also <a class="reference internal" href="#about-io-formatted-io"><span>Formatted I/O</span></a>)</li>
</ul>
</div></blockquote>
<p>In addition, there are several convenient synonyms for <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a> and
<a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a>:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#IO.channel.readwrite" title="IO.channel.readwrite"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readwrite</span></code></a></li>
<li>the <a class="reference internal" href="#operator">&lt;~&gt; operator</a></li>
</ul>
</div></blockquote>
<p>Sometimes it's important to flush the buffer in a channel - to do that, use the
.flush() method. Flushing the buffer will make all writes available to other
applications or other views of the file (ie, it will call e.g. the OS call
pwrite).  It is also possible to close a channel, which will implicitly
flush it and release any buffer memory used by the channel.  Note that if you
need to ensure that data from a channel is on disk, you'll have to call
<a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> or <a class="reference internal" href="#IO.channel.close" title="IO.channel.close"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.close</span></code></a> and then <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a> on
the related file.</p>
</div>
<div class="section" id="functions-for-closing-channels">
<span id="about-io-closing-channels"></span><h2>Functions for Closing Channels<a class="headerlink" href="#functions-for-closing-channels" title="Permalink to this headline">¶</a></h2>
<p>A channel must be closed in order to free the resources allocated for it,
to ensure that data written to it is visible to other channels,
or to allow the associated file to be closed.</p>
<p>See <a class="reference internal" href="#IO.channel.close" title="IO.channel.close"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.close</span></code></a>.</p>
<p>It is an error to perform any I/O operations on a channel
that has been closed.
It is an error to close a file when it has channels that
have not been closed.</p>
<p>Files and channels are reference counted. Each file and channel is
closed automatically when no references to it remain. For example, if
a local variable is the only reference to a channel, the channel will
be closed when that variable goes out of scope.  Programs may also
close a file or channel explicitly.</p>
</div>
<div class="section" id="the-stdin-stdout-and-stderr-channels">
<span id="about-io-style"></span><h2>The <code class="docutils literal"><span class="pre">stdin</span></code>, <code class="docutils literal"><span class="pre">stdout</span></code>, and <code class="docutils literal"><span class="pre">stderr</span></code> Channels<a class="headerlink" href="#the-stdin-stdout-and-stderr-channels" title="Permalink to this headline">¶</a></h2>
<p>Chapel provides the predefined channels <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal"><span class="pre">stdin</span></code></a>, <a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal"><span class="pre">stdout</span></code></a>, and
<a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal"><span class="pre">stderr</span></code></a> to access the corresponding operating system streams standard
input, standard output, and standard error.</p>
<p><a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal"><span class="pre">stdin</span></code></a> supports reading;
<a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal"><span class="pre">stdout</span></code></a> and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal"><span class="pre">stderr</span></code></a> support writing.</p>
<p>All three channels are safe to use concurrently.
Their types' <code class="docutils literal"><span class="pre">kind</span></code> argument is <code class="docutils literal"><span class="pre">dynamic</span></code></p>
</div>
<div class="section" id="error-handling">
<span id="about-io-error-handling"></span><h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>Most I/O routines accept an optional <cite>error=</cite> argument. If that argument
is used, instead of halting when an error is encountered, the function
will return the error code.</p>
<p>These error codes are stored with the type <a class="reference internal" href="SysBasic.html#SysBasic.syserr" title="SysBasic.syserr"><code class="xref chpl chpl-type docutils literal"><span class="pre">SysBasic.syserr</span></code></a>. Success is
represented by <a class="reference internal" href="SysBasic.html#SysBasic.ENOERR" title="SysBasic.ENOERR"><code class="xref chpl chpl-proc docutils literal"><span class="pre">SysBasic.ENOERR</span></code></a>. The error codes and their meaning
are described in <a class="reference internal" href="SysBasic.html#module-SysBasic" title="SysBasic: Types for low-level programming and C integration."><code class="xref chpl chpl-mod docutils literal"><span class="pre">SysBasic</span></code></a>. Some of these error codes that are commonly used within the I/O implementation  include:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="SysBasic.html#SysBasic.EEOF" title="SysBasic.EEOF"><code class="xref chpl chpl-proc docutils literal"><span class="pre">SysBasic.EEOF</span></code></a> - the end of file was reached</li>
<li><a class="reference internal" href="SysBasic.html#SysBasic.ESHORT" title="SysBasic.ESHORT"><code class="xref chpl chpl-proc docutils literal"><span class="pre">SysBasic.ESHORT</span></code></a> - a read or write only returned part of the
requested data</li>
<li><a class="reference internal" href="SysBasic.html#SysBasic.EFORMAT" title="SysBasic.EFORMAT"><code class="xref chpl chpl-proc docutils literal"><span class="pre">SysBasic.EFORMAT</span></code></a> - data read did not adhere to the requested format</li>
<li><a class="reference internal" href="SysBasic.html#SysBasic.EILSEQ" title="SysBasic.EILSEQ"><code class="xref chpl chpl-const docutils literal"><span class="pre">SysBasic.EILSEQ</span></code></a> - illegal multibyte sequence (e.g. there was a
UTF-8 format error)</li>
<li><a class="reference internal" href="SysBasic.html#SysBasic.EOVERFLOW" title="SysBasic.EOVERFLOW"><code class="xref chpl chpl-const docutils literal"><span class="pre">SysBasic.EOVERFLOW</span></code></a> - data read did not fit into requested type
(e.g. reading 1000 into a <cite>uint(8)</cite>).</li>
</ul>
</div></blockquote>
<p>An error code can be converted to a string using the function
<a class="reference internal" href="SysError.html#SysError.errorToString" title="SysError.errorToString"><code class="xref chpl chpl-proc docutils literal"><span class="pre">errorToString</span></code></a>.</p>
</div>
<div class="section" id="ensuring-successful-i-o">
<span id="about-io-ensuring-successful-io"></span><h2>Ensuring Successful I/O<a class="headerlink" href="#ensuring-successful-i-o" title="Permalink to this headline">¶</a></h2>
<p>It is possible - in some situations - for I/O to fail without returning an
error. In cases where a programmer wants to be sure that there was no error
writing the data to disk, it is important to call <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a> to make
sure that data has arrived on disk without an error. Many errors can be
reported with typical operation, but some errors can only be reported by the
system during <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.close</span></code></a> or even <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a>.</p>
<p>When a file (or channel) is closed, data written to that file will be written
to disk eventually by the operating system. If an application needs to be sure
that the data is immediately written to persistent storage, it should use
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a> prior to closing the file.</p>
</div>
<div class="section" id="correspondence-to-c-i-o">
<h2>Correspondence to C I/O<a class="headerlink" href="#correspondence-to-c-i-o" title="Permalink to this headline">¶</a></h2>
<p>It is not possible to seek, read, or write to a file directly.
Create a channel to proceed.</p>
<p><a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> in Chapel has the same conceptual meaning as fflush() in
C.  However, fflush() is not necessarily called in channel.flush().  Unlike
fsync(), which is actually called in file.fsync() in Chapel.</p>
<p>The iomode constants in Chapel have the same meaning as the following
strings passed to fopen() in C:</p>
<blockquote>
<div><ul class="simple">
<li>iomode.r   &quot;r&quot;</li>
<li>iomode.rw  &quot;r+&quot;</li>
<li>iomode.cw  &quot;w&quot;</li>
<li>iomode.cwr &quot;w+&quot;</li>
</ul>
</div></blockquote>
<p>However, open() in Chapel does not necessarily invoke fopen().</p>
</div>
<div class="section" id="bytes-type">
<h2>Bytes Type<a class="headerlink" href="#bytes-type" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="Buffers.html#Buffers.bytes" title="Buffers.bytes"><code class="xref chpl chpl-record docutils literal"><span class="pre">Buffers.bytes</span></code></a> object is just some data in memory along with a
size. Bytes objects are reference counted, and the memory will be freed when
nothing refers to the bytes object any more.</p>
</div>
<div class="section" id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="Buffers.html#Buffers.buffer" title="Buffers.buffer"><code class="xref chpl chpl-record docutils literal"><span class="pre">Buffers.buffer</span></code></a> stores some number subsections of bytes objects.
It is efficient to go to a particular offset in a buffer, and to push or pop
bytes objects from the beginning or end of a buffer.</p>
<p>Buffers are used internally in each channel.</p>
</div>
<div class="section" id="formatted-i-o">
<span id="about-io-formatted-io"></span><h2>Formatted I/O<a class="headerlink" href="#formatted-i-o" title="Permalink to this headline">¶</a></h2>
<p>See below for a <a class="reference internal" href="#about-io-formatted-io-overview"><span>sample-based overview</span></a>
of the format strings. Further below, we describes the format string syntax
<a class="reference internal" href="#about-io-formatted-io-in-detail"><span>in detail</span></a>. Finally, we demonstrate the
functionality with <a class="reference internal" href="#about-io-formatted-io-examples"><span>example function calls</span></a>.</p>
<div class="section" id="overview-of-format-strings">
<span id="about-io-formatted-io-overview"></span><h3>Overview of Format Strings<a class="headerlink" href="#overview-of-format-strings" title="Permalink to this headline">¶</a></h3>
<p>In a manner similar to C's 'printf' and 'scanf', the IO package includes
<a class="reference internal" href="#IO.channel.writef" title="IO.channel.writef"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writef</span></code></a> and <a class="reference internal" href="#IO.channel.readf" title="IO.channel.readf"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readf</span></code></a> functions. These functions take
in a format string and some arguments. The <a class="reference internal" href="#IO.string.format" title="IO.string.format"><code class="xref chpl chpl-proc docutils literal"><span class="pre">string.format</span></code></a> method is also
available and is loosely equivalent to C's 'sprintf'. For example, one might do:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">writef</span><span class="p">(</span><span class="s">&quot;My favorite %s is %i\n&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">s</span><span class="p">:</span><span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;My favorite %s is %i&quot;</span><span class="p">.</span><span class="nx">format</span><span class="p">(</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>

<span class="c1">// prints:</span>
<span class="c1">// My favorite number is 7</span>
<span class="c1">// My favorite number is 7</span>
</pre></div>
</div>
<p>The following sections offer a tour through the conversions to illustrate the
common cases. A more precise definition follows in the &quot;Format String
Syntax in Detail&quot; section below.</p>
<p>In this file, we use &quot;integral&quot; to refer to the Chapel types int or uint and
&quot;floating-point&quot; to refer to real, imaginary, or complex, of any bit width.</p>
</div>
<div class="section" id="formatted-i-o-for-c-programmers">
<h3>Formatted I/O for C Programmers<a class="headerlink" href="#formatted-i-o-for-c-programmers" title="Permalink to this headline">¶</a></h3>
<p>This table is designed to help C programmers understand the equivalent
Chapel format specifiers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="16%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C</th>
<th class="head">Chapel</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>%i</td>
<td>%i</td>
<td>an integer in decimal</td>
</tr>
<tr class="row-odd"><td>%d</td>
<td>%i</td>
<td>an integer in decimal</td>
</tr>
<tr class="row-even"><td>%u</td>
<td>%u</td>
<td>an unsigned integer in decimal</td>
</tr>
<tr class="row-odd"><td>%x</td>
<td>%xu</td>
<td>an unsigned integer in hexadecimal</td>
</tr>
<tr class="row-even"><td>%g</td>
<td>%r</td>
<td>real number in exponential or decimal (if compact)</td>
</tr>
<tr class="row-odd"><td>%7.2g</td>
<td>%7.2r</td>
<td>real, 2 significant digits, padded to 7 columns</td>
</tr>
<tr class="row-even"><td>%f</td>
<td>%dr</td>
<td>real number always in decimal</td>
</tr>
<tr class="row-odd"><td>%7.3f</td>
<td>%7.3dr</td>
<td>real, 3 digits after <code class="docutils literal"><span class="pre">.</span></code>, padded to 7 columns</td>
</tr>
<tr class="row-even"><td>%e</td>
<td>%er</td>
<td>real number always in exponential</td>
</tr>
<tr class="row-odd"><td>%7.3e</td>
<td>%7.3er</td>
<td>real, 3 digits after <code class="docutils literal"><span class="pre">.</span></code>, padded to 7 columns</td>
</tr>
<tr class="row-even"><td>%s</td>
<td>%s</td>
<td>a string without any quoting</td>
</tr>
</tbody>
</table>
<p>Unlike in C, a value of the wrong type will be cast appropriately - so for
example printing 2 (an <code class="docutils literal"><span class="pre">int</span></code>)  with <code class="docutils literal"><span class="pre">%.2dr</span></code> will result in <code class="docutils literal"><span class="pre">2.00</span></code>.  Note
that <code class="docutils literal"><span class="pre">%n</span></code> and <code class="docutils literal"><span class="pre">%t</span></code> are equivalent to <code class="docutils literal"><span class="pre">%r</span></code> for real conversions and <code class="docutils literal"><span class="pre">%i</span></code>
for numeric conversions; so these are also equivalent to <code class="docutils literal"><span class="pre">%i</span></code> <code class="docutils literal"><span class="pre">%d</span></code> or
<code class="docutils literal"><span class="pre">%g</span></code> in C. Also note that Chapel format strings includes many capabilities
not available with C formatted I/O routines - including quoted strings,
binary numbers, complex numbers, and raw binary I/O.</p>
</div>
<div class="section" id="generic-numeric-conversions">
<h3>Generic Numeric Conversions<a class="headerlink" href="#generic-numeric-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%{##.###}</span></code></dt>
<dd><p class="first">decimal number padded on the left with spaces to 2 digits before
the point, rounded to 3 after. Works with integral, real, imaginary,
or complex arguments.</p>
<p class="last">In all cases, the output is padded on the left to the total length
of the conversion specifier (6 in this example).  The output
can be longer, when needed to accommodate the number.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">%{##}</span></code></dt>
<dd>integral value padded out to 2 digits. Also works with real, imaginary
or complex numbers by rounding them to integers. Numbers with more
digits will take up more space instead of being truncated.</dd>
</dl>
<p>In both conversions above, an imaginary argument gets an 'i' afterwards
and the entire expression is padded out to the width of ##### digits.
For example:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">writef</span><span class="p">(</span><span class="s">&quot;|${#####}|\n&quot;</span><span class="p">,</span> <span class="m">2.0i</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//   |   2i|</span>

<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;|%{#####.#}|\n&quot;</span><span class="p">,</span> <span class="m">2.0i</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//   |   2.0i|</span>
</pre></div>
</div>
<p>Complex arguments are printed in the format a + bi, where each of a and b is
rounded individually as if printed under that conversion on its own. Then, the
formatted complex number is padded to the requested size. For example:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">writef</span><span class="p">(</span><span class="s">&quot;|%{#########}|\n&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="m">2.0i</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//   |   1 + 2i|</span>

<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;|%{#########.#}|\n&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="m">2.0i</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//   | 1.0 + 2.0i|</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#about-io-formatted-pound-details"><span># Specifiers</span></a> for more details
on this conversion type.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%n</span></code></dt>
<dd>a &quot;number&quot; - equivalent to one of %i, %u, %r, %m, or %z below,
depending on the type</dd>
<dt><code class="docutils literal"><span class="pre">%17n</span></code></dt>
<dd>a number padded out to 17 columns</dd>
<dt><code class="docutils literal"><span class="pre">%.4n</span></code></dt>
<dd>a number with 4 significant digits or a precision of 4</dd>
</dl>
</div>
<div class="section" id="integral-conversions">
<h3>Integral Conversions<a class="headerlink" href="#integral-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%i</span></code> or <code class="docutils literal"><span class="pre">%di</span></code></dt>
<dd>a signed integer in decimal, possibly negative
(note - when reading an <code class="docutils literal"><span class="pre">%i</span></code>, <code class="docutils literal"><span class="pre">-</span></code> is allowed)</dd>
<dt><code class="docutils literal"><span class="pre">%u</span></code> or <code class="docutils literal"><span class="pre">%du</span></code></dt>
<dd>an unsigned decimal integer
(note - when reading a <code class="docutils literal"><span class="pre">%u</span></code>, <code class="docutils literal"><span class="pre">-</span></code> is not allowed)</dd>
<dt><code class="docutils literal"><span class="pre">%bi</span></code></dt>
<dd>a binary signed integer</dd>
<dt><code class="docutils literal"><span class="pre">%bu</span></code></dt>
<dd>a binary unsigned integer</dd>
<dt><code class="docutils literal"><span class="pre">%&#64;bu</span></code></dt>
<dd>a binary unsigned integer prefixed with <code class="docutils literal"><span class="pre">0b</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%oi</span></code></dt>
<dd>an octal signed integer</dd>
<dt><code class="docutils literal"><span class="pre">%ou</span></code></dt>
<dd>an octal unsigned integer</dd>
<dt><code class="docutils literal"><span class="pre">%&#64;ou</span></code></dt>
<dd>an octal unsigned integer prefixed with <code class="docutils literal"><span class="pre">0o</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%xu</span></code></dt>
<dd>a hexadecimal unsigned integer</dd>
<dt><code class="docutils literal"><span class="pre">%xi</span></code></dt>
<dd>a hexadecimal signed integer</dd>
<dt><code class="docutils literal"><span class="pre">%&#64;xu</span></code></dt>
<dd>a hexadecimal unsigned integer prefixed with <code class="docutils literal"><span class="pre">0x</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%Xu</span></code></dt>
<dd>a hexadecimal unsigned integer in uppercase</dd>
<dt><code class="docutils literal"><span class="pre">%&#64;Xu</span></code></dt>
<dd>a hexadecimal unsigned integer prefixed with <code class="docutils literal"><span class="pre">0X</span></code> and uppercase</dd>
<dt><code class="docutils literal"><span class="pre">%17i</span></code></dt>
<dd>a decimal integer padded on the left with spaces to 17 columns
(That is, it is right-justified in a 17-column field.
Padding width is ignored when reading integers)</dd>
<dt><code class="docutils literal"><span class="pre">%*i</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%17i</span></code> but read the minimum width from the preceding argument</dd>
<dt><code class="docutils literal"><span class="pre">%017i</span></code></dt>
<dd>a decimal integer padded on the left with zeros to 17 columns</dd>
<dt><code class="docutils literal"><span class="pre">%-17i</span></code></dt>
<dd>a decimal integer left-justified (padded on the right) to 17 columns</dd>
<dt><code class="docutils literal"><span class="pre">%+i</span></code></dt>
<dd>a decimal integer showing <code class="docutils literal"><span class="pre">+</span></code> for positive numbers</dd>
<dt><code class="docutils literal"><span class="pre">%</span> <span class="pre">i</span></code></dt>
<dd>a decimal integer with a space for positive numbers</dd>
<dt><code class="docutils literal"><span class="pre">%|4i</span></code></dt>
<dd>output 4 raw, binary bytes of the passed integer in native endianness</dd>
<dt><code class="docutils literal"><span class="pre">%&lt;4i</span></code></dt>
<dd>output 4 raw, binary bytes of the passed integer little endian</dd>
<dt><code class="docutils literal"><span class="pre">%&gt;4i</span></code></dt>
<dd>output 4 raw, binary bytes of the passed integer big endian</dd>
<dt><code class="docutils literal"><span class="pre">%&lt;8i</span></code></dt>
<dd>output 8 raw, binary bytes of the passed integer little endian
(byte widths of 1, 2, 4, and 8 are supported for integral conversions)</dd>
</dl>
</div>
<div class="section" id="real-conversions">
<h3>Real Conversions<a class="headerlink" href="#real-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%r</span></code></dt>
<dd>a real number with decimal or exponential notation, where
exponential is chosen if the decimal version would be too long</dd>
<dt><code class="docutils literal"><span class="pre">%6r</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%r</span></code> but padded on the left to 6 columns (ie right-justified)</dd>
<dt><code class="docutils literal"><span class="pre">%-6r</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%r</span></code> but padded on the right to 6 columns (ie left-justified)</dd>
<dt><code class="docutils literal"><span class="pre">%.4r</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%r</span></code> but with 4 significant digits</dd>
<dt><code class="docutils literal"><span class="pre">%.*r</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%.4r</span></code> but with significant digits read from preceding argument</dd>
<dt><code class="docutils literal"><span class="pre">%6.4r</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%r</span></code> but padded on the left to 6 columns
and with 4 significant digits</dd>
<dt><code class="docutils literal"><span class="pre">%*.*r</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%6.4r</span></code> but read minimum width and significant digits from
preceding arguments</dd>
<dt><code class="docutils literal"><span class="pre">%dr</span></code></dt>
<dd>a real number in decimal notation, e.g. <code class="docutils literal"><span class="pre">12.34</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%6dr</span></code></dt>
<dd>a decimal number padded on the left to 6 columns (right-justified)</dd>
<dt><code class="docutils literal"><span class="pre">%.4dr</span></code></dt>
<dd>a decimal number with 4 digits after the radix point</dd>
<dt><code class="docutils literal"><span class="pre">%6.4dr</span></code></dt>
<dd>a decimal number padded on the left to 6 columns and with 4 digits
after the radix point
(width and precision are ignored when reading numbers in readf)</dd>
<dt><code class="docutils literal"><span class="pre">%er</span></code></dt>
<dd>a real number in exponential notation, e.g. <code class="docutils literal"><span class="pre">8.2e-23</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%Er</span></code></dt>
<dd>like %er but with the 'e' in uppercase, e.g. <code class="docutils literal"><span class="pre">8.2E-23</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%.4er</span></code></dt>
<dd>exponential notation with 4 digits after the period, e.g. <code class="docutils literal"><span class="pre">8.2000e-23</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%xer</span></code></dt>
<dd>hexadecimal number using p to mark exponent e.g. <code class="docutils literal"><span class="pre">6c.3f7p-2a</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%|4r</span></code></dt>
<dd>emit 4 raw, binary bytes of the passed number in native endianness</dd>
<dt><code class="docutils literal"><span class="pre">%&lt;8r</span></code></dt>
<dd>emit 8 raw, binary bytes of the passed number in little endian</dd>
<dt><code class="docutils literal"><span class="pre">%&lt;4r</span></code></dt>
<dd>emit 4 raw, binary bytes of the passed number in little endian
(<code class="docutils literal"><span class="pre">&lt;</span></code> <code class="docutils literal"><span class="pre">|</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code> are supported for widths 4 or 8)</dd>
</dl>
</div>
<div class="section" id="complex-and-imaginary-conversions">
<h3>Complex and Imaginary Conversions<a class="headerlink" href="#complex-and-imaginary-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%m</span></code></dt>
<dd>an imaginary number, like a real with <code class="docutils literal"><span class="pre">%r</span></code> but ends with an <code class="docutils literal"><span class="pre">i</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%z</span></code></dt>
<dd>print complex number with <code class="docutils literal"><span class="pre">%r</span></code> for each part in the format <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">bi</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%&#64;z</span></code></dt>
<dd>print complex number with <code class="docutils literal"><span class="pre">%r</span></code> for each part in the format <code class="docutils literal"><span class="pre">(a,b)</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%6z</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%z</span></code> but pad the entire complex number out to 6 columns</dd>
<dt><code class="docutils literal"><span class="pre">%6.4z</span></code></dt>
<dd>print a and b 4 significant digits and pad the entire complex
number out to 6 columns</dd>
<dt><code class="docutils literal"><span class="pre">%dz</span></code></dt>
<dd>print a and b with <code class="docutils literal"><span class="pre">%dr</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%ez</span></code></dt>
<dd>print a and b with <code class="docutils literal"><span class="pre">%er</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%|4m</span></code></dt>
<dd>same as <code class="docutils literal"><span class="pre">%|4r</span></code></dd>
<dt><code class="docutils literal"><span class="pre">%|8z</span></code></dt>
<dd>emit 8 raw, binary bytes of native-endian complex (a,b are each 4 bytes)</dd>
<dt><code class="docutils literal"><span class="pre">%&lt;16z</span></code></dt>
<dd>emit 16 raw, binary bytes of little-endian complex (a,b each 8 bytes)</dd>
</dl>
</div>
<div class="section" id="string-and-bytes-conversions">
<h3>String and Bytes Conversions<a class="headerlink" href="#string-and-bytes-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%s</span></code></dt>
<dd>a string. When reading, read until whitespace.
Note that if you want to be able to read your string back in,
you should use one of the quoted or encoded binary versions (see below),
since generally with %s it's not clear where the string ends.</dd>
<dt><code class="docutils literal"><span class="pre">%c</span></code></dt>
<dd>a single Unicode character (argument should be a string or an integral
storing the character code)</dd>
<dt><code class="docutils literal"><span class="pre">%17s</span></code></dt>
<dd><ul class="first last simple">
<li>when writing - a string left padded (right justified) to 17 columns</li>
<li>when reading - read up to 17 bytes or a whitespace, whichever comes
first, rounding down to whole characters</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">%-17s</span></code></dt>
<dd><ul class="first last simple">
<li>when writing - a string right padded (left justified) to 17 columns</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">%.17s</span></code></dt>
<dd><ul class="first last simple">
<li>when writing - a string truncated to 17 columns. When combined
with quoting strings, for example <code class="docutils literal"><span class="pre">%.17&quot;S</span></code>, the conversion
will print ... after a string if it was truncated. The
truncation includes leaving room for the quotes and -
if needed - the periods, so the shortest truncated
string is <code class="docutils literal"><span class="pre">&quot;&quot;...</span></code>  Generally, you won't be able to read
these back in.</li>
<li>when reading - read exactly 17 Unicode code points</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">%|17s</span></code></dt>
<dd><ul class="first last simple">
<li>when writing - emit string but cause runtime error if length
does not match</li>
<li>when reading - read exactly 17 bytes (error if we read &lt; 17 bytes)</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">%|*s</span></code></dt>
<dd>as with %17s but the length is specified in the argument before the string.</dd>
<dt><code class="docutils literal"><span class="pre">%&quot;S</span></code></dt>
<dd>use double-quotes to delimit string</dd>
<dt><code class="docutils literal"><span class="pre">%'S</span></code></dt>
<dd>use single-quotes to delimit string</dd>
<dt><code class="docutils literal"><span class="pre">%cS</span></code></dt>
<dd>use any character (c) to delimit string</dd>
<dt><code class="docutils literal"><span class="pre">%{(S)}</span></code></dt>
<dd>quoted string, starting with <code class="docutils literal"><span class="pre">(</span></code>, ending with <code class="docutils literal"><span class="pre">)</span></code>, where the
parens could be replaced by arbitrary characters</dd>
<dt><code class="docutils literal"><span class="pre">%*S</span></code></dt>
<dd>quoted string, the arg before the string to specifies quote character</dd>
<dt><code class="docutils literal"><span class="pre">%|0S</span></code></dt>
<dd>write a string null-terminated or read bytes until a null-terminator</dd>
<dt><code class="docutils literal"><span class="pre">%|*S</span></code></dt>
<dd>means read bytes until a terminator byte. The terminator byte is read
from the argument before the string.</dd>
<dt><code class="docutils literal"><span class="pre">%|1S</span></code> <code class="docutils literal"><span class="pre">%|2S</span></code> <code class="docutils literal"><span class="pre">%|4S</span></code> and <code class="docutils literal"><span class="pre">%|8S</span></code></dt>
<dd>work with encoded strings storing a length
and then the string data. The digit before <code class="docutils literal"><span class="pre">S</span></code> is
the number of bytes of length which is by default
stored native endian. <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> can be used
to specify the endianness of the length field,
for example <code class="docutils literal"><span class="pre">%&lt;8S</span></code> is 8 bytes of little-endian length
and then string data.</dd>
<dt><code class="docutils literal"><span class="pre">%|vS</span></code></dt>
<dd>as with <code class="docutils literal"><span class="pre">%|1S</span></code>-<code class="docutils literal"><span class="pre">%|8S</span></code> but the string length is encoded using a
variable-length byte scheme (which is always the same no matter what
endianness). In this scheme, the high bit of each encoded length byte
records whether or not there are more length bytes (and the remaining
bits encode the length in a big-endian manner).</dd>
<dt><code class="docutils literal"><span class="pre">%|*vS</span></code> or <code class="docutils literal"><span class="pre">%|*0S</span></code></dt>
<dd>read an encoded string but limit it to a number of bytes
read from the argument before the string; when writing
cause a runtime error if the string is longer than the
maximum.</dd>
<dt><code class="docutils literal"><span class="pre">%/a+/</span></code></dt>
<dd>where any regular expression can be used instead of <code class="docutils literal"><span class="pre">a+</span></code>
consume one or more 'a's when reading, gives an error when printing,
and does not assign to any arguments
(note - regular expression support is dependent on RE2 build;
see <a class="reference internal" href="Regexp.html#module-Regexp" title="Regexp: Regular expression support."><code class="xref chpl chpl-mod docutils literal"><span class="pre">Regexp</span></code></a>)</dd>
<dt><code class="docutils literal"><span class="pre">%/(a+)/</span></code></dt>
<dd>consume one or more 'a's and then set the corresponding string
argument to the read value</dd>
<dt><code class="docutils literal"><span class="pre">%17/a+/</span></code></dt>
<dd>match a regular expression up to 17 bytes
(note that <code class="docutils literal"><span class="pre">%.17/a+/</span></code>, which would mean to match 17 characters,
is not supported).</dd>
<dt><code class="docutils literal"><span class="pre">%/*/</span></code></dt>
<dd>next argument contains the regular expression to match</dd>
</dl>
</div>
<div class="section" id="general-conversions">
<h3>General Conversions<a class="headerlink" href="#general-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%t</span></code></dt>
<dd>read or write the object according to its readThis/writeThis routine</dd>
<dt><code class="docutils literal"><span class="pre">%jt</span></code></dt>
<dd>read or write an object in JSON format using readThis/writeThis</dd>
<dt><code class="docutils literal"><span class="pre">%ht</span></code></dt>
<dd>read or write an object in Chapel syntax using readThis/writeThis</dd>
<dt><code class="docutils literal"><span class="pre">%|t</span></code></dt>
<dd>read or write an object in binary native-endian with readThis/writeThis</dd>
<dt><code class="docutils literal"><span class="pre">%&lt;t</span></code></dt>
<dd>read or write an object little-endian in binary with readThis/writeThis</dd>
<dt><code class="docutils literal"><span class="pre">%&gt;t</span></code></dt>
<dd>read or write an object big-endian in binary with readThis/writeThis</dd>
</dl>
</div>
<div class="section" id="note-about-whitespace">
<h3>Note About Whitespace<a class="headerlink" href="#note-about-whitespace" title="Permalink to this headline">¶</a></h3>
<p>When reading, <code class="docutils literal"><span class="pre">\n</span></code> in a format string matches any zero or more space
characters other than newline and then exactly one newline character. In
contrast, <code class="docutils literal"><span class="pre">&quot;</span> <span class="pre">&quot;</span></code> matches at least one space character of any kind.</p>
<p>When writing, whitespace is printed from the format string just like any
other literal would be.</p>
<p>Finally, space characters after a binary conversion will be ignored, so
that a binary format string can appear more readable.</p>
</div>
<div class="section" id="format-string-syntax-in-detail">
<span id="about-io-formatted-io-in-detail"></span><h3>Format String Syntax in Detail<a class="headerlink" href="#format-string-syntax-in-detail" title="Permalink to this headline">¶</a></h3>
<p>Chapel's format strings are simpler than those in C in one way: it is no longer
necessary to specify the types of the arguments in the format string. For
example, in C the l in %ld is specifying the type of the argument for integer
(decimal) conversion. That is not necessary in Chapel since the compiler is
able to use type information from the call.</p>
<p>Format strings in Chapel consist of:</p>
<blockquote>
<div><ul>
<li><p class="first">conversion specifiers e.g. <code class="docutils literal"><span class="pre">&quot;%xi&quot;</span></code> (described below)</p>
</li>
<li><p class="first">newline e.g. <code class="docutils literal"><span class="pre">&quot;\n&quot;</span></code></p>
<ul class="simple">
<li>when writing - prints a newline</li>
<li>when reading - reads any amount of non-newline whitespace and then
exactly one newline. Causes the format string not to
match if it did not read a newline.</li>
</ul>
</li>
<li><p class="first">other whitespace e.g. <code class="docutils literal"><span class="pre">&quot;</span> <span class="pre">&quot;</span></code></p>
<blockquote>
<div><ul class="simple">
<li>when writing - prints as the specified whitespace</li>
<li>when reading - matches at least one character of whitespace, possibly
including newlines.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">other text e.g. &quot;test&quot;</p>
<blockquote>
<div><ul class="simple">
<li>when writing - prints the specified text</li>
<li>when reading - matches the specified text</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="specifiers">
<span id="about-io-formatted-pound-details"></span><h3># Specifiers<a class="headerlink" href="#specifiers" title="Permalink to this headline">¶</a></h3>
<p>All # specifiers must be enclosed in <code class="docutils literal"><span class="pre">%{}</span></code> syntax, for example <code class="docutils literal"><span class="pre">%{#}</span></code> is the
shortest one, and <code class="docutils literal"><span class="pre">%{#.#}</span></code> is a more typical one. The integer portion of the
number will be padded out to match the number of <code class="docutils literal"><span class="pre">#</span></code> s before the decimal
point, and the number of <code class="docutils literal"><span class="pre">#</span></code> s after the decimal point indicate how many
digits to print after the decimal point. In other words, display how many
digits to use when printing a floating-point number by using the # symbol to
stand for digits. The fractional portion of the number will be rounded
appropriately and extra space will be made if the integer portion is too small:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">writef</span><span class="p">(</span><span class="s">&quot;n:%{###.###}\n&quot;</span><span class="p">,</span> <span class="mf">1.2349</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// n:  1.235</span>
</pre></div>
</div>
<p>This syntax also works for numbers without a decimal point by rounding them
appropriately.</p>
<p>A # specifier may start with a <code class="docutils literal"><span class="pre">.</span></code>.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%{.##}\n&quot;</span><span class="p">,</span> <span class="mf">0.777</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//  0.78</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h3>% Specifiers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Specifiers starting with % offer quite a few options. First, some basic
rules.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">%%</span></code></dt>
<dd>means a literal <code class="docutils literal"><span class="pre">%</span></code></dd>
<dt><code class="docutils literal"><span class="pre">\n</span></code></dt>
<dd>means a literal newline</dd>
<dt><code class="docutils literal"><span class="pre">\\</span></code></dt>
<dd>means a single backslash</dd>
<dt><code class="docutils literal"><span class="pre">%{}</span></code></dt>
<dd>curly braces can wrap a <code class="docutils literal"><span class="pre">%</span></code> or <code class="docutils literal"><span class="pre">#</span></code> conversion specifier. That way, even
odd specifiers can be interpreted unambiguously. Some of the more complex
features require the use of the <code class="docutils literal"><span class="pre">%{}</span></code> syntax, but it's always
acceptable to use curly braces to make the format string clearer.
Curly braces are required for # conversion specifiers.</dd>
</dl>
<p>In general, a <code class="docutils literal"><span class="pre">%</span></code> specifier consists of either text or binary conversions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>%
[optional endian flag (binary conversions only)]
[optional flags]
[optional field width or size in bytes]
[optional . then precision]
[optional base flag]
[optional exponential type]
[conversion type]
</pre></div>
</div>
<p>Going through each section for text conversions:</p>
<dl class="docutils">
<dt>[optional flags]</dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal"><span class="pre">&#64;</span></code></dt>
<dd>means &quot;alternate form&quot;. It means to print out a base when not using
decimal (e.g. <code class="docutils literal"><span class="pre">0xFFF</span></code> or <code class="docutils literal"><span class="pre">0b101011</span></code>); and it will format a complex
number with parens instead of as e.g. <code class="docutils literal"><span class="pre">1.0+2.0i</span></code></dd>
<dt><code class="docutils literal"><span class="pre">+</span></code></dt>
<dd>means to show a plus sign when printing positive numbers</dd>
<dt><code class="docutils literal"><span class="pre">0</span></code></dt>
<dd>means to pad numeric conversions with 0 instead of space</dd>
<dt><code class="docutils literal"><span class="pre">&quot;</span> <span class="pre">&quot;</span></code></dt>
<dd>(a space) leaves a blank before a positive number
(in order to help line up with negative numbers)</dd>
<dt><code class="docutils literal"><span class="pre">-</span></code></dt>
<dd>left-justify the converted value instead of right-justifying.
Note, if both <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">-</span></code> are given, the effect is as if only <code class="docutils literal"><span class="pre">-</span></code>
were given.</dd>
<dt><code class="docutils literal"><span class="pre">~</span></code></dt>
<dd>when reading a record or class instance, skip over fields in the input not
present in the Chapel type. This flag currently only works in combination
with the JSON format.  This flag allows a Chapel program to describe only the
relevant fields in a record when the input might contain many more fields.</dd>
</dl>
</dd>
<dt>[optional field width]</dt>
<dd><p class="first">When printing numeric or string values, the field width specifies the number
of <em>columns</em> that the conversion should use to display the value. It can be
<code class="docutils literal"><span class="pre">*</span></code>, which means to read the field width from an integral argument before
the converted value.</p>
<p>For string conversions in readf (<code class="docutils literal"><span class="pre">%s</span></code> <code class="docutils literal"><span class="pre">%&quot;</span></code> <code class="docutils literal"><span class="pre">%'</span></code> <code class="docutils literal"><span class="pre">%//</span></code>), the field
width specifies the maximum number of bytes to read.</p>
<p class="last">For numeric conversions in readf, the field width is ignored.</p>
</dd>
<dt>[optional . then precision]</dt>
<dd><p class="first">When printing floating point values, the precision is used to control
the number of decimal digits to print.  For <code class="docutils literal"><span class="pre">%r</span></code> conversions, it
specifies the number of significant digits to print; for <code class="docutils literal"><span class="pre">%dr</span></code> or <code class="docutils literal"><span class="pre">%er</span></code>
conversions, it specifies the number of digits following the decimal point.
It can also be <code class="docutils literal"><span class="pre">*</span></code>, which means to read the precision from an integral
argument before the converted value.</p>
<p>For textual string conversions in writef, (<code class="docutils literal"><span class="pre">%s</span></code> <code class="docutils literal"><span class="pre">%&quot;</span></code> <code class="docutils literal"><span class="pre">%'</span></code>), the
precision indicates the maximum number of columns to print - and the result
will be truncated if it does not fit. In readf for these textual string
conversions, the precision indicates the maximum number of characters
(e.g. Unicode code points) to input.</p>
<p class="last">The precision is silently ignored for integral conversions
(<code class="docutils literal"><span class="pre">%i</span></code>, <code class="docutils literal"><span class="pre">%u</span></code>, etc) and for <code class="docutils literal"><span class="pre">%//</span></code> conversions.</p>
</dd>
<dt>[optional base flag]</dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal"><span class="pre">d</span></code></dt>
<dd>means decimal (and not exponential for floating-point)</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>means lower-case hexadecimal</dd>
<dt><code class="docutils literal"><span class="pre">X</span></code></dt>
<dd>means upper-case hexadecimal</dd>
<dt><code class="docutils literal"><span class="pre">o</span></code></dt>
<dd>means octal</dd>
<dt><code class="docutils literal"><span class="pre">b</span></code></dt>
<dd>means binary</dd>
<dt><code class="docutils literal"><span class="pre">j</span></code></dt>
<dd>means JSON-style strings, numbers, and structures</dd>
<dt><code class="docutils literal"><span class="pre">h</span></code></dt>
<dd>means Chapel-style strings, numbers, and structures</dd>
<dt><code class="docutils literal"><span class="pre">'</span></code></dt>
<dd>means single-quoted string (with \ and ')</dd>
<dt><code class="docutils literal"><span class="pre">&quot;</span></code></dt>
<dd>means double-quoted string (with \ and &quot;)</dd>
</dl>
</dd>
<dt>[optional exponential type]</dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal"><span class="pre">e</span></code></dt>
<dd>means floating-point conversion printing exponential <code class="docutils literal"><span class="pre">-12.34e+56</span></code></dd>
<dt><code class="docutils literal"><span class="pre">E</span></code></dt>
<dd>means floating-point conversion printing uppercase
exponential <code class="docutils literal"><span class="pre">-12.34E+56</span></code></dd>
</dl>
</dd>
<dt>[conversion type]</dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal"><span class="pre">t</span></code></dt>
<dd>means <em>type-based</em> or <em>thing</em> - uses writeThis/readThis but ignores
width and precision</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>means type-based number, allowing width and precision</dd>
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>means integral conversion</dd>
<dt><code class="docutils literal"><span class="pre">u</span></code></dt>
<dd>means unsigned integral conversion</dd>
<dt><code class="docutils literal"><span class="pre">r</span></code></dt>
<dd>means real conversion (e.g. <code class="docutils literal"><span class="pre">12.23</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>means imaginary conversion with an <code class="docutils literal"><span class="pre">i</span></code> after it (e.g. <code class="docutils literal"><span class="pre">12.23i</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">z</span></code></dt>
<dd>means complex conversion</dd>
<dt><code class="docutils literal"><span class="pre">s</span></code></dt>
<dd>means string conversion</dd>
<dt><code class="docutils literal"><span class="pre">S</span></code></dt>
<dd>means a quoted string conversion</dd>
<dt><code class="docutils literal"><span class="pre">{cS}</span></code></dt>
<dd>means string conversion with quote char <em>c</em></dd>
<dt><code class="docutils literal"><span class="pre">{*S}</span></code></dt>
<dd>means string conversion with quote char in argument before the string</dd>
<dt><code class="docutils literal"><span class="pre">{xSy}</span></code></dt>
<dd>means string conversion with left and right quote chars <em>x</em> and <em>y</em></dd>
<dt><code class="docutils literal"><span class="pre">/.../</span></code></dt>
<dd>means a regular expression (for reading only)</dd>
<dt><code class="docutils literal"><span class="pre">{/.../xyz}</span></code></dt>
<dd>means regular expression with flags <em>xyz</em></dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>means a Unicode character - either the first character in a string
or an integral character code</dd>
</dl>
</dd>
</dl>
<p>For binary conversions:</p>
<dl class="docutils">
<dt>[optional endian flag]</dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal"><span class="pre">&lt;</span></code></dt>
<dd>means little-endian</dd>
<dt><code class="docutils literal"><span class="pre">&gt;</span></code></dt>
<dd>means big-endian</dd>
<dt><code class="docutils literal"><span class="pre">|</span></code></dt>
<dd>means native-endian</dd>
</dl>
</dd>
<dt>[optional size in bytes]</dt>
<dd><p class="first">This is the number of bytes the format should read or write in this
conversion. For integral conversions (e.g. <code class="docutils literal"><span class="pre">%|i</span></code>) it specifies the number
of bytes in the integer, and 1, 2, 4, and 8 are supported. For real and
imaginary conversions, 4 and 8 are supported. For complex conversions,
8 and 16 are supported. The size in bytes is <em>required</em> for binary
integral and floating-point conversions.</p>
<p>The size can be <code class="docutils literal"><span class="pre">*</span></code>, which means that the number of bytes is read
from the argument before the conversion.</p>
<p class="last">For strings, if a terminator or length field is specified, exactly this
number is the maximum size in bytes; if the terminator or length is not
specified, the string must be exactly that size (and if the argument is not
exactly that number of bytes it will cause an error even when writing).</p>
</dd>
<dt>[conversion type]</dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal"><span class="pre">t</span></code></dt>
<dd>means <em>type-based</em> or <em>thing</em> - to read or write with readThis/writeThis</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>means type-based number (size is not mandatory)</dd>
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>means integral. Note that the size is mandatory for binary integral
conversions</dd>
<dt><code class="docutils literal"><span class="pre">u</span></code></dt>
<dd>means unsigned integral. Note that the size is mandatory for binary
integral conversions</dd>
<dt><code class="docutils literal"><span class="pre">r</span></code></dt>
<dd>means real. Note that the size is mandatory for binary real conversions</dd>
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>works the same as <code class="docutils literal"><span class="pre">r</span></code> for binary conversions</dd>
<dt><code class="docutils literal"><span class="pre">z</span></code></dt>
<dd>means complex. Note that the size is mandatory for binary complex
conversions</dd>
<dt><code class="docutils literal"><span class="pre">s</span></code></dt>
<dd><ul class="first last simple">
<li>means string binary I/O</li>
<li><code class="docutils literal"><span class="pre">%|17s</span></code> means exactly 17 byte string</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">0S</span></code>/<code class="docutils literal"><span class="pre">1S</span></code>/<code class="docutils literal"><span class="pre">2S</span></code>/<code class="docutils literal"><span class="pre">4S</span></code>/<code class="docutils literal"><span class="pre">8S</span></code></dt>
<dd><ul class="first last simple">
<li>mean encoded string binary I/O:</li>
<li><code class="docutils literal"><span class="pre">%|0S</span></code> means null-terminated string</li>
<li><code class="docutils literal"><span class="pre">%{|S*}</span></code> means  next-argument specifies string terminator byte</li>
<li><code class="docutils literal"><span class="pre">%|1S</span></code> means a one-byte length and then the string</li>
<li><code class="docutils literal"><span class="pre">%|2S</span></code> means a two-byte length and then the string</li>
<li><code class="docutils literal"><span class="pre">%|4S</span></code> means a four-byte length and then the string</li>
<li><code class="docutils literal"><span class="pre">%|8S</span></code> means an eight-byte length and then the string</li>
<li><code class="docutils literal"><span class="pre">%|vS</span></code> means a variable-byte-encoded length and then the string</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>means a Unicode character - either the first character in a string
or an integral character code</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="formatted-i-o-examples">
<span id="about-io-formatted-io-examples"></span><h3>Formatted I/O Examples<a class="headerlink" href="#formatted-i-o-examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%5i %5s %5r\n&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="mf">6.34</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//    1  test  6.34</span>

<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%2.4z\n&quot;</span><span class="p">,</span> <span class="mf">43.291</span> <span class="o">+</span> <span class="m">279.112i</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// 43.29 + 279.1i</span>

<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&lt;4u&quot;</span><span class="p">,</span> <span class="mh">0x11223344</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 4433 2211</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&gt;4u&quot;</span><span class="p">,</span> <span class="mh">0x11223344</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 1122 3344</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&lt;4i %&lt;4i&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output -- note that spaces after</span>
     <span class="c1">//  a binary format specifier are ignored)</span>
     <span class="c1">// 0200 0000 2000 0000</span>


<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%|0S\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 7465 7374 000a</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%|1S\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 0474 6573 740a</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&gt;2S\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 0004 7465 7374 0a</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&gt;4S\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 0000 0004 7465 7374 0a</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&gt;8S\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 0000 0000 0000 0004 7465 7374 0a</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%|vS\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (hexdump of the output)</span>
     <span class="c1">// 04 7465 7374 0a</span>

<span class="nx">writef</span><span class="p">(</span><span class="s">&#39;%&quot;S\n&#39;</span><span class="p">,</span> <span class="s">&quot;test \&quot;\&quot; \&#39;\&#39; !&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// &quot;test \&quot;\&quot; &#39;&#39; !&quot;</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%&#39;S\n&quot;</span><span class="p">,</span> <span class="s">&quot;test \&quot;\&quot; \&#39;\&#39; !&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// &#39;test &quot;&quot; \&#39;\&#39; !&#39;</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%{(S)}\n&quot;</span><span class="p">,</span> <span class="s">&quot;test ()&quot;</span><span class="p">,</span> <span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// (test (\))</span>


<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%40s|\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%-40s|\n&quot;</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">//                                     test|</span>
     <span class="c1">// test                                    |</span>

<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;123456\n&quot;</span><span class="p">);</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%6.6&#39;S\n&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">);</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%6.6&#39;S\n&quot;</span><span class="p">,</span> <span class="s">&quot;abcdefg&quot;</span><span class="p">);</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%.3&#39;S\n&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">);</span>
<span class="nx">writef</span><span class="p">(</span><span class="s">&quot;%.3&#39;S\n&quot;</span><span class="p">,</span> <span class="s">&quot;abcd&quot;</span><span class="p">);</span>
     <span class="c1">// outputs:</span>
     <span class="c1">// 123456</span>
     <span class="c1">//    &#39;a&#39;</span>
     <span class="c1">// &#39;a&#39;...</span>
     <span class="c1">// &#39;a&#39;</span>
     <span class="c1">// &#39;&#39;...</span>


<span class="kd">var</span> <span class="nx">s</span><span class="p">:</span><span class="kt">string</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">got</span> <span class="o">=</span> <span class="nx">readf</span><span class="p">(</span><span class="s">&quot; %c&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">);</span>
<span class="c1">// if the input is &quot; a&quot;, &quot;\na&quot;, &quot;  a&quot;, etc, s will contain &quot;a&quot;</span>
<span class="c1">// if the input is &quot;b&quot;, got will be false and s will contain &quot;&quot;</span>

<span class="kd">var</span> <span class="nx">s</span><span class="p">:</span><span class="kt">string</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">got</span> <span class="o">=</span> <span class="nx">readf</span><span class="p">(</span><span class="s">&quot;\n%c&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">);</span>
<span class="c1">// if the input is &quot;\na&quot;, or &quot; \na&quot;, s will contain &quot;a&quot;</span>
<span class="c1">// if the input is &quot;b&quot;, got will be false and s will be &quot;&quot;</span>

<span class="kd">var</span> <span class="nx">got</span> <span class="o">=</span> <span class="nx">readf</span><span class="p">(</span><span class="s">&quot;%/a+/&quot;</span><span class="p">);</span>
<span class="c1">// if the input is &quot;a&quot; or &quot;aa&quot; (and so on), got will return true</span>
<span class="c1">// if the input is &quot;c&quot; got will be false</span>

<span class="kd">var</span> <span class="nx">s</span><span class="p">:</span><span class="kt">string</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">got</span> <span class="o">=</span> <span class="nx">readf</span><span class="p">(</span><span class="s">&quot;%/a(b+)/&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">);</span>
<span class="c1">// if the input is &quot;c&quot; got will be false and s will be &quot;&quot;</span>
<span class="c1">// if the input is &quot;ab&quot;, got will be true and s will be &quot;b&quot;</span>
<span class="c1">// if the input is &quot;abb&quot;, got will be true and s will be &quot;bb&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="io-functions-and-types">
<h2>IO Functions and Types<a class="headerlink" href="#io-functions-and-types" title="Permalink to this headline">¶</a></h2>
<dl class="enum">
<dt id="IO.iomode">
<em class="property">enum </em><code class="descname">iomode</code> { r = 1, cw = 2, rw = 3, cwr = 4 }<a class="headerlink" href="#IO.iomode" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.iomode" title="IO.iomode"><code class="xref chpl chpl-type docutils literal"><span class="pre">iomode</span></code></a> type is an enum.
When used as arguments when opening files,
its constants have the following meaning:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">iomode.r</span></code> - open an existing file for reading.</li>
<li><code class="docutils literal"><span class="pre">iomode.rw</span></code> - open an existing file for reading and writing.</li>
<li><code class="docutils literal"><span class="pre">iomode.cw</span></code> - create a new file for writing.
If the file already exists, its contents are removed
when the file is opened in this mode.</li>
<li><code class="docutils literal"><span class="pre">iomode.cwr</span></code> - as with <code class="docutils literal"><span class="pre">iomode.cw</span></code> but reading from the
file is also allowed.</li>
</ul>
</dd></dl>

<dl class="enum">
<dt id="IO.iokind">
<em class="property">enum </em><code class="descname">iokind</code> { dynamic = 0, native = 1, big = 2, little = 3 }<a class="headerlink" href="#IO.iokind" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> type is an enum. When used as arguments to the
<a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type, its constants have the following meaning:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">iokind.big</span></code> means binary I/O with big-endian byte order is performed
when writing/reading basic types from the channel.</li>
<li><code class="docutils literal"><span class="pre">iokind.little</span></code> means binary I/O with little-endian byte order
(similar to <code class="docutils literal"><span class="pre">iokind.big</span></code> but with little-endian byte order).</li>
<li><code class="docutils literal"><span class="pre">iokind.native</span></code> means binary I/O in native byte order
(similar to <code class="docutils literal"><span class="pre">iokind.big</span></code> but with the byte order that is native
to the target platform).</li>
<li><code class="docutils literal"><span class="pre">iokind.dynamic</span></code> means that the applicable I/O style has full effect
and as a result the kind varies at runtime.</li>
</ul>
<p>In the case of <code class="docutils literal"><span class="pre">iokind.big</span></code>, <code class="docutils literal"><span class="pre">iokind.little</span></code>, and
<code class="docutils literal"><span class="pre">iokind.native</span></code> the applicable <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> is consulted when
writing/reading strings, but not for other basic types.</p>
<p>There are synonyms available for these values:</p>
<ul class="simple">
<li><a class="reference internal" href="#IO.iodynamic" title="IO.iodynamic"><code class="xref chpl chpl-proc docutils literal"><span class="pre">iodynamic</span></code></a> = <code class="docutils literal"><span class="pre">iokind.dynamic</span></code></li>
<li><a class="reference internal" href="#IO.ionative" title="IO.ionative"><code class="xref chpl chpl-proc docutils literal"><span class="pre">ionative</span></code></a> = <code class="docutils literal"><span class="pre">iokind.native</span></code></li>
<li><a class="reference internal" href="#IO.iobig" title="IO.iobig"><code class="xref chpl chpl-proc docutils literal"><span class="pre">iobig</span></code></a> = <code class="docutils literal"><span class="pre">iokind.big</span></code></li>
<li><a class="reference internal" href="#IO.iolittle" title="IO.iolittle"><code class="xref chpl chpl-proc docutils literal"><span class="pre">iolittle</span></code></a> = <code class="docutils literal"><span class="pre">iokind.little</span></code></li>
</ul>
</dd></dl>

<dl class="data">
<dt id="IO.iodynamic">
<em class="property">param </em><code class="descname">iodynamic</code> = iokind.dynamic<a class="headerlink" href="#IO.iodynamic" title="Permalink to this definition">¶</a></dt>
<dd><p>A synonym for <code class="docutils literal"><span class="pre">iokind.dynamic</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="data">
<dt id="IO.ionative">
<em class="property">param </em><code class="descname">ionative</code> = iokind.native<a class="headerlink" href="#IO.ionative" title="Permalink to this definition">¶</a></dt>
<dd><p>A synonym for <code class="docutils literal"><span class="pre">iokind.native</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="data">
<dt id="IO.iobig">
<em class="property">param </em><code class="descname">iobig</code> = iokind.big<a class="headerlink" href="#IO.iobig" title="Permalink to this definition">¶</a></dt>
<dd><p>A synonym for <code class="docutils literal"><span class="pre">iokind.big</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="data">
<dt id="IO.iolittle">
<em class="property">param </em><code class="descname">iolittle</code> = iokind.little<a class="headerlink" href="#IO.iolittle" title="Permalink to this definition">¶</a></dt>
<dd><p>A synonym for <code class="docutils literal"><span class="pre">iokind.little</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="enum">
<dt id="IO.iostringstyle">
<em class="property">enum </em><code class="descname">iostringstyle</code> { len1b_data = -1, len2b_data = -2, len4b_data = -4, len8b_data = -8, lenVb_data = -10, data_toeof = -65280, data_null = -256 }<a class="headerlink" href="#IO.iostringstyle" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum contains values used to control binary I/O with strings
via the <code class="docutils literal"><span class="pre">str_style</span></code> field in <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a>.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">iostringstyle.len1b_data</span></code> indicates a string format of 1 byte of
length followed by length bytes of string data.</li>
<li><code class="docutils literal"><span class="pre">iostringstyle.len2b_data</span></code> indicates a string format of 2 bytes of
length followed by length bytes of string data.</li>
<li><code class="docutils literal"><span class="pre">iostringstyle.len4b_data</span></code> indicates a string format of 4 bytes of
length followed by length bytes of string data.</li>
<li><code class="docutils literal"><span class="pre">iostringstyle.len8b_data</span></code> indicates a string format of 8 bytes of
length followed by length bytes of string data.</li>
<li><code class="docutils literal"><span class="pre">iostringstyle.lenVb_data</span></code> indicates a string format of a variable
number of bytes of length, encoded with high-bit meaning more bytes
of length follow, and where the 7-bits of length from each byte store
the 7-bit portions of the length in order from least-significant to
most-significant. This way of encoding a variable-byte length  matches
<a class="reference external" href="https://github.com/google/protobuf/">Google Protocol Buffers</a>.</li>
<li><code class="docutils literal"><span class="pre">iostringstyle.data_toeof</span></code> indicates a string format that contains
only the string data without any length or terminator. When reading,
this format will read a string until the end of the file is reached.</li>
<li><code class="docutils literal"><span class="pre">iostringstyle.data_null</span></code> indicates a string that is terminated
by a zero byte. It can be combined with other numeric
values to indicate a string terminated by a particular byte. For example,
to indicate a string terminated by <code class="docutils literal"><span class="pre">$</span></code> (which in ASCII has byte value 0x24),
one would use the value <code class="docutils literal"><span class="pre">iostringstyle.data_null|0x24</span></code>.</li>
<li>A positive and nonzero value indicates that a string of exactly that many
bytes should be read or written.</li>
</ul>
</dd></dl>

<dl class="enum">
<dt id="IO.iostringformat">
<em class="property">enum </em><code class="descname">iostringformat</code> { word = 0, basic = 1, chpl = 2, json = 3, toend = 4, toeof = 5 }<a class="headerlink" href="#IO.iostringformat" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum contains values used to control text I/O with strings
via the <code class="docutils literal"><span class="pre">string_format</span></code> field in <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a>.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">iostringformat.word</span></code> means string is as-is;
reading reads until whitespace. This is the default.</li>
<li><code class="docutils literal"><span class="pre">iostringformat.basic</span></code> means only escape <em>string_end</em> and <code class="docutils literal"><span class="pre">\</span></code>
with <code class="docutils literal"><span class="pre">\</span></code></li>
<li><code class="docutils literal"><span class="pre">iostringformat.chpl</span></code> means  escape <em>string_end</em>
<code class="docutils literal"><span class="pre">\</span></code> <code class="docutils literal"><span class="pre">'</span></code> <code class="docutils literal"><span class="pre">&quot;</span></code> <code class="docutils literal"><span class="pre">\n</span></code> with <code class="docutils literal"><span class="pre">\</span></code> and
nonprinting characters <code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">0xXY</span></code> with <code class="docutils literal"><span class="pre">\xXY</span></code></li>
<li><code class="docutils literal"><span class="pre">iostringformat.json</span></code> means  escape <em>string_end</em> <code class="docutils literal"><span class="pre">&quot;</span></code> and <code class="docutils literal"><span class="pre">\</span></code>
with <code class="docutils literal"><span class="pre">\</span></code>, and nonprinting characters <code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">\uABCD</span></code></li>
<li><code class="docutils literal"><span class="pre">iostringformat.toend</span></code> means string is as-is; reading reads until
<em>string_end</em></li>
<li><code class="docutils literal"><span class="pre">iostringformat.toeof</span></code> means string is as-is; reading reads until
end of file</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="IO.stringStyleTerminated">
<em class="property">proc </em><code class="descname">stringStyleTerminated</code><span class="sig-paren">(</span><em>terminator: uint(8)</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleTerminated" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> <code class="docutils literal"><span class="pre">str_style</span></code> value
to indicate a string format where strings are terminated by a
particular byte.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>terminator</strong> -- a byte value that the strings will be terminated by</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a value that indicates a string format where strings
are terminated by the terminator byte. This value is appropriate
to store in <a class="reference internal" href="#IO.iostyle.str_style" title="IO.iostyle.str_style"><code class="xref chpl chpl-var docutils literal"><span class="pre">iostyle.str_style</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.stringStyleNullTerminated">
<em class="property">proc </em><code class="descname">stringStyleNullTerminated</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleNullTerminated" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> <code class="docutils literal"><span class="pre">str_style</span></code> value
to indicate a string format where strings are terminated by a
zero byte.</p>
</dd></dl>

<dl class="function">
<dt id="IO.stringStyleExactLen">
<em class="property">proc </em><code class="descname">stringStyleExactLen</code><span class="sig-paren">(</span><em>len: int(64)</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleExactLen" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> <code class="docutils literal"><span class="pre">str_style</span></code> value
to indicate a string format where strings have an exact length.</p>
</dd></dl>

<dl class="function">
<dt id="IO.stringStyleWithVariableLength">
<em class="property">proc </em><code class="descname">stringStyleWithVariableLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleWithVariableLength" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> <code class="docutils literal"><span class="pre">str_style</span></code> value
to indicate a string format where string data is preceded by a variable-byte
length as described in <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostringstyle</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="IO.stringStyleWithLength">
<em class="property">proc </em><code class="descname">stringStyleWithLength</code><span class="sig-paren">(</span><em>lengthBytes: int</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleWithLength" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> <code class="docutils literal"><span class="pre">str_style</span></code> value
to indicate a string format where string data is preceded by a <code class="docutils literal"><span class="pre">lengthBytes</span></code>
of length. Only lengths of 1, 2, 4, or 8 are supported; if this method
is called with any other length, it will halt with an error.</p>
</dd></dl>

<dl class="data">
<dt id="IO.IOHINT_NONE">
<em class="property">const </em><code class="descname">IOHINT_NONE</code> = 0: c_int<a class="headerlink" href="#IO.IOHINT_NONE" title="Permalink to this definition">¶</a></dt>
<dd><p>IOHINT_NONE means normal operation, nothing special
to hint. Expect to use NONE most of the time.
The other hints can be bitwise-ORed in.</p>
</dd></dl>

<dl class="data">
<dt id="IO.IOHINT_RANDOM">
<em class="property">const </em><code class="descname">IOHINT_RANDOM</code> = QIO_HINT_RANDOM<a class="headerlink" href="#IO.IOHINT_RANDOM" title="Permalink to this definition">¶</a></dt>
<dd><p>IOHINT_RANDOM means we expect random access to a file</p>
</dd></dl>

<dl class="data">
<dt id="IO.IOHINT_SEQUENTIAL">
<em class="property">const </em><code class="descname">IOHINT_SEQUENTIAL</code> = QIO_HINT_SEQUENTIAL<a class="headerlink" href="#IO.IOHINT_SEQUENTIAL" title="Permalink to this definition">¶</a></dt>
<dd><p>IOHINT_SEQUENTIAL means expect sequential access. On
Linux, this should double the readahead.</p>
</dd></dl>

<dl class="data">
<dt id="IO.IOHINT_CACHED">
<em class="property">const </em><code class="descname">IOHINT_CACHED</code> = QIO_HINT_CACHED<a class="headerlink" href="#IO.IOHINT_CACHED" title="Permalink to this definition">¶</a></dt>
<dd><p>IOHINT_CACHED means we expect the entire file
to be cached and/or we pull it in all at
once. May request readahead on the entire file.</p>
</dd></dl>

<dl class="data">
<dt id="IO.IOHINT_PARALLEL">
<em class="property">const </em><code class="descname">IOHINT_PARALLEL</code> = QIO_HINT_PARALLEL<a class="headerlink" href="#IO.IOHINT_PARALLEL" title="Permalink to this definition">¶</a></dt>
<dd><p>IOHINT_PARALLEL means that we expect to have many
channels working with this file in parallel.
It might change the reading/writing implementation
to something more efficient in that scenario.</p>
</dd></dl>

<dl class="record">
<dt id="IO.iostyle">
<em class="property">record </em><code class="descname">iostyle</code><a class="headerlink" href="#IO.iostyle" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> type represents I/O styles
defining how Chapel's basic types should be read or written.</p>
<p>See <a class="reference internal" href="#about-io-style"><span>The stdin, stdout, and stderr Channels</span></a>.</p>
<dl class="attribute">
<dt id="IO.iostyle.binary">
<em class="property">var </em><code class="descname">binary</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform binary I/O? 1 - yes, 0 - no.
This field is ignored for <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> values other than <code class="docutils literal"><span class="pre">dynamic</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.byteorder">
<em class="property">var </em><code class="descname">byteorder</code>: uint(8) = iokind.native: uint(8)<a class="headerlink" href="#IO.iostyle.byteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>What byte order should we use when performing binary I/O?
This field is ignored for <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> values other than <code class="docutils literal"><span class="pre">dynamic</span></code>.
It should be set to a value in <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.str_style">
<em class="property">var </em><code class="descname">str_style</code>: int(64) = iostringstyle.data_toeof<a class="headerlink" href="#IO.iostyle.str_style" title="Permalink to this definition">¶</a></dt>
<dd><p>What string format should we use when writing strings
in binary mode? See <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostringstyle</span></code></a> for more information
on what the values of <code class="docutils literal"><span class="pre">str_style</span></code> mean.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.min_width_columns">
<em class="property">var </em><code class="descname">min_width_columns</code>: uint(32) = 0<a class="headerlink" href="#IO.iostyle.min_width_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>When performing text I/O, pad out to this many columns</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.max_width_columns">
<em class="property">var </em><code class="descname">max_width_columns</code>: uint(32) = max(uint(32))<a class="headerlink" href="#IO.iostyle.max_width_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>When performing text I/O, do not use more than this many columns</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.max_width_characters">
<em class="property">var </em><code class="descname">max_width_characters</code>: uint(32) = max(uint(32))<a class="headerlink" href="#IO.iostyle.max_width_characters" title="Permalink to this definition">¶</a></dt>
<dd><p>When performing text I/O, do not use more than this many characters</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.max_width_bytes">
<em class="property">var </em><code class="descname">max_width_bytes</code>: uint(32) = max(uint(32))<a class="headerlink" href="#IO.iostyle.max_width_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>When performing text I/O, do not use more than this many bytes</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.string_start">
<em class="property">var </em><code class="descname">string_start</code>: style_char_t = 34<a class="headerlink" href="#IO.iostyle.string_start" title="Permalink to this definition">¶</a></dt>
<dd><p>What character do we start strings with, when appropriate? Default is &quot;</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.string_end">
<em class="property">var </em><code class="descname">string_end</code>: style_char_t = 34<a class="headerlink" href="#IO.iostyle.string_end" title="Permalink to this definition">¶</a></dt>
<dd><p>What character do we end strings with, when appropriate? Default is &quot;</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.string_format">
<em class="property">var </em><code class="descname">string_format</code>: uint(8) = iostringformat.word: uint(8)<a class="headerlink" href="#IO.iostyle.string_format" title="Permalink to this definition">¶</a></dt>
<dd><p>How should we format strings when performing text I/O?
See <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostringstyle</span></code></a> for more information
on what the values of <code class="docutils literal"><span class="pre">str_style</span></code> mean.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.base">
<em class="property">var </em><code class="descname">base</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.base" title="Permalink to this definition">¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
what base should be used for the number? Default of 0 means decimal.
Bases 2, 8, 10, 16 are supported for integers. Bases 10 and 16
are supported for real values.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.point_char">
<em class="property">var </em><code class="descname">point_char</code>: style_char_t = 46<a class="headerlink" href="#IO.iostyle.point_char" title="Permalink to this definition">¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
how is the integer portion separated from the fractional portion?
Default is '.'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.exponent_char">
<em class="property">var </em><code class="descname">exponent_char</code>: style_char_t = 101<a class="headerlink" href="#IO.iostyle.exponent_char" title="Permalink to this definition">¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
how is the exponent written? Default is 'e'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.other_exponent_char">
<em class="property">var </em><code class="descname">other_exponent_char</code>: style_char_t = 112<a class="headerlink" href="#IO.iostyle.other_exponent_char" title="Permalink to this definition">¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
when base is &gt; 10, how is the exponent written? Default is 'e'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.positive_char">
<em class="property">var </em><code class="descname">positive_char</code>: style_char_t = 43<a class="headerlink" href="#IO.iostyle.positive_char" title="Permalink to this definition">¶</a></dt>
<dd><p>What character denotes a positive number? Default is '+'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.negative_char">
<em class="property">var </em><code class="descname">negative_char</code>: style_char_t = 45<a class="headerlink" href="#IO.iostyle.negative_char" title="Permalink to this definition">¶</a></dt>
<dd><p>What character denotes a negative number? Default is '-'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.i_char">
<em class="property">var </em><code class="descname">i_char</code>: style_char_t = 105<a class="headerlink" href="#IO.iostyle.i_char" title="Permalink to this definition">¶</a></dt>
<dd><p>What character follows an the imaginary number? Default is 'i'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.prefix_base">
<em class="property">var </em><code class="descname">prefix_base</code>: uint(8) = 1<a class="headerlink" href="#IO.iostyle.prefix_base" title="Permalink to this definition">¶</a></dt>
<dd><p>When writing in a base other than 10, should the prefix be used?
(e.g. hexadecimal numbers are prefixed with 0x)</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.pad_char">
<em class="property">var </em><code class="descname">pad_char</code>: style_char_t = 32<a class="headerlink" href="#IO.iostyle.pad_char" title="Permalink to this definition">¶</a></dt>
<dd><p>When padding with spaces, which pad character to use? Default is ' '</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.showplus">
<em class="property">var </em><code class="descname">showplus</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.showplus" title="Permalink to this definition">¶</a></dt>
<dd><p>When printing a positive numeric value, should the + be shown?</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.uppercase">
<em class="property">var </em><code class="descname">uppercase</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.uppercase" title="Permalink to this definition">¶</a></dt>
<dd><p>When printing a numeric value in hexadecimal, should it be
uppercase?</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.leftjustify">
<em class="property">var </em><code class="descname">leftjustify</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.leftjustify" title="Permalink to this definition">¶</a></dt>
<dd><p>When printing a numeric value in a field of specified width, should
the number be on the left (that is padded on the right?). The default
is to right-justify the number.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.showpoint">
<em class="property">var </em><code class="descname">showpoint</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.showpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>When printing an integral value using a real format, should a trailing
decimal point be included? If so, the value 0 will be written as '0.'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.showpointzero">
<em class="property">var </em><code class="descname">showpointzero</code>: uint(8) = 1<a class="headerlink" href="#IO.iostyle.showpointzero" title="Permalink to this definition">¶</a></dt>
<dd><p>When printing an integral value using a real format, should a trailing
decimal point and zero be included? If so, the value 0 will be written
as '0.0'</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.precision">
<em class="property">var </em><code class="descname">precision</code>: int(32) = -1<a class="headerlink" href="#IO.iostyle.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the precision for real format conversions. See the description
of realfmt below.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.realfmt">
<em class="property">var </em><code class="descname">realfmt</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.realfmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Formatting of real numbers:</p>
<blockquote>
<div><ul class="simple">
<li>0 means  print out 'precision' number of significant digits
(%g in printf)</li>
<li>1 means  print out 'precision' number of digits after the decimal point
(%f)</li>
<li>2 means  always use exponential and 'precision' number of digits (%e)</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.complex_style">
<em class="property">var </em><code class="descname">complex_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.complex_style" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.array_style">
<em class="property">var </em><code class="descname">array_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.array_style" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.aggregate_style">
<em class="property">var </em><code class="descname">aggregate_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.aggregate_style" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="IO.iostyle.tuple_style">
<em class="property">var </em><code class="descname">tuple_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.tuple_style" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="IO.defaultIOStyle">
<em class="property">proc </em><code class="descname">defaultIOStyle</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.defaultIOStyle" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the default I/O style. See <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a>
and <a class="reference internal" href="#about-io-styles"><span>I/O Styles</span></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.iostyle.native">
<em class="property">proc </em><code class="descclassname">iostyle.</code><code class="descname">native</code><span class="sig-paren">(</span><em>str_style: int(64) = stringStyleWithVariableLength()</em><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.native" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an I/O style indicating binary I/O in native byte order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>str_style</strong> -- see <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostringstyle</span></code></a> - which format to use when reading
or writing strings. Defaults to variable-byte length.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.iostyle.big">
<em class="property">proc </em><code class="descclassname">iostyle.</code><code class="descname">big</code><span class="sig-paren">(</span><em>str_style: int(64) = stringStyleWithVariableLength()</em><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.big" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an I/O style indicating binary I/O in big-endian byte order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>str_style</strong> -- see <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostringstyle</span></code></a> - which format to use when reading
or writing strings. Defaults to variable-byte length.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.iostyle.little">
<em class="property">proc </em><code class="descclassname">iostyle.</code><code class="descname">little</code><span class="sig-paren">(</span><em>str_style: int(64) = stringStyleWithVariableLength()</em><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.little" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an I/O style indicating binary I/O in little-endian byte order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>str_style</strong> -- see <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostringstyle</span></code></a> - which format to use when reading
or writing strings. Defaults to variable-byte length.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.iostyle.text">
<em class="property">proc </em><code class="descclassname">iostyle.</code><code class="descname">text</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an I/O style indicating text I/O.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="type">
<dt id="IO.iohints">
<em class="property">type </em><code class="descname">iohints</code> = c_int<a class="headerlink" href="#IO.iohints" title="Permalink to this definition">¶</a></dt>
<dd><p>A value of the <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a> type defines a set of hints about the I/O that
the file or channel will perform.  These hints may be used by the
implementation to select optimized versions of the I/O operations.</p>
<p>The <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a> type is implementation-defined.
The following <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a> constants are provided:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#IO.IOHINT_NONE" title="IO.IOHINT_NONE"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_NONE</span></code></a> defines an empty set, which provides no hints.</li>
<li><a class="reference internal" href="#IO.IOHINT_RANDOM" title="IO.IOHINT_RANDOM"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_RANDOM</span></code></a> suggests to expect random access.</li>
<li><a class="reference internal" href="#IO.IOHINT_SEQUENTIAL" title="IO.IOHINT_SEQUENTIAL"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_SEQUENTIAL</span></code></a> suggests to expect sequential access.</li>
<li><a class="reference internal" href="#IO.IOHINT_CACHED" title="IO.IOHINT_CACHED"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_CACHED</span></code></a> suggests that the file data is or should be
cached in memory, possibly all at once.</li>
<li><a class="reference internal" href="#IO.IOHINT_PARALLEL" title="IO.IOHINT_PARALLEL"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_PARALLEL</span></code></a> suggests to expect many channels
working with this file in parallel.</li>
</ul>
</div></blockquote>
<p>Other hints might be added in the future.</p>
<p>The following binary operators are defined on <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">|</span></code> for set union</li>
<li><code class="docutils literal"><span class="pre">&amp;</span></code> for set intersection</li>
<li><code class="docutils literal"><span class="pre">==</span></code> for set equality</li>
<li><code class="docutils literal"><span class="pre">1=</span></code> for set inequality</li>
</ul>
<p>When an <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a> formal has default intent, the
actual is copied to the formal upon a function call and
the formal cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a> type is undefined.</p>
</dd></dl>

<dl class="record">
<dt id="IO.file">
<em class="property">record </em><code class="descname">file</code><a class="headerlink" href="#IO.file" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> type is implementation-defined.  A value of the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> type refers to the state that is used by the implementation to
identify and interact with the OS file.</p>
<p>When a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> formal argument has default intent, the
actual is copied to the formal upon a function call and
the formal cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> type does not represent any OS file.
It is illegal to perform any I/O operations on the default value.</p>
</dd></dl>

<dl class="method">
<dt id="IO.file.check">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Halt if a file is invalid</p>
</dd></dl>

<dl class="method">
<dt id="IO.file.close">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">close</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a file.</p>
<p>In order to free the resources allocated for a file, it
must be closed using this method.</p>
<p>It is an error to perform any I/O operations on a file
that has been closed.
It is an error to close a file when it has channels that
have not been closed.</p>
<p>Closing a file does not guarantee immediate persistence of the performed
updates, if any. In cases where immediate persistence is important,
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a> should be used for that purpose prior to closing the file.
In particular, even though closing the file might complete without errors,
the data written might not persist in the event of a severe error like
running out of storage space or power loss. See also
<a class="reference internal" href="#about-io-ensuring-successful-io"><span>Ensuring Successful I/O</span></a>.</p>
<p>Files are automatically closed when the file variable
goes out of scope and all channels using that file are closed. Programs
may also explicitly close a file using this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.fsync">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">fsync</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Sync a file to disk.</p>
<p>Commits file data to the device associated with this file.
Data written to the file by a channel will be committed
only if the channel has been closed or flushed.</p>
<p>This function will typically call the <code class="docutils literal"><span class="pre">fsync</span></code> system call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.getPath">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">getPath</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span>: string<a class="headerlink" href="#IO.file.getPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path to an open file.</p>
<p>Note that not all files have a path (e.g. files opened with <a class="reference internal" href="#IO.openmem" title="IO.openmem"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openmem</span></code></a>),
and that this function may not work on all operating systems.</p>
<p>The function <a class="reference internal" href="Path.html#Path.file.realPath" title="Path.file.realPath"><code class="xref chpl chpl-proc docutils literal"><span class="pre">Path.file.realPath</span></code></a> is an alternative way
to get the path to a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.tryGetPath">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">tryGetPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: string<a class="headerlink" href="#IO.file.tryGetPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path to an open file, or return &quot;unknown&quot; if there was
a problem getting the path to the open file.</p>
</dd></dl>

<dl class="method">
<dt id="IO.file.path">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">path</code>: string<a class="headerlink" href="#IO.file.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path to an open file. Halt if there is an error getting the path.</p>
</dd></dl>

<dl class="method">
<dt id="IO.file.length">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: int(64)<a class="headerlink" href="#IO.file.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current length of an open file. Note that the length can always
change if other channels, tasks or programs are writing to the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the current file length</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.open">
<em class="property">proc </em><code class="descname">open</code><span class="sig-paren">(</span><em>out error: syserr</em>, <em>path: string = &quot;&quot;</em>, <em>mode: iomode</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>style: iostyle = defaultIOStyle()</em>, <em>url: string = &quot;&quot;</em><span class="sig-paren">)</span>: file<a class="headerlink" href="#IO.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file on a filesystem or stored at a particular URL. Note that once the
file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a>
to create a channel to actually perform I/O operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>path</strong> -- which file to open (for example, &quot;some/file.txt&quot;). This argument
is required unless the <code class="docutils literal"><span class="pre">url=</span></code> argument is used.</li>
<li><strong>iomode</strong> -- specify whether to open the file for reading or writing and
whether or not to create the file if it doesn't exist.
See <a class="reference internal" href="#IO.iomode" title="IO.iomode"><code class="xref chpl chpl-type docutils literal"><span class="pre">iomode</span></code></a>.</li>
<li><strong>hints</strong> -- optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>.</li>
<li><strong>style</strong> -- optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</li>
<li><strong>url</strong> -- optional argument to specify a URL to open. See <a class="reference internal" href="../packages/Curl.html#module-Curl" title="Curl: Simple support for many network protocols with libcurl"><code class="xref chpl chpl-mod docutils literal"><span class="pre">Curl</span></code></a> and
<a class="reference internal" href="../packages/HDFS.html#module-HDFS" title="HDFS: Support for Hadoop Distributed Filesystem"><code class="xref chpl chpl-mod docutils literal"><span class="pre">HDFS</span></code></a> for more information on <code class="docutils literal"><span class="pre">url=</span></code> support for those
systems. If HDFS is enabled, this function supports <code class="docutils literal"><span class="pre">url=</span></code>
arguments of the form &quot;hdfs://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;&quot;. If Curl is
enabled, this function supports <code class="docutils literal"><span class="pre">url=</span></code> starting with
<code class="docutils literal"><span class="pre">http://</span></code>, <code class="docutils literal"><span class="pre">https://</span></code>, <code class="docutils literal"><span class="pre">ftp://</span></code>, <code class="docutils literal"><span class="pre">ftps://</span></code>, <code class="docutils literal"><span class="pre">smtp://</span></code>,
<code class="docutils literal"><span class="pre">smtps://</span></code>, <code class="docutils literal"><span class="pre">imap://</span></code>, or <code class="docutils literal"><span class="pre">imaps://</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open file to the requested resource. If the <code class="docutils literal"><span class="pre">error=</span></code> argument
was provided and the file was not opened because of an error, returns
the default <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.openfd">
<em class="property">proc </em><code class="descname">openfd</code><span class="sig-paren">(</span><em>fd: fd_t</em>, <em>out error: syserr</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file<a class="headerlink" href="#IO.openfd" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Chapel file that works with a system file descriptor  Note that once
the file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> or
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> to create a channel to actually perform I/O operations</p>
<p>The system file descriptor will be closed when the Chapel file is closed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function can be used to create Chapel files that refer to system file
descriptors that do not support the <code class="docutils literal"><span class="pre">seek</span></code> functionality. For example, file
descriptors that represent pipes or open socket connections have this
property. In that case, the resulting file value should only be used with one
<a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> at a time.
The I/O system will ignore the channel offsets when reading or writing
to files backed by non-seekable file descriptors.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>fd</strong> -- a system file descriptor (obtained with <a class="reference internal" href="Sys.html#Sys.sys_open" title="Sys.sys_open"><code class="xref chpl chpl-proc docutils literal"><span class="pre">Sys.sys_open</span></code></a> or
<a class="reference internal" href="Sys.html#Sys.sys_connect" title="Sys.sys_connect"><code class="xref chpl chpl-proc docutils literal"><span class="pre">Sys.sys_connect</span></code></a> for example).</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>hints</strong> -- optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>.</li>
<li><strong>style</strong> -- optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> using the specified file descriptor.
If the <code class="docutils literal"><span class="pre">error=</span></code> argument
was provided and the file was not opened because of an error, returns
the default <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.openfp">
<em class="property">proc </em><code class="descname">openfp</code><span class="sig-paren">(</span><em>fp: _file</em>, <em>out error: syserr</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file<a class="headerlink" href="#IO.openfp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Chapel file that works with an open C file (ie a <code class="docutils literal"><span class="pre">FILE*</span></code>).  Note
that once the file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> or
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> to create a channel to actually perform I/O operations</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The resulting file value should only be used with one <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> at a
time. The I/O system will ignore the channel offsets when reading or writing
to a file opened with <a class="reference internal" href="#IO.openfp" title="IO.openfp"><code class="xref chpl chpl-proc docutils literal"><span class="pre">openfp</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>fp</strong> -- a C <code class="docutils literal"><span class="pre">FILE*</span></code> to work with</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>hints</strong> -- optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>.</li>
<li><strong>style</strong> -- optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> that uses the underlying FILE* argument.
If the <code class="docutils literal"><span class="pre">error=</span></code> argument
was provided and the file was not opened because of an error, returns
the default <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.opentmp">
<em class="property">proc </em><code class="descname">opentmp</code><span class="sig-paren">(</span><em>out error: syserr</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file<a class="headerlink" href="#IO.opentmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a temporary file. Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> to create a channel to actually
perform I/O operations.</p>
<p>The temporary file will be created in an OS-dependent temporary directory,
for example &quot;/tmp&quot; is the typical location. The temporary file will be
deleted upon closing.</p>
<p>Temporary files are always opened with <a class="reference internal" href="#IO.iomode" title="IO.iomode"><code class="xref chpl chpl-type docutils literal"><span class="pre">iomode</span></code></a> <code class="docutils literal"><span class="pre">iomode.cwr</span></code>;
that is, a new file is created that supports both writing and reading.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>hints</strong> -- optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>.</li>
<li><strong>style</strong> -- optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open temporary file. If the <code class="docutils literal"><span class="pre">error=</span></code> argument
was provided and the file was not opened because of an error, returns
the default <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.openmem">
<em class="property">proc </em><code class="descname">openmem</code><span class="sig-paren">(</span><em>out error: syserr</em>, <em>style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.openmem" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file that is backed by a buffer in memory that will not persist when the
file is closed.  Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> to create a channel to actually
perform I/O operations.</p>
<p>The resulting file supports both reading and writing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>style</strong> -- optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open memory file. If the <code class="docutils literal"><span class="pre">error=</span></code> argument
was provided and the file was not opened because of an error, returns
the default <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="record">
<dt id="IO.channel">
<em class="property">record </em><code class="descname">channel</code><a class="headerlink" href="#IO.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>A channel supports either sequential reading or sequential writing to an
underlying <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal"><span class="pre">file</span></code></a> object. A channel can buffer data. Read operations
on the channel might return old data. Write operations might not have an
immediate effect. Use <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> to control this buffering.</p>
<p>The <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type is implementation-defined.
A value of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type refers to the state that is used
to implement the channel operations.</p>
<p>When a <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> formal has default intent, the
actual is copied to the formal upon a function call and
the formal cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type is not associated
with any file and so cannot be used to perform I/O.</p>
<p>The <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type is generic.</p>
<dl class="attribute">
<dt id="IO.channel.writing">
<em class="property">param </em><code class="descname">writing</code>: bool<a class="headerlink" href="#IO.channel.writing" title="Permalink to this definition">¶</a></dt>
<dd><p>writing is a boolean indicating whether the channels of this type
support writing (when <cite>true</cite>) or reading (when <cite>false</cite>).</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.channel.kind">
<em class="property">param </em><code class="descname">kind</code>: iokind<a class="headerlink" href="#IO.channel.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>kind is an enum <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> that allows narrowing
this channel's I/O style for more efficient binary I/O.</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.channel.locking">
<em class="property">param </em><code class="descname">locking</code>: bool<a class="headerlink" href="#IO.channel.locking" title="Permalink to this definition">¶</a></dt>
<dd><p>locking is a boolean indicating whether it is safe to use this
channel concurrently (when <cite>true</cite>).</p>
</dd></dl>

</dd></dl>

<dl class="record">
<dt id="IO.ioChar">
<em class="property">record </em><code class="descname">ioChar</code><a class="headerlink" href="#IO.ioChar" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a Unicode code point. I/O routines (such as <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a>
and <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a>) can use arguments of this type in order to read or
write a single Unicode code point.</p>
<dl class="attribute">
<dt id="IO.ioChar.ch">
<em class="property">var </em><code class="descname">ch</code>: int(32)<a class="headerlink" href="#IO.ioChar.ch" title="Permalink to this definition">¶</a></dt>
<dd><p>The code point value</p>
</dd></dl>

</dd></dl>

<dl class="record">
<dt id="IO.ioNewline">
<em class="property">record </em><code class="descname">ioNewline</code><a class="headerlink" href="#IO.ioNewline" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a newline character or character sequence (ie <code class="docutils literal"><span class="pre">\n</span></code>). I/O routines
(such as <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a> and <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a>) can use arguments of
this type in order to read or write a newline. This is different from 'n'
because an ioNewline always produces an actual newline, but in some cases
writing <code class="docutils literal"><span class="pre">\n</span></code> will produce an escaped string (such as <code class="docutils literal"><span class="pre">&quot;\n&quot;</span></code>).</p>
<p>When reading an ioNewline, read routines will skip any character sequence
(including e.g. letters and numbers) to get to the newline character unless
<code class="docutils literal"><span class="pre">skipWhitespaceOnly</span></code> is set to true.</p>
<dl class="attribute">
<dt id="IO.ioNewline.skipWhitespaceOnly">
<em class="property">var </em><code class="descname">skipWhitespaceOnly</code>: bool = false<a class="headerlink" href="#IO.ioNewline.skipWhitespaceOnly" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally, we will skip anything at all to get to a n,
but if skipWhitespaceOnly is set, it will be an error
if we run into non-space characters other than n.</p>
</dd></dl>

</dd></dl>

<dl class="record">
<dt id="IO.ioLiteral">
<em class="property">record </em><code class="descname">ioLiteral</code><a class="headerlink" href="#IO.ioLiteral" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to represent a constant string we want to read or write.</p>
<p>When writing, the ioLiteral is output without any quoting or escaping.</p>
<p>When reading, the ioLiteral must be matched exactly - or else the read call
will return an error with code <a class="reference internal" href="SysBasic.html#SysBasic.EFORMAT" title="SysBasic.EFORMAT"><code class="xref chpl chpl-data docutils literal"><span class="pre">SysBasic.EFORMAT</span></code></a>.</p>
<dl class="attribute">
<dt id="IO.ioLiteral.val">
<em class="property">var </em><code class="descname">val</code>: string<a class="headerlink" href="#IO.ioLiteral.val" title="Permalink to this definition">¶</a></dt>
<dd><p>The value of the literal</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ioLiteral.ignoreWhiteSpace">
<em class="property">var </em><code class="descname">ignoreWhiteSpace</code>: bool = true<a class="headerlink" href="#IO.ioLiteral.ignoreWhiteSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Should read operations using this literal ignore and consume
whitespace before the literal?</p>
</dd></dl>

<dl class="method">
<dt id="IO.ioLiteral.writeThis">
<em class="property">proc </em><code class="descname">writeThis</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioLiteral.writeThis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="record">
<dt id="IO.ioBits">
<em class="property">record </em><code class="descname">ioBits</code><a class="headerlink" href="#IO.ioBits" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a value with a particular bit length that we want to read or write.
The I/O will always be done in binary mode.</p>
<dl class="attribute">
<dt id="IO.ioBits.v">
<em class="property">var </em><code class="descname">v</code>: uint(64)<a class="headerlink" href="#IO.ioBits.v" title="Permalink to this definition">¶</a></dt>
<dd><p>The bottom <code class="docutils literal"><span class="pre">nbits</span></code> of v will be read or written</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ioBits.nbits">
<em class="property">var </em><code class="descname">nbits</code>: int(8)<a class="headerlink" href="#IO.ioBits.nbits" title="Permalink to this definition">¶</a></dt>
<dd><p>How many of the low-order bits of <code class="docutils literal"><span class="pre">v</span></code> should we read or write?</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="IO.channel.lock">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">lock</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a channel's lock.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.unlock">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a channel's lock.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.offset">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: int(64)<a class="headerlink" href="#IO.channel.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset of a channel. Note that other operations
on the channel (e.g. by other tasks) might change the offset. If you
are doing another operation on the channel based upon the current offset,
you should use <a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.lock</span></code></a>, <a class="reference internal" href="#IO.channel._offset" title="IO.channel._offset"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._offset</span></code></a>, and
<a class="reference internal" href="#IO.channel.unlock" title="IO.channel.unlock"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.unlock</span></code></a> to prevent race conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the current offset of the channel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.advance">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">advance</code><span class="sig-paren">(</span><em>amount: int(64)</em>, <em>ref error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a channel offset forward.</p>
<p>For a reading channel, this function will consume the next <code class="docutils literal"><span class="pre">amount</span></code>
bytes. If EOF is reached, the channel position may be left at the
EOF.</p>
<p>For a writing channel, this function will write <code class="docutils literal"><span class="pre">amount</span></code> zeros - or some
other data if it is stored in the channel's buffer, for example with
<a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._mark</span></code></a> and <a class="reference internal" href="#IO.channel._revert" title="IO.channel._revert"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._revert</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel._offset">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: int(64)<a class="headerlink" href="#IO.channel._offset" title="Permalink to this definition">¶</a></dt>
<dd><p>For a channel locked with <a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.lock</span></code></a>, return the offset
of that channel.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel._mark">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">_mark</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: syserr<a class="headerlink" href="#IO.channel._mark" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p><em>mark</em> a channel - that is, save the current offset of the channel on its
<em>mark stack</em>. This function should only be called on a channel that is
already locked with with <a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.lock</span></code></a>.</p>
<p>The <em>mark stack</em> stores several channel offsets. For any channel offset that
is between the minimum and maximum value in the <em>mark stack</em>, I/O operations
on the channel will keep that region of the file buffered in memory so that
those operations can be un-done. As a result, it is possible to perform <em>I/O
transactions</em> on a channel. The basic steps for an <em>I/O transaction</em> are:</p>
<blockquote>
<div><ul class="simple">
<li>lock the channel with <a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.lock</span></code></a>
(or work on an already-locked channel)</li>
<li><em>mark</em> the current position with <a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._mark</span></code></a></li>
<li>do something speculative (e.g. try to read 200 bytes of anything followed
by a 'B')</li>
<li>if the speculative operation was successful,  commit the changes by
calling <a class="reference internal" href="#IO.channel._commit" title="IO.channel._commit"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._commit</span></code></a></li>
<li>if the speculative operation was not successful, go back to the <em>mark</em> by
calling <a class="reference internal" href="#IO.channel._revert" title="IO.channel._revert"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._revert</span></code></a>. Subsequent I/O operations will work
as though nothing happened.</li>
<li>unlock the channel with <a class="reference internal" href="#IO.channel.unlock" title="IO.channel.unlock"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.unlock</span></code></a> if necessary</li>
</ul>
</div></blockquote>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that it is possible to request an entire file be buffered in memory
using this feature, for example by <em>marking</em> at offset=0 and then
advancing to the end of the file. It is important to be aware of these
memory space requirements.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an error code, if an error was encountered.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel._revert">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">_revert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel._revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em>. See <a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._mark</span></code></a>. This function should
only be called on a channel that has already been locked and marked.  This
function will pop the last element from the <em>mark stack</em> and then leave the
previous channel offset unchanged.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel._commit">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">_commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel._commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em>. See <a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel._mark</span></code></a>. This function should
only be called on a channel that has already been locked and marked.  This
function will pop the last element from the <em>mark stack</em> and then set the
channel offset to the popped offset.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel._style">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">_style</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.channel._style" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current style used by a channel. This function should only be
called on a locked channel.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel._set_style">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">_set_style</code><span class="sig-paren">(</span><em>style: iostyle</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel._set_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the style associated with a channel. This function should only
be called on a locked channel.</p>
</dd></dl>

<dl class="function">
<dt id="IO.openreader">
<em class="property">proc </em><code class="descname">openreader</code><span class="sig-paren">(</span><em>out err: syserr</em>, <em>path: string = &quot;&quot;</em>, <em>param kind = iokind.dynamic</em>, <em>param locking = true</em>, <em>start: int(64) = 0</em>, <em>end: int(64) = max(int(64))</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>url: string = &quot;&quot;</em><span class="sig-paren">)</span>: channel(false, kind, locking)<a class="headerlink" href="#IO.openreader" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file at a particular path or URL and return a reading channel for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal"><span class="pre">open</span></code></a> and then
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.reader</span></code></a> on the resulting file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>err</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>path</strong> -- which file to open (for example, &quot;some/file.txt&quot;). This argument
is required unless the <code class="docutils literal"><span class="pre">url=</span></code> argument is used.</li>
<li><strong>kind</strong> -- <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> controls the formatting choices.</li>
<li><strong>locking</strong> -- compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</li>
<li><strong>start</strong> -- zero-based byte offset indicating where in the file the
channel should start reading. Defaults to 0.</li>
<li><strong>end</strong> -- zero-based byte offset indicating where in the file the
channel should no longer be allowed to read. Defaults
to a <code class="docutils literal"><span class="pre">max(int)</span></code> - meaning no end point.</li>
<li><strong>hints</strong> -- optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>.</li>
<li><strong>url</strong> -- optional argument to specify a URL to open. See <a class="reference internal" href="../packages/Curl.html#module-Curl" title="Curl: Simple support for many network protocols with libcurl"><code class="xref chpl chpl-mod docutils literal"><span class="pre">Curl</span></code></a> and
<a class="reference internal" href="../packages/HDFS.html#module-HDFS" title="HDFS: Support for Hadoop Distributed Filesystem"><code class="xref chpl chpl-mod docutils literal"><span class="pre">HDFS</span></code></a> for more information on <code class="docutils literal"><span class="pre">url=</span></code> support for those
systems. If HDFS is enabled, this function supports <code class="docutils literal"><span class="pre">url=</span></code>
arguments of the form &quot;hdfs://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;&quot;. If Curl is
enabled, this function supports <code class="docutils literal"><span class="pre">url=</span></code> starting with
<code class="docutils literal"><span class="pre">http://</span></code>, <code class="docutils literal"><span class="pre">https://</span></code>, <code class="docutils literal"><span class="pre">ftp://</span></code>, <code class="docutils literal"><span class="pre">ftps://</span></code>, <code class="docutils literal"><span class="pre">smtp://</span></code>,
<code class="docutils literal"><span class="pre">smtps://</span></code>, <code class="docutils literal"><span class="pre">imap://</span></code>, or <code class="docutils literal"><span class="pre">imaps://</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open reading channel to the requested resource. If the <code class="docutils literal"><span class="pre">error=</span></code>
argument was provided and the channel was not opened because of an
error, returns the default <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.openwriter">
<em class="property">proc </em><code class="descname">openwriter</code><span class="sig-paren">(</span><em>out err: syserr</em>, <em>path: string = &quot;&quot;</em>, <em>param kind = iokind.dynamic</em>, <em>param locking = true</em>, <em>start: int(64) = 0</em>, <em>end: int(64) = max(int(64))</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>url: string = &quot;&quot;</em><span class="sig-paren">)</span>: channel(true, kind, locking)<a class="headerlink" href="#IO.openwriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file at a particular path or URL and return a writing channel for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal"><span class="pre">open</span></code></a> with <code class="docutils literal"><span class="pre">iomode.cwr</span></code> and then
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.writer</span></code></a> on the resulting file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>err</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>path</strong> -- which file to open (for example, &quot;some/file.txt&quot;). This argument
is required unless the <code class="docutils literal"><span class="pre">url=</span></code> argument is used.</li>
<li><strong>kind</strong> -- <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> controls the formatting choices.</li>
<li><strong>locking</strong> -- compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</li>
<li><strong>start</strong> -- zero-based byte offset indicating where in the file the
channel should start writing. Defaults to 0.</li>
<li><strong>end</strong> -- zero-based byte offset indicating where in the file the
channel should no longer be allowed to write. Defaults
to a <code class="docutils literal"><span class="pre">max(int)</span></code> - meaning no end point.</li>
<li><strong>hints</strong> -- optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>.</li>
<li><strong>url</strong> -- optional argument to specify a URL to open. See <a class="reference internal" href="../packages/Curl.html#module-Curl" title="Curl: Simple support for many network protocols with libcurl"><code class="xref chpl chpl-mod docutils literal"><span class="pre">Curl</span></code></a> and
<a class="reference internal" href="../packages/HDFS.html#module-HDFS" title="HDFS: Support for Hadoop Distributed Filesystem"><code class="xref chpl chpl-mod docutils literal"><span class="pre">HDFS</span></code></a> for more information on <code class="docutils literal"><span class="pre">url=</span></code> support for those
systems. If HDFS is enabled, this function supports <code class="docutils literal"><span class="pre">url=</span></code>
arguments of the form &quot;hdfs://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;&quot;. If Curl is
enabled, this function supports <code class="docutils literal"><span class="pre">url=</span></code> starting with
<code class="docutils literal"><span class="pre">http://</span></code>, <code class="docutils literal"><span class="pre">https://</span></code>, <code class="docutils literal"><span class="pre">ftp://</span></code>, <code class="docutils literal"><span class="pre">ftps://</span></code>, <code class="docutils literal"><span class="pre">smtp://</span></code>,
<code class="docutils literal"><span class="pre">smtps://</span></code>, <code class="docutils literal"><span class="pre">imap://</span></code>, or <code class="docutils literal"><span class="pre">imaps://</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an open reading channel to the requested resource. If the <code class="docutils literal"><span class="pre">error=</span></code>
argument was provided and the channel was not opened because of an
error, returns the default <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.reader">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">reader</code><span class="sig-paren">(</span><em>out error: syserr</em>, <em>param kind = iokind.dynamic</em>, <em>param locking = true</em>, <em>start: int(64) = 0</em>, <em>end: int(64) = max(int(64))</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>style: iostyle = this._style</em><span class="sig-paren">)</span>: channel(false, kind, locking)<a class="headerlink" href="#IO.file.reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> that supports reading from a file. See
<a class="reference internal" href="#about-io-overview"><span>I/O Overview</span></a>.</p>
<p>The <code class="docutils literal"><span class="pre">start=</span></code> and <code class="docutils literal"><span class="pre">end=</span></code> arguments define the region of the file that the
channel will read from.  These are byte offsets; the beginning of the file is
at the offset 0.  The defaults for these arguments enable the channel to
access the entire file.</p>
<p>A channel will never read beyond its maximum end position. In addition,
reading from a channel beyond the end of the underlying file will not extend
that file.  Reading beyond the end of the file or beyond the end offset of
the channel will produce the error <code class="docutils literal"><span class="pre">EEOF</span></code> (and return <cite>false</cite> in many
cases such as <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a>) to indicate that the end was reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>kind</strong> -- <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> controls the formatting choices.</li>
<li><strong>locking</strong> -- compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</li>
<li><strong>start</strong> -- zero-based byte offset indicating where in the file the
channel should start reading. Defaults to 0.</li>
<li><strong>end</strong> -- zero-based byte offset indicating where in the file the
channel should no longer be allowed to read. Defaults
to a <code class="docutils literal"><span class="pre">max(int)</span></code> - meaning no end point.</li>
<li><strong>hints</strong> -- provide hints about the I/O that this channel will perform. See
<a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>. The default value of <a class="reference internal" href="#IO.IOHINT_NONE" title="IO.IOHINT_NONE"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_NONE</span></code></a>
will cause the channel to use the hints provided when opening
the file.</li>
<li><strong>style</strong> -- provide a <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> to use with this channel. The
default value will be the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> associated with
this file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.lines">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">lines</code><span class="sig-paren">(</span><em>out error: syserr</em>, <em>param locking: bool = true</em>, <em>start: int(64) = 0</em>, <em>end: int(64) = max(int(64))</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>in local_style: iostyle = this._style</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all of the lines in a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an object which yields strings read from the file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.writer">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">writer</code><span class="sig-paren">(</span><em>out error: syserr</em>, <em>param kind = iokind.dynamic</em>, <em>param locking = true</em>, <em>start: int(64) = 0</em>, <em>end: int(64) = max(int(64))</em>, <em>hints: iohints = IOHINT_NONE</em>, <em>style: iostyle = this._style</em><span class="sig-paren">)</span>: channel(true, kind, locking)<a class="headerlink" href="#IO.file.writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> that supports writing to a file. See
<a class="reference internal" href="#about-io-overview"><span>I/O Overview</span></a>.</p>
<p>The <code class="docutils literal"><span class="pre">start=</span></code> and <code class="docutils literal"><span class="pre">end=</span></code> arguments define the region of the file that the
channel will write to.  These are byte offsets; the beginning of the file is
at the offset 0.  The defaults for these arguments enable the channel to
access the entire file.</p>
<p>When a channel writes to a file, it will replace file data that was
previously stored at the relevant offset. If the offset is beyond the
end of the file, the file will be extended.</p>
<p>A channel will never write beyond its maximum end position.  It will extend
the file only as necessary to store data written to the channel. In other
words, specifying end here does not impact the file size directly; it
impacts only the section of the file that this channel can write to. After
all channels to a file are closed, that file will have a size equal to the
last position written to by any channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
<li><strong>kind</strong> -- <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> controls the formatting choices.</li>
<li><strong>locking</strong> -- compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</li>
<li><strong>start</strong> -- zero-based byte offset indicating where in the file the
channel should start writing. Defaults to 0.</li>
<li><strong>end</strong> -- zero-based byte offset indicating where in the file the
channel should no longer be allowed to write. Defaults
to a <code class="docutils literal"><span class="pre">max(int)</span></code> - meaning no end point.</li>
<li><strong>hints</strong> -- provide hints about the I/O that this channel will perform. See
<a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal"><span class="pre">iohints</span></code></a>. The default value of <a class="reference internal" href="#IO.IOHINT_NONE" title="IO.IOHINT_NONE"><code class="xref chpl chpl-const docutils literal"><span class="pre">IOHINT_NONE</span></code></a>
will cause the channel to use the hints provided when opening
the file.</li>
<li><strong>style</strong> -- provide a <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> to use with this channel. The
default value will be the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal"><span class="pre">iostyle</span></code></a> associated with
this file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readwrite">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readwrite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.readwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>For a writing channel, writes as with <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a>.
For a reading channel, reads as with <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a>.
Stores any error encountered in the channel. Does not return anything.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc &lt;~&gt;(const ref ch: channel, x) const ref</code></dt>
<dd><p>The <span class="target" id="operator">&lt;~&gt; operator</span></p>
<p>This <cite>&lt;~&gt;</cite> operator is the same as calling <a class="reference internal" href="#IO.channel.readwrite" title="IO.channel.readwrite"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readwrite</span></code></a>,
except that it returns the channel so that multiple operator
calls can be chained together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ch</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc &lt;~&gt;(const ref r: channel, lit: ioLiteral) const ref</code></dt>
<dd><p>Overload to support reading an <a class="reference internal" href="#IO.ioLiteral" title="IO.ioLiteral"><code class="xref chpl chpl-type docutils literal"><span class="pre">IO.ioLiteral</span></code></a> without
passing ioLiterals by reference, so that</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">reader</span> <span class="o">&lt;~&gt;</span> <span class="k">new</span> <span class="nx">ioLiteral</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>works without requiring an explicit temporary value to store
the ioLiteral.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc &lt;~&gt;(const ref r: channel, nl: ioNewline) const ref</code></dt>
<dd><p>Overload to support reading an <a class="reference internal" href="#IO.ioNewline" title="IO.ioNewline"><code class="xref chpl chpl-type docutils literal"><span class="pre">IO.ioNewline</span></code></a> without
passing ioNewline by reference, so that</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">reader</span> <span class="o">&lt;~&gt;</span> <span class="k">new</span> <span class="nx">ioNewline</span><span class="p">()</span>
</pre></div>
</div>
<p>works without requiring an explicit temporary value to store
the ioNewline.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readWriteLiteral">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readWriteLiteral</code><span class="sig-paren">(</span><em>lit: string</em>, <em>ignoreWhiteSpace = true</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.readWriteLiteral" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicit call for reading or writing a literal as an
alternative to using <a class="reference internal" href="#IO.ioLiteral" title="IO.ioLiteral"><code class="xref chpl chpl-type docutils literal"><span class="pre">IO.ioLiteral</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readWriteNewline">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readWriteNewline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.readWriteNewline" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicit call for reading or writing a newline as an
alternative to using <a class="reference internal" href="#IO.ioNewline" title="IO.ioNewline"><code class="xref chpl chpl-type docutils literal"><span class="pre">IO.ioNewline</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.binary">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">binary</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this channel is configured for binary I/O.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.error">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">error</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: syserr<a class="headerlink" href="#IO.channel.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return any saved error code.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.setError">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">setError</code><span class="sig-paren">(</span><em>e: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.setError" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an error code.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.clearError">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">clearError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.clearError" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear any saved error code.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.writeBytes">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">writeBytes</code><span class="sig-paren">(</span><em>x</em>, <em>len: ssize_t</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.writeBytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a sequence of bytes.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.read">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">read</code><span class="sig-paren">(</span><em>ref args ...?k</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if we read all the args,
false if we encountered EOF (or possibly another error and didn't halt)</p>
</dd></dl>

<dl class="function">
<dt id="IO.stringify">
<em class="property">proc </em><code class="descname">stringify</code><span class="sig-paren">(</span><em>args ...?k</em><span class="sig-paren">)</span>: string<a class="headerlink" href="#IO.stringify" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a string representing the result of writing the arguments.</p>
<p>Writes each argument, possibly using a <cite>writeThis</cite> method,
to a string and returns the result.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">read</code><span class="sig-paren">(</span><em>ref args ...?k</em>, <em>style: iostyle</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool</dt>
<dd><p>Read values from a channel. The input will be consumed atomically - the
channel lock will be held while reading all of the passed values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> -- a list of arguments to read. Basic types are handled
internally, but for other types this function will call
value.readThis() with a <code class="docutils literal"><span class="pre">Reader</span></code> argument as described
in the specification.</li>
<li><strong>style</strong> -- optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostyle</span></code></a> for this read.
If this argument is not provided, use the current style
associated with this channel.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if the read succeeded, and <cite>false</cite> on error or end of file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readline">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readline</code><span class="sig-paren">(</span><em>arg: [] uint(8)</em>, <em>out numRead: int</em>, <em>start = arg.domain.low</em>, <em>amount = arg.domain.high-start+1</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.readline" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a line into a Chapel array of bytes. Reads until a <code class="docutils literal"><span class="pre">\n</span></code> is reached.
The <code class="docutils literal"><span class="pre">\n</span></code> is returned in the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>arg</strong> -- A 1D DefaultRectangular array which must have at least 1 element.</li>
<li><strong>numRead</strong> -- The number of bytes read.</li>
<li><strong>start</strong> -- Index to begin reading into.</li>
<li><strong>amount</strong> -- The maximum amount of bytes to read.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">true if the bytes were read without error.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readline</code><span class="sig-paren">(</span><em>ref arg: string</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool</dt>
<dd><p>Read a line into a Chapel string. Reads until a <code class="docutils literal"><span class="pre">\n</span></code> is reached.
The <code class="docutils literal"><span class="pre">\n</span></code> is included in the resulting string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>arg</strong> -- a string to receive the line</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if a line was read without error, <cite>false</cite> on error or EOF</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readstring">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readstring</code><span class="sig-paren">(</span><em>ref str_out: string</em>, <em>len: int(64) = -1</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.readstring" title="Permalink to this definition">¶</a></dt>
<dd><p>read a given number of bytes from a channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>str_out</strong> -- The string to be read into</li>
<li><strong>len</strong> -- Read up to len bytes from the channel, up until EOF
(or some kind of I/O error). If the default value of -1
is provided, read until EOF starting from the channel's
current offset.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if we read something, <cite>false</cite> on EOF or error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readbits">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readbits</code><span class="sig-paren">(</span><em>out v: integral</em>, <em>nbits: integral</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.readbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read bits with binary I/O</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> -- where to store the read bits. This value will have its <em>nbits</em>
least-significant bits set.</li>
<li><strong>nbits</strong> -- how many bits to read</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if the bits were read without error, <cite>false</cite> on error or EOF</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.writebits">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">writebits</code><span class="sig-paren">(</span><em>v: integral</em>, <em>nbits: integral</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.writebits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write bits with binary I/O</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> -- a value containing <em>nbits</em> bits to write the least-significant bits</li>
<li><strong>nbits</strong> -- how many bits to write</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if the bits were written without error, <cite>false</cite> on error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readln">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readln</code><span class="sig-paren">(</span><em>ref args ...?k</em>, <em>style: iostyle</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.readln" title="Permalink to this definition">¶</a></dt>
<dd><p>Read values from a channel and then consume any bytes until
newline is reached. The input will be consumed atomically - the
channel lock will be held while reading all of the passed values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> -- a list of arguments to read. This routine can be called
with zero or more such arguments. Basic types are handled
internally, but for other types this function will call
value.readThis() with a <code class="docutils literal"><span class="pre">Reader</span></code> argument as described
in the specification.</li>
<li><strong>style</strong> -- optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostyle</span></code></a> for this read.
If this argument is not provided, use the current style
associated with this channel.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if the read succeeded, and <cite>false</cite> on error or end of file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">read</code><span class="sig-paren">(</span><em>type t</em><span class="sig-paren">)</span></dt>
<dd><p>Read a value of passed type.
Halts if an error is encountered.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is difficult to handle errors or to handle reaching the end of
the file with this function. If such cases are important please use
the <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a> returning the values read in arguments instead.</p>
</div>
<p>For example, the following line of code reads a value of type <cite>int</cite>
from <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal"><span class="pre">stdin</span></code></a> and uses it to initialize a variable <code class="docutils literal"><span class="pre">x</span></code>:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>t</strong> -- the type to read</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the value read</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readln</code><span class="sig-paren">(</span><em>type t</em><span class="sig-paren">)</span></dt>
<dd><p>Read a value of passed type followed by a newline.
Halts if an error is encountered.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is difficult to handle errors or to handle reaching the end of
the file with this function. If such cases are important please use
<a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readln</span></code></a> instead.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>t</strong> -- the type to read</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the value read</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readln</code><span class="sig-paren">(</span><em>type t ...?numTypes</em><span class="sig-paren">)</span></dt>
<dd><p>Read values of passed types followed by a newline
and return a tuple containing the read values.
Halts if an error is encountered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>t</strong> -- more than one type to read</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple of the read values</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">read</code><span class="sig-paren">(</span><em>type t ...?numTypes</em><span class="sig-paren">)</span></dt>
<dd><p>Read values of passed types and return a tuple containing the read values.
Halts if an error is encountered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>t</strong> -- more than one type to read</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple of the read values</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.write">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">write</code><span class="sig-paren">(</span><em>const args ...?k</em>, <em>style: iostyle</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write values to a channel. The output will be produced atomically -
the channel lock will be held while writing all of the passed
values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> -- a list of arguments to write. Basic types are handled
internally, but for other types this function will call
value.writeThis() with the channel as an argument.</li>
<li><strong>style</strong> -- optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostyle</span></code></a> for this write.
If this argument is not provided, use the current style
associated with this channel.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if the write succeeded</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.writeln">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">writeln</code><span class="sig-paren">(</span><em>const args ...?k</em>, <em>style: iostyle</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.writeln" title="Permalink to this definition">¶</a></dt>
<dd><p>Write values to a channel followed by a newline.  The output will be
produced atomically - the channel lock will be held while writing all of the
passed values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> -- a variable number of arguments to write. This method can be
called with zero or more arguments. Basic types are handled
internally, but for other types this function will call
value.writeThis() with the channel as an argument.</li>
<li><strong>style</strong> -- optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal"><span class="pre">iostyle</span></code></a> for this write.
If this argument is not provided, use the current style
associated with this channel.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>true</cite> if the write succeeded</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.flush">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">flush</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes all writes to the channel, if any, available to concurrent viewers
of its associated file, such as other channels or other applications
accessing this file concurrently.
Unlike <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal"><span class="pre">file.fsync</span></code></a>, this does not commit the written data
to the file's device.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.assertEOF">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">assertEOF</code><span class="sig-paren">(</span><em>error: string</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.assertEOF" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert that a channel has reached end-of-file.
Halts with an error message if the receiving channel is not currently
at EOF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- an optional string argument which will be printed
out if the assert fails. The default prints &quot;Not at EOF&quot;.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.close">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">close</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a channel. Implicitly performs the <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.flush</span></code></a> operation
(see <a class="reference internal" href="#about-io-channel-synchronization"><span>Synchronization of Channel Data and Avoiding Data Races</span></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.isclosed">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">isclosed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.isclosed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if a channel is currently closed.</p>
</dd></dl>

<dl class="record">
<dt id="IO.ItemReader">
<em class="property">record </em><code class="descname">ItemReader</code><a class="headerlink" href="#IO.ItemReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper class on a channel to make it only read values
of a single type. Also supports an iterator yielding
the read values.</p>
<dl class="attribute">
<dt id="IO.ItemReader.ItemType">
<em class="property">type </em><code class="descname">ItemType</code><a class="headerlink" href="#IO.ItemReader.ItemType" title="Permalink to this definition">¶</a></dt>
<dd><p>What type do we read and yield?</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ItemReader.kind">
<em class="property">param </em><code class="descname">kind</code>: iokind<a class="headerlink" href="#IO.ItemReader.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>the kind field for our channel</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ItemReader.locking">
<em class="property">param </em><code class="descname">locking</code>: bool<a class="headerlink" href="#IO.ItemReader.locking" title="Permalink to this definition">¶</a></dt>
<dd><p>the locking field for our channel</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ItemReader.ch">
<em class="property">var </em><code class="descname">ch</code>: channel(false, kind, locking)<a class="headerlink" href="#IO.ItemReader.ch" title="Permalink to this definition">¶</a></dt>
<dd><p>our channel</p>
</dd></dl>

<dl class="method">
<dt id="IO.ItemReader.read">
<em class="property">proc </em><code class="descname">read</code><span class="sig-paren">(</span><em>out arg: ItemType</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.ItemReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single item, returning an error</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descname">read</code><span class="sig-paren">(</span><em>out arg: ItemType</em><span class="sig-paren">)</span>: bool</dt>
<dd><p>read a single item, halting on error</p>
</dd></dl>

<dl class="itermethod">
<dt id="IO.ItemReader.these">
<em class="property">iter </em><code class="descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.ItemReader.these" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate through all items of that type read from the channel</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="IO.channel.itemReader">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">itemReader</code><span class="sig-paren">(</span><em>type ItemType</em>, <em>param kind: iokind = iokind.dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.itemReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return an <a class="reference internal" href="#IO.ItemReader" title="IO.ItemReader"><code class="xref chpl chpl-record docutils literal"><span class="pre">ItemReader</span></code></a> that can yield read values of
a single type.</p>
</dd></dl>

<dl class="record">
<dt id="IO.ItemWriter">
<em class="property">record </em><code class="descname">ItemWriter</code><a class="headerlink" href="#IO.ItemWriter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="IO.ItemWriter.ItemType">
<em class="property">type </em><code class="descname">ItemType</code><a class="headerlink" href="#IO.ItemWriter.ItemType" title="Permalink to this definition">¶</a></dt>
<dd><p>What type do we write?</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ItemWriter.kind">
<em class="property">param </em><code class="descname">kind</code>: iokind<a class="headerlink" href="#IO.ItemWriter.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>the kind field for our channel</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ItemWriter.locking">
<em class="property">param </em><code class="descname">locking</code>: bool<a class="headerlink" href="#IO.ItemWriter.locking" title="Permalink to this definition">¶</a></dt>
<dd><p>the locking field for our channel</p>
</dd></dl>

<dl class="attribute">
<dt id="IO.ItemWriter.ch">
<em class="property">var </em><code class="descname">ch</code>: channel(true, kind, locking)<a class="headerlink" href="#IO.ItemWriter.ch" title="Permalink to this definition">¶</a></dt>
<dd><p>our channel</p>
</dd></dl>

<dl class="method">
<dt id="IO.ItemWriter.write">
<em class="property">proc </em><code class="descname">write</code><span class="sig-paren">(</span><em>arg: ItemType</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.ItemWriter.write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single item, returning an error</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descname">write</code><span class="sig-paren">(</span><em>arg: ItemType</em><span class="sig-paren">)</span>: bool</dt>
<dd><p>write a single item, halting on error</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="IO.channel.itemWriter">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">itemWriter</code><span class="sig-paren">(</span><em>type ItemType</em>, <em>param kind: iokind = iokind.dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.itemWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return an <a class="reference internal" href="#IO.ItemWriter" title="IO.ItemWriter"><code class="xref chpl chpl-record docutils literal"><span class="pre">ItemWriter</span></code></a> that can write values of
a single type.</p>
</dd></dl>

<dl class="data">
<dt id="IO.stdin">
<em class="property">const </em><code class="descname">stdin</code>: channel(false, iokind.dynamic, true) = AppendExpr.Call08<a class="headerlink" href="#IO.stdin" title="Permalink to this definition">¶</a></dt>
<dd><p>standard input, otherwise known as file descriptor 0</p>
</dd></dl>

<dl class="data">
<dt id="IO.stdout">
<em class="property">const </em><code class="descname">stdout</code>: channel(true, iokind.dynamic, true) = AppendExpr.Call08<a class="headerlink" href="#IO.stdout" title="Permalink to this definition">¶</a></dt>
<dd><p>standard output, otherwise known as file descriptor 1</p>
</dd></dl>

<dl class="data">
<dt id="IO.stderr">
<em class="property">const </em><code class="descname">stderr</code>: channel(true, iokind.dynamic, true) = AppendExpr.Call08<a class="headerlink" href="#IO.stderr" title="Permalink to this definition">¶</a></dt>
<dd><p>standard error, otherwise known as file descriptor 2</p>
</dd></dl>

<dl class="function">
<dt id="IO.write">
<em class="property">proc </em><code class="descname">write</code><span class="sig-paren">(</span><em>const args ...?n</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to stdout.write. See <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.write</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="IO.writeln">
<em class="property">proc </em><code class="descname">writeln</code><span class="sig-paren">(</span><em>const args ...?n</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.writeln" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to stdout.writeln. See <a class="reference internal" href="#IO.channel.writeln" title="IO.channel.writeln"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writeln</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="IO.read">
<em class="property">proc </em><code class="descname">read</code><span class="sig-paren">(</span><em>ref args ...?n</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to stdin.read. See <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="IO.readln">
<em class="property">proc </em><code class="descname">readln</code><span class="sig-paren">(</span><em>ref args ...?n</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.readln" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to stdin.readln. See <a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readln</span></code></a></p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">proc </em><code class="descname">readln</code><span class="sig-paren">(</span><em>type t ...?numTypes</em><span class="sig-paren">)</span></dt>
<dd><p>Equivalent to stdin.readln. See <a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readln</span></code></a> for types</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">proc </em><code class="descname">read</code><span class="sig-paren">(</span><em>type t ...?numTypes</em><span class="sig-paren">)</span></dt>
<dd><p>Equivalent to stdin.read. See <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.read</span></code></a> for types</p>
</dd></dl>

<dl class="function">
<dt id="IO.unlink">
<em class="property">proc </em><code class="descname">unlink</code><span class="sig-paren">(</span><em>path: string</em>, <em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a file. This function is likely to be replaced
by <a class="reference internal" href="FileSystem.html#FileSystem.remove" title="FileSystem.remove"><code class="xref chpl chpl-proc docutils literal"><span class="pre">FileSystem.remove</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> -- the path to the file to remove</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.unicodeSupported">
<em class="property">proc </em><code class="descname">unicodeSupported</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.unicodeSupported" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><cite>true</cite> if this version of the Chapel runtime supports UTF-8 output.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.writef">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">writef</code><span class="sig-paren">(</span><em>fmtStr: string</em>, <em>const args ...?k</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.writef" title="Permalink to this definition">¶</a></dt>
<dd><p>Write arguments according to a format string. See
<a class="reference internal" href="#about-io-formatted-io"><span>Formatted I/O</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>fmt</strong> -- the format string</li>
<li><strong>args</strong> -- the arguments to write</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.readf">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">readf</code><span class="sig-paren">(</span><em>fmtStr: string</em>, <em>ref args ...?k</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.readf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read arguments according to a format string. See
<a class="reference internal" href="#about-io-formatted-io"><span>Formatted I/O</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>fmt</strong> -- the format string</li>
<li><strong>args</strong> -- the arguments to read</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">true if all arguments were read according to the format string,
false on EOF. If the format did not match the input, returns
false with error=EFORMAT or halts if no error argument was
provided.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="IO.writef">
<em class="property">proc </em><code class="descname">writef</code><span class="sig-paren">(</span><em>fmt: string</em>, <em>const args ...?k</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.writef" title="Permalink to this definition">¶</a></dt>
<dd><p>Call <code class="docutils literal"><span class="pre">stdout.writef</span></code>; see <a class="reference internal" href="#IO.channel.writef" title="IO.channel.writef"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.writef</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="IO.readf">
<em class="property">proc </em><code class="descname">readf</code><span class="sig-paren">(</span><em>fmt: string</em>, <em>ref args ...?k</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.readf" title="Permalink to this definition">¶</a></dt>
<dd><p>Call <code class="docutils literal"><span class="pre">stdout.readf</span></code>; see <a class="reference internal" href="#IO.channel.readf" title="IO.channel.readf"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.readf</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="IO.channel.skipField">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">skipField</code><span class="sig-paren">(</span><em>out error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.skipField" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip a field in the current aggregate format. This method is currently only
supported for JSON format and returns ENOTSUP for other formats. In other
formats, it may not be possible in general to know when a field ends.</p>
<p>The field skipped includes a field name and value but not a following
separator. For example, for a JSON format channel, given the input:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&quot;fieldName&quot;:&quot;fieldValue&quot;, &quot;otherField&quot;:3
</pre></div>
</div>
<p>this function will skip to (but leave unread) the comma after
the first field value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.string.format">
<em class="property">proc </em><code class="descclassname">string.</code><code class="descname">format</code><span class="sig-paren">(</span><em>args ...?k</em>, <em>out error: syserr</em><span class="sig-paren">)</span>: string<a class="headerlink" href="#IO.string.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new string consisting of values formatted according to a
format string.  See <a class="reference internal" href="#about-io-formatted-io"><span>Formatted I/O</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>this</strong> -- the format string</li>
<li><strong>args</strong> -- the arguments to format</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the resulting string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.extractMatch">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">extractMatch</code><span class="sig-paren">(</span><em>m: reMatch</em>, <em>ref arg</em>, <em>ref error: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.extractMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets arg to the string of a match.</p>
<p>Assumes that the channel has been marked before where
the captures are being returned. Will change the channel
position to just after the match. Will not do anything
if error is set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> -- a <a class="reference internal" href="Regexp.html#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal"><span class="pre">Regexp.reMatch</span></code></a> storing a location that matched</li>
<li><strong>arg</strong> -- an argument to retrieve the match into. If it is not a string,
the string match will be cast to arg.type.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.search">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">search</code><span class="sig-paren">(</span><em>re: regexp</em>, <em>ref captures ...?k</em>, <em>ref error: syserr</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#IO.channel.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for an offset in the channel matching the
passed regular expression, possibly pulling out capture groups.
If there is a match, leaves the channel position at the
match. If there is no match, the channel position will be
advanced to the end of the channel (or end of the file).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>re</strong> -- a <a class="reference internal" href="Regexp.html#Regexp.regexp" title="Regexp.regexp"><code class="xref chpl chpl-record docutils literal"><span class="pre">Regexp.regexp</span></code></a> record representing a compiled
regular expression.</li>
<li><strong>captures</strong> -- an optional variable number of arguments in which to
store the regions of the file matching the capture groups
in the regular expression.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the region of the channel that matched</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.channel.match">
<em class="property">proc </em><code class="descclassname">channel.</code><code class="descname">match</code><span class="sig-paren">(</span><em>re: regexp</em>, <em>ref captures ...?k</em>, <em>ref error: syserr</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#IO.channel.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match, starting at the current position in the channel,
against a regexp, possibly pulling out capture groups.
If there was a match, leaves the channel position at
the match. If there was no match, leaves the channel
position where it was at the start of this call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>re</strong> -- a <a class="reference internal" href="Regexp.html#Regexp.regexp" title="Regexp.regexp"><code class="xref chpl chpl-record docutils literal"><span class="pre">Regexp.regexp</span></code></a> record representing a compiled
regular expression.</li>
<li><strong>captures</strong> -- an optional variable number of arguments in which to
store the regions of the file matching the capture groups
in the regular expression.</li>
<li><strong>error</strong> -- optional argument to capture an error code. If this argument
is not provided and an error is encountered, this function
will halt with an error message.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the region of the channel that matched</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="IO.channel.matches">
<em class="property">iter </em><code class="descclassname">channel.</code><code class="descname">matches</code><span class="sig-paren">(</span><em>re: regexp</em>, <em>param captures = 0</em>, <em>maxmatches: int = max(int)</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the string as well as capture groups.</p>
<p>Yields tuples of <a class="reference internal" href="Regexp.html#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal"><span class="pre">Regexp.reMatch</span></code></a> objects, the 1st is always
the match for the whole pattern.</p>
<p>At the time each match is returned, the channel position is
at the start of that match. Note though that you would have
to use <a class="reference internal" href="#IO.channel.advance" title="IO.channel.advance"><code class="xref chpl chpl-proc docutils literal"><span class="pre">channel.advance</span></code></a> to get to the position of a capture group.</p>
<p>After returning each match, advances to just after that
match and looks for another match. Thus, it will not return
overlapping matches.</p>
<p>In the end, leaves the channel position at the end of the
last reported match (if we ran out of maxmatches)
or at the end of the channel (if we no longer matched)</p>
<p>Holds the channel lock for the duration of the search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>re</strong> -- a <a class="reference internal" href="Regexp.html#Regexp.regexp" title="Regexp.regexp"><code class="xref chpl chpl-record docutils literal"><span class="pre">Regexp.regexp</span></code></a> record representing a compiled
regular expression.</li>
<li><strong>captures</strong> -- an optional compile-time constant representing the number
of captures to be yielded in tuple elements.</li>
<li><strong>maxmatches</strong> -- the maximum number of matches to report.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">tuples of <a class="reference internal" href="Regexp.html#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal"><span class="pre">Regexp.reMatch</span></code></a> objects, where the first element
is the whole pattern.  The tuples will have 1+captures elements.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.getchunk">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">getchunk</code><span class="sig-paren">(</span><em>start: int(64) = 0</em>, <em>end: int(64) = max(int(64))</em><span class="sig-paren">)</span>: (int(64), int(64))<a class="headerlink" href="#IO.file.getchunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (chunk start, chunk end) for the first chunk in the file
containing data in the region start..end-1. Note that the returned
chunk might not cover all of the region in question.</p>
<p>Returns (0,0) if no such value exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> -- the file offset (starting from 0) where the region begins</li>
<li><strong>end</strong> -- the file offset just after the region</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple of (chunkStart, chunkEnd) so that the bytes
in chunkStart..chunkEnd-1 are stored in a manner that makes
reading that chunk at a time most efficient</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="IO.file.localesForRegion">
<em class="property">proc </em><code class="descclassname">file.</code><code class="descname">localesForRegion</code><span class="sig-paren">(</span><em>start: int(64)</em>, <em>end: int(64)</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.localesForRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 'best' locale to run something working with the region
of the file in start..end-1.</p>
<p>This <em>must</em> return the same result when called from different locales.
Returns a domain of locales that are &quot;best&quot; for the given region. If no
locales are &quot;best&quot; we return a domain containing all locales.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> -- the file offset (starting from 0) where the region begins</li>
<li><strong>end</strong> -- the file offset just after the region</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a set of locales that are best for working with this region</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">domain(locale)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="List.html" class="btn btn-neutral float-right" title="List" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Help.html" class="btn btn-neutral" title="Help" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Cray Inc.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.15.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 



</body>
</html>