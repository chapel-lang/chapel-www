<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Types &mdash; Chapel Documentation 2.1</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=20623aea"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Variables" href="variables.html" />
    <link rel="prev" title="Lexical Structure" href="lexical-structure.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.1
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.1";
$pagename = "language/spec/types";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#language-basics">Language Basics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#primitive-types">Primitive Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enumerated-types">Enumerated Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structured-types">Structured Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-parallel-types">Data Parallel Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-types">Synchronization Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-aliases">Type Aliases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#querying-the-type-of-an-expression">Querying the Type of an Expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operations-available-on-types">Operations Available on Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types-with-runtime-components">Types with Runtime Components</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l3"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l3"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-structures">Code Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Chapel Language Specification</a></li>
      <li class="breadcrumb-item active">Types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="types">
<span id="chapter-types"></span><span id="index-0"></span><h1>Types<a class="headerlink" href="#types" title="Link to this heading">¶</a></h1>
<p>Chapel is a statically typed language with a rich set of types. These
include a set of predefined primitive types, enumerated types,
structured types (classes, records, unions, tuples), data parallel types
(ranges, domains, arrays), and synchronization types (sync, atomic).</p>
<p>The syntax of a type is as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>type-expression:
  primitive-type
  enum-type
  structured-type
  dataparallel-type
  synchronization-type
  lvalue-expression
  if-expression
  unary-expression
  binary-expression
  expression
</pre></div>
</div>
<p>Many expressions are syntactically allowed as a type; however not all
expressions produce a type. For example, a call to a function is
syntactically allowed as the type of a variable. However it would be an
error for that call to result in a value (rather than a type) in that
context.</p>
<p>Programmers can define their own enumerated types, classes, records,
unions, and type aliases using type declaration statements:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>type-declaration-statement:
  enum-declaration-statement
  class-declaration-statement
  record-declaration-statement
  union-declaration-statement
  type-alias-declaration-statement
</pre></div>
</div>
<p>These statements are defined in Sections <a class="reference internal" href="#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>,
<a class="reference internal" href="classes.html#class-declarations"><span class="std std-ref">Class Declarations</span></a>, <a class="reference internal" href="records.html#record-declarations"><span class="std std-ref">Record Declarations</span></a>,
<a class="reference internal" href="unions.html#union-declarations"><span class="std std-ref">Union Declarations</span></a>, and <a class="reference internal" href="#type-aliases"><span class="std std-ref">Type Aliases</span></a>,
respectively.</p>
<section id="primitive-types">
<span id="index-1"></span><span id="id1"></span><h2>Primitive Types<a class="headerlink" href="#primitive-types" title="Link to this heading">¶</a></h2>
<p>The concrete primitive types are: <code class="docutils literal notranslate"><span class="pre">void</span></code>, <code class="docutils literal notranslate"><span class="pre">nothing</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>,
<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">real</span></code>, <code class="docutils literal notranslate"><span class="pre">imag</span></code>, <code class="docutils literal notranslate"><span class="pre">complex</span></code>, <code class="docutils literal notranslate"><span class="pre">string</span></code> and
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>. They are defined in this section.</p>
<p>In addition, there are several generic primitive types that are
described in <a class="reference internal" href="generics.html#built-in-generic-types"><span class="std std-ref">Built-in Generic Types</span></a>.</p>
<p>The primitive types are summarized by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>primitive-type:
  &#39;void&#39;
  &#39;nothing&#39;
  &#39;bool&#39;
  &#39;int&#39; primitive-type-parameter-part[OPT]
  &#39;uint&#39; primitive-type-parameter-part[OPT]
  &#39;real&#39; primitive-type-parameter-part[OPT]
  &#39;imag&#39; primitive-type-parameter-part[OPT]
  &#39;complex&#39; primitive-type-parameter-part[OPT]
  &#39;string&#39;
  &#39;bytes&#39;
  &#39;enum&#39;
  &#39;record&#39;
  &#39;class&#39;
  &#39;owned&#39;
  &#39;shared&#39;
  &#39;unmanaged&#39;
  &#39;borrowed&#39;

primitive-type-parameter-part:
  ( integer-parameter-expression )

integer-parameter-expression:
  expression
</pre></div>
</div>
<p>If present, the parenthesized <code class="docutils literal notranslate"><span class="pre">integer-parameter-expression</span></code> must
evaluate to a compile-time constant of integer type.
See <a class="reference internal" href="variables.html#compile-time-constants"><span class="std std-ref">Compile-Time Constants</span></a></p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>There is an expectation of future support for larger bit width
primitive types depending on a platform’s native support for those
types.</p>
</div></blockquote>
<section id="the-void-type">
<span id="index-2"></span><span id="id2"></span><h3>The Void Type<a class="headerlink" href="#the-void-type" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">void</span></code> type is used to represent the lack of a value. It is
primarily used to indicate that a function does not return anything.</p>
<blockquote>
<div><p><em>Example (returnVoid.chpl)</em>.</p>
<p>For example, the below declares <code class="docutils literal notranslate"><span class="pre">f</span></code> to return <code class="docutils literal notranslate"><span class="pre">void</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">()</span> <span class="p">:</span> <span class="kt">void</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>The compiler can infer the return type of <code class="docutils literal notranslate"><span class="pre">void</span></code> as well. See
See <a class="reference internal" href="procedures.html#return-types"><span class="std std-ref">Return Types</span></a> for more information.</p>
</div></blockquote>
<p>It is an error to assign the result of a function that returns <code class="docutils literal notranslate"><span class="pre">void</span></code>
to a variable.</p>
</section>
<section id="the-nothing-type">
<span id="index-3"></span><span id="id3"></span><h3>The Nothing Type<a class="headerlink" href="#the-nothing-type" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">nothing</span></code> type is used to indicate a variable or field that should
be removed by the compiler. The value <code class="docutils literal notranslate"><span class="pre">none</span></code> is the only value of type
<code class="docutils literal notranslate"><span class="pre">nothing</span></code>.</p>
<p>The value <code class="docutils literal notranslate"><span class="pre">none</span></code> can only be assigned to a variable of type
<code class="docutils literal notranslate"><span class="pre">nothing</span></code>, or to a generic variable that will take on the type
<code class="docutils literal notranslate"><span class="pre">nothing</span></code>. The variable will be removed from the program and have no
representation at run-time.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nothing</span></code> type can be used to conditionally remove a variable
or field from the code based on a <code class="docutils literal notranslate"><span class="pre">param</span></code> conditional expression.</p>
<p><em>Example (noneNothing.chpl)</em>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nothing</span></code> type and <code class="docutils literal notranslate"><span class="pre">none</span></code> values typically come up in a
generic programming context (see also <a class="reference internal" href="generics.html#chapter-generics"><span class="std std-ref">Generics</span></a>). For
example, the following program defines a generic function <code class="docutils literal notranslate"><span class="pre">g</span></code> that
can determine if it was called with an integer or with <code class="docutils literal notranslate"><span class="pre">none</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">arg</span><span class="p">.</span><span class="kd">type</span> <span class="o">!=</span> <span class="kt">nothing</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// outputs 1</span>
<span class="nx">g</span><span class="p">(</span><span class="kc">none</span><span class="p">);</span> <span class="c1">// does not create output</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="the-bool-type">
<span id="index-4"></span><span id="id4"></span><h3>The Bool Type<a class="headerlink" href="#the-bool-type" title="Link to this heading">¶</a></h3>
<p>Chapel defines a logical data type designated by the symbol <code class="docutils literal notranslate"><span class="pre">bool</span></code>
with the two predefined values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>. Values of this
boolean type are stored using an implementation-defined number of
bits.</p>
<p>Some statements require expressions of <code class="docutils literal notranslate"><span class="pre">bool</span></code> type and Chapel supports
a special conversion of values to <code class="docutils literal notranslate"><span class="pre">bool</span></code> type when used in this
context (<a class="reference internal" href="conversions.html#implicit-statement-bool-conversions"><span class="std std-ref">Implicit Conversions for Conditionals</span></a>).</p>
<p>Variables of type <code class="docutils literal notranslate"><span class="pre">bool</span></code> have a default value of <code class="docutils literal notranslate"><span class="pre">false</span></code> if they are
not initialized to something else (see also <a class="reference internal" href="variables.html#chapter-variables"><span class="std std-ref">Variables</span></a>).</p>
<blockquote>
<div><p><em>Example (bools.chpl)</em>.</p>
<p>This program demonstrates creating a variable with type <code class="docutils literal notranslate"><span class="pre">bool</span></code> and
setting it to <code class="docutils literal notranslate"><span class="pre">true</span></code>, and then setting another variable to the
logical negation of it:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="o">!</span><span class="nx">x</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
</pre></div>
</div>
<p>All three variables have type <code class="docutils literal notranslate"><span class="pre">bool</span></code>.  Note that the types of <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> are optional; the program indicates the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> but
the compiler infers the type of <code class="docutils literal notranslate"><span class="pre">y</span></code>.  See <a class="reference internal" href="variables.html#chapter-variables"><span class="std std-ref">Variables</span></a>
for more details. The last variable is initialized to the default
value of <code class="docutils literal notranslate"><span class="pre">bool</span></code>, which is <code class="docutils literal notranslate"><span class="pre">false</span></code> (see <a class="reference internal" href="variables.html#default-values-for-types"><span class="std std-ref">Default Initialization</span></a>).</p>
</div></blockquote>
</section>
<section id="signed-and-unsigned-integral-types">
<span id="index-5"></span><span id="id5"></span><h3>Signed and Unsigned Integral Types<a class="headerlink" href="#signed-and-unsigned-integral-types" title="Link to this heading">¶</a></h3>
<p>The integral types can be parameterized by the number of bits used to
represent them. Valid bit-sizes are 8, 16, 32, and 64. The default
signed integral type, <code class="docutils literal notranslate"><span class="pre">int</span></code>, is a synonym for <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>; and the
default unsigned integral type, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, is a synonym for <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code>.</p>
<p>Variables of integral type have a default value of <code class="docutils literal notranslate"><span class="pre">0</span></code> if they are
not initialized to something else (see also <a class="reference internal" href="variables.html#chapter-variables"><span class="std std-ref">Variables</span></a>).</p>
<p>The integral types and their ranges are given in the following table:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Minimum Value</strong></p></th>
<th class="head"><p><strong>Maximum Value</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int(8)</p></td>
<td><p>-128</p></td>
<td><p>127</p></td>
</tr>
<tr class="row-odd"><td><p>uint(8)</p></td>
<td><p>0</p></td>
<td><p>255</p></td>
</tr>
<tr class="row-even"><td><p>int(16)</p></td>
<td><p>-32768</p></td>
<td><p>32767</p></td>
</tr>
<tr class="row-odd"><td><p>uint(16)</p></td>
<td><p>0</p></td>
<td><p>65535</p></td>
</tr>
<tr class="row-even"><td><p>int(32)</p></td>
<td><p>-2147483648</p></td>
<td><p>2147483647</p></td>
</tr>
<tr class="row-odd"><td><p>uint(32)</p></td>
<td><p>0</p></td>
<td><p>4294967295</p></td>
</tr>
<tr class="row-even"><td><p>int(64), int</p></td>
<td><p>-9223372036854775808</p></td>
<td><p>9223372036854775807</p></td>
</tr>
<tr class="row-odd"><td><p>uint(64), uint</p></td>
<td><p>0</p></td>
<td><p>18446744073709551615</p></td>
</tr>
</tbody>
</table>
<p>Integer literals such as <cite>3</cite> have type <code class="docutils literal notranslate"><span class="pre">int</span></code>. However, such literals
can implicitly convert to other numeric types that can losslessly store
the value. See <a class="reference internal" href="conversions.html#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>.
Integer literals can be written in hexadecimal, octal, or binary. See
<a class="reference internal" href="lexical-structure.html#literals"><span class="std std-ref">Literals</span></a>.</p>
<p>Signed integral types of can implicitly convert to signed integral types
of larger width. Additionally, signed integral types can implicitly
convert to unsigned integral types of the same or larger width. Unsigned
integral types can implicitly convert to both signed and unsigned
integral type of larger width. See <a class="reference internal" href="conversions.html#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>
for details.</p>
<p>It is possible for overflow to occur with binary operators on integers.
For signed integers, overflow leads to undefined behavior. For unsigned
integers, overflow leads to wrapping since any bits not representable
will be discarded.</p>
<blockquote>
<div><p><em>Example (integers.chpl)</em>.</p>
<p>Here, <code class="docutils literal notranslate"><span class="pre">x</span></code> is inferred to have type <code class="docutils literal notranslate"><span class="pre">int</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">y</span></code> is initialized by converting <code class="docutils literal notranslate"><span class="pre">2</span></code> to a <code class="docutils literal notranslate"><span class="pre">uint(8)</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">y</span><span class="p">:</span><span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, <code class="docutils literal notranslate"><span class="pre">z</span></code> is set to an expression that would evaluate to <code class="docutils literal notranslate"><span class="pre">257</span></code>,
but that is not representable as a <code class="docutils literal notranslate"><span class="pre">uint(8)</span></code>, so it results in the
wrapped value <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="real-types">
<span id="index-6"></span><span id="id6"></span><h3>Real Types<a class="headerlink" href="#real-types" title="Link to this heading">¶</a></h3>
<p>Unlike integral types, <code class="docutils literal notranslate"><span class="pre">real</span></code> types are floating point types that can
store fractional values. Like the integral types, the real types can be
parameterized by the number of bits used to represent them. The default
real type, <code class="docutils literal notranslate"><span class="pre">real</span></code>, is 64 bits. The real types that are supported are
machine-dependent, but usually include <code class="docutils literal notranslate"><span class="pre">real(32)</span></code> (single precision)
and <code class="docutils literal notranslate"><span class="pre">real(64)</span></code> (double precision) following the IEEE 754 standard.</p>
<p>Variables of <code class="docutils literal notranslate"><span class="pre">real</span></code> type have a default value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> if they are
not initialized to something else (see also <a class="reference internal" href="variables.html#chapter-variables"><span class="std std-ref">Variables</span></a>).</p>
<p>All integral types can implicitly convert to all <code class="docutils literal notranslate"><span class="pre">real</span></code> types, and
<code class="docutils literal notranslate"><span class="pre">real(32)</span></code> can implicitly convert to <code class="docutils literal notranslate"><span class="pre">real(64)</span></code>. See
<a class="reference internal" href="conversions.html#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a> for details.</p>
<p><code class="docutils literal notranslate"><span class="pre">real</span></code> literals such as <cite>5.2</cite> have type <code class="docutils literal notranslate"><span class="pre">real</span></code>. However, such literals
can implicitly convert to other numeric types that can losslessly store
the value. See <a class="reference internal" href="conversions.html#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>.
<code class="docutils literal notranslate"><span class="pre">real</span></code> literals can be written in decimal or hexadecimal and with or
without an exponent (see <a class="reference internal" href="lexical-structure.html#literals"><span class="std std-ref">Literals</span></a> for details):</p>
<blockquote>
<div><ul>
<li><p>in decimal without an exponent, e.g. <code class="docutils literal notranslate"><span class="pre">5.2</span></code></p></li>
<li><p>in decimal with an exponent, e.g. <code class="docutils literal notranslate"><span class="pre">6.02e23</span></code></p></li>
<li><p>in hexadecimal without an exponent, e.g. <code class="docutils literal notranslate"><span class="pre">0x2.fe</span></code></p></li>
<li><p>in hexadecimal with a decimal exponent, e.g. <code class="docutils literal notranslate"><span class="pre">0x2.fep23</span></code></p>
<p><em>Example (harmonic.chpl)</em>.</p>
<p>For example, this program computes the first <code class="docutils literal notranslate"><span class="pre">n</span></code> terms of the
harmonic series.</p>
<p>First, it defines a <code class="docutils literal notranslate"><span class="pre">config</span> <span class="pre">const</span></code> to allow setting the value of
<code class="docutils literal notranslate"><span class="pre">n</span></code> on the command line (see <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">Variable Declarations</span></a>):</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, it declares a <code class="docutils literal notranslate"><span class="pre">real</span></code> variable. Since this variable isn’t
initialized, it will be initialized to 0.0:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sum</span><span class="p">:</span><span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, it loops over the first <cite>n</cite> elements and adds them to the
sum (see also <a class="reference internal" href="statements.html#the-for-loop"><span class="std std-ref">The For Loop</span></a>):</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="o">/</span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that it uses <cite>1.0/i</cite> in order to do a floating point division. If
it used <cite>1/i</cite>, it would do integer division (rounding towards zero),
which evaluates to <code class="docutils literal notranslate"><span class="pre">0</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
<p>Finally, it prints out the sum:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</section>
<section id="imaginary-types">
<span id="index-7"></span><span id="id7"></span><h3>Imaginary Types<a class="headerlink" href="#imaginary-types" title="Link to this heading">¶</a></h3>
<p>Imaginary types are floating-point types, and similarly to <code class="docutils literal notranslate"><span class="pre">real</span></code>
types, they can be parameterized by the number of bits used to
represent them. The default imaginary type, <code class="docutils literal notranslate"><span class="pre">imag</span></code>, is 64 bits. The
imaginary types that are supported are machine-dependent, but usually
include <code class="docutils literal notranslate"><span class="pre">imag(32)</span></code> and <code class="docutils literal notranslate"><span class="pre">imag(64)</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The imaginary type is included to avoid numeric instabilities and
under-optimized code stemming from always converting real values to
complex values with a zero imaginary part.</p>
</div></blockquote>
<p>Imaginary literals can be created by appending <code class="docutils literal notranslate"><span class="pre">i</span></code> to a numeric
literal; for example, <code class="docutils literal notranslate"><span class="pre">0.6i</span></code>. Such literals have type <code class="docutils literal notranslate"><span class="pre">imag</span></code>.
However, such literals can implicitly convert to other numeric types that
can losslessly store the value. See
<a class="reference internal" href="conversions.html#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>.  As with <code class="docutils literal notranslate"><span class="pre">real</span></code>
literals, imaginary literals can be written in decimal or hexadecimal and
with or without an exponent (see <a class="reference internal" href="lexical-structure.html#literals"><span class="std std-ref">Literals</span></a> for details):</p>
<p>Variables of <code class="docutils literal notranslate"><span class="pre">imag</span></code> type have a default value of <code class="docutils literal notranslate"><span class="pre">0.0i</span></code> if they are
not initialized to something else (see also <a class="reference internal" href="variables.html#chapter-variables"><span class="std std-ref">Variables</span></a>).</p>
<p>It is possible to convert between a <code class="docutils literal notranslate"><span class="pre">real</span></code> value and an <code class="docutils literal notranslate"><span class="pre">imag</span></code> value
using an explicit cast (see <a class="reference internal" href="conversions.html#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a>). Similarly, an
<code class="docutils literal notranslate"><span class="pre">imag</span></code> value can be cast to a <code class="docutils literal notranslate"><span class="pre">real</span></code> value. Such casts preserve the
floating-point value while changing whether or not it is imaginary.</p>
<blockquote>
<div><p><em>Example (imaginary.chpl)</em>.</p>
<p>For example, this program creates imaginary numbers in two different
ways. First, <code class="docutils literal notranslate"><span class="pre">a</span></code> is an <code class="docutils literal notranslate"><span class="pre">imag</span></code> variable initialized to a literal:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="m">0.6i</span><span class="p">;</span>
</pre></div>
</div>
<p>Now, suppose we have a <code class="docutils literal notranslate"><span class="pre">real</span></code> value <code class="docutils literal notranslate"><span class="pre">s</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="mf">10.25</span><span class="p">;</span>
</pre></div>
</div>
<p>We can initialize an <code class="docutils literal notranslate"><span class="pre">imag</span></code> variable with the same numeric value,
but as an imaginary value, with a cast:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">s</span><span class="p">:</span><span class="kt">imag</span><span class="p">;</span>
<span class="nx">assert</span><span class="p">(</span><span class="nx">b</span> <span class="o">==</span> <span class="m">10.25i</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="complex-types">
<span id="index-8"></span><span id="id8"></span><h3>Complex Types<a class="headerlink" href="#complex-types" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">complex</span></code> type represents a complex number. A <code class="docutils literal notranslate"><span class="pre">complex</span></code> value has
floating-point values for the real and imaginary components.</p>
<p>As with the integral and real types, the type <code class="docutils literal notranslate"><span class="pre">complex</span></code> can be
parameterized by the number of bits used to represent the complex number.
Since the complex number consists of two components, the number of bits
used to represent it is twice the number of bits used to represent each
component.</p>
<p>In particular:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">complex(64)</span></code> contains two <code class="docutils literal notranslate"><span class="pre">real(32)</span></code> fields</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">complex(128)</span></code> contains two <code class="docutils literal notranslate"><span class="pre">real(64)</span></code> fields</p></li>
</ul>
</div></blockquote>
<p>The real and imaginary components can be accessed via the methods <code class="docutils literal notranslate"><span class="pre">re</span></code>
and <code class="docutils literal notranslate"><span class="pre">im</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">im</span></code> returns a <code class="docutils literal notranslate"><span class="pre">real</span></code> of appropriate width,
rather than an <code class="docutils literal notranslate"><span class="pre">imag</span></code>.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>Given a complex number <code class="docutils literal notranslate"><span class="pre">c</span></code> with the value <code class="docutils literal notranslate"><span class="pre">3.14+2.72i</span></code>, the
expressions <code class="docutils literal notranslate"><span class="pre">c.re</span></code> and <code class="docutils literal notranslate"><span class="pre">c.im</span></code> refer to <code class="docutils literal notranslate"><span class="pre">3.14</span></code> and <code class="docutils literal notranslate"><span class="pre">2.72</span></code>
respectively.</p>
</div></blockquote>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="complex.re">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">complex.</span></span><span class="sig-name descname"><span class="pre">re</span></span><span class="w"> </span><em class="property"> <span class="pre">ref</span></em><a class="headerlink" href="#complex.re" title="Link to this definition">¶</a></dt>
<dd><p>When used as a value, this returns the real component of
the complex number as a <em>real</em>.</p>
<p>When used as an lvalue, this is a setter that assigns the
real component.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="complex.im">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">complex.</span></span><span class="sig-name descname"><span class="pre">im</span></span><span class="w"> </span><em class="property"> <span class="pre">ref</span></em><a class="headerlink" href="#complex.im" title="Link to this definition">¶</a></dt>
<dd><p>When used as a value, this returns the imaginary component of
the complex number as a <em>real</em>.</p>
<p>When used as an lvalue, this is a setter that assigns the
imaginary component.</p>
</dd></dl>

<p>The standard <a class="reference internal" href="../../modules/standard/Math.html#module-Math" title="Math: This module provides frequently used mathematical constants and functions."><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">Math</span></code></a> module provides more functions on complex types.
See the <a class="reference internal" href="../../modules/standard/Math.html#module-Math" title="Math: This module provides frequently used mathematical constants and functions."><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">Math</span></code></a> module documentation.</p>
</section>
<section id="the-string-type">
<span id="index-9"></span><span id="id9"></span><h3>The String Type<a class="headerlink" href="#the-string-type" title="Link to this heading">¶</a></h3>
<p>Strings are a primitive type designated by the symbol <code class="docutils literal notranslate"><span class="pre">string</span></code>
comprised of Unicode characters in UTF-8 encoding. Their length is
unbounded. Strings are defined in <a class="reference internal" href="strings.html#chapter-strings"><span class="std std-ref">Strings</span></a>.</p>
</section>
<section id="the-bytes-type">
<span id="index-10"></span><span id="id10"></span><h3>The Bytes Type<a class="headerlink" href="#the-bytes-type" title="Link to this heading">¶</a></h3>
<p>Bytes is a primitive type designated by the symbol <code class="docutils literal notranslate"><span class="pre">bytes</span></code> comprised
of arbitrary bytes. Bytes are immutable in-place and their length is
unbounded. Bytes are defined in <a class="reference internal" href="bytes.html#chapter-bytes"><span class="std std-ref">Bytes</span></a>.</p>
</section>
</section>
<section id="enumerated-types">
<span id="index-11"></span><span id="id11"></span><h2>Enumerated Types<a class="headerlink" href="#enumerated-types" title="Link to this heading">¶</a></h2>
<p>Enumerated types are declared with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>enum-declaration-statement:
  &#39;enum&#39; identifier { enum-constant-list }

enum-constant-list:
  enum-constant
  enum-constant , enum-constant-list[OPT]

enum-constant:
  identifier init-part[OPT]

init-part:
  = expression
</pre></div>
</div>
<p>The enumerated type can then be referenced by its name, as summarized by
the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>enum-type:
  identifier
</pre></div>
</div>
<p>An enumerated type defines a set of named constants that can be referred
to via a member access on the enumerated type. Each enumerated type is a
distinct type.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">init-part</span></code> is omitted for all of the named constants in an
enumerated type, the enumerated values are <em>abstract</em> and do not have
associated integer values. Any constant that has an <code class="docutils literal notranslate"><span class="pre">init-part</span></code> will
be associated with that integer value. Such constants must be parameter
values of integral type. Any constant that does not have an
<code class="docutils literal notranslate"><span class="pre">init-part</span></code>, yet which follows one that does, will be associated with
an integer value one greater than its predecessor. An enumerated type
whose first constant has an <code class="docutils literal notranslate"><span class="pre">init-part</span></code> is called <em>concrete</em>, since
all constants in the enum will have an associated integer value, whether
explicit or implicit. An enumerated type that specifies an <code class="docutils literal notranslate"><span class="pre">init-part</span></code>
for some constants, but not the first is called <em>semi-concrete</em>. Numeric
conversions are automatically supported for enumerated types which are
concrete or semi-concrete
(see <a class="reference internal" href="conversions.html#explicit-enumeration-conversions"><span class="std std-ref">Explicit Enumeration Conversions</span></a>).</p>
<blockquote>
<div><p><em>Example (enum-statesmen.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nx">statesman</span> <span class="p">{</span> <span class="nx">Aristotle</span><span class="p">,</span> <span class="nx">Roosevelt</span><span class="p">,</span> <span class="nx">Churchill</span><span class="p">,</span> <span class="nx">Kissinger</span> <span class="p">}</span>
</pre></div>
</div>
<p>defines an abstract enumerated type with four constants. The function</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">quote</span><span class="p">(</span><span class="nx">s</span><span class="p">:</span> <span class="nx">statesman</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">select</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="k">when</span> <span class="nx">statesman</span><span class="p">.</span><span class="nx">Aristotle</span> <span class="k">do</span>
       <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;All paid jobs absorb and degrade the mind.&quot;</span><span class="p">);</span>
    <span class="k">when</span> <span class="nx">statesman</span><span class="p">.</span><span class="nx">Roosevelt</span> <span class="k">do</span>
       <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Every reform movement has a lunatic fringe.&quot;</span><span class="p">);</span>
    <span class="k">when</span> <span class="nx">statesman</span><span class="p">.</span><span class="nx">Churchill</span> <span class="k">do</span>
       <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;A joke is a very serious thing.&quot;</span><span class="p">);</span>
    <span class="k">when</span> <span class="nx">statesman</span><span class="p">.</span><span class="nx">Kissinger</span> <span class="k">do</span>
       <span class="p">{</span> <span class="nx">write</span><span class="p">(</span><span class="s">&quot;No one will ever win the battle of the sexes; &quot;</span><span class="p">);</span>
         <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;there&#39;s too much fraternizing with the enemy.&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>outputs a quote from the given statesman. Note that enumerated
constants must be prefixed by the enumerated type name and a dot
unless a use statement is employed
(see <a class="reference internal" href="statements.html#the-use-statement"><span class="std std-ref">The Use Statement</span></a> and <a class="reference internal" href="modules.html#using-modules"><span class="std std-ref">Using Modules</span></a>).</p>
</div></blockquote>
<p>It is possible to iterate over an enumerated type. The loop body will be
invoked on each named constant in the enum. The following method is also
available:</p>
<dl class="chpl function">
<dt class="sig sig-object chpl" id="enum.size">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">enum.</span></span><span class="sig-name descname"><span class="pre">size</span></span><em class="property"> <span class="pre">:</span> <span class="pre">param</span> <span class="pre">int</span></em><a class="headerlink" href="#enum.size" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of constants in the given enumerated type.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="enum.first">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">enum.</span></span><span class="sig-name descname"><span class="pre">first</span></span><em class="property"> <span class="pre">:</span> <span class="pre">enum</span></em><a class="headerlink" href="#enum.first" title="Link to this definition">¶</a></dt>
<dd><p>Returns the first constant in the enumerated type.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="enum.last">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">enum.</span></span><span class="sig-name descname"><span class="pre">last</span></span><em class="property"> <span class="pre">:</span> <span class="pre">enum</span></em><a class="headerlink" href="#enum.last" title="Link to this definition">¶</a></dt>
<dd><p>Returns the last constant in the enumerated type.</p>
</dd></dl>

</section>
<section id="structured-types">
<span id="index-12"></span><span id="id12"></span><h2>Structured Types<a class="headerlink" href="#structured-types" title="Link to this heading">¶</a></h2>
<p>The structured types are summarized by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>structured-type:
  class-type
  record-type
  union-type
  tuple-type
</pre></div>
</div>
<p>Classes are discussed in <a class="reference internal" href="classes.html#chapter-classes"><span class="std std-ref">Classes</span></a>. Records are
discussed in <a class="reference internal" href="records.html#chapter-records"><span class="std std-ref">Records</span></a>. Unions are discussed in
<a class="reference internal" href="unions.html#chapter-unions"><span class="std std-ref">Unions</span></a>. Tuples are discussed in
<a class="reference internal" href="tuples.html#chapter-tuples"><span class="std std-ref">Tuples</span></a>.</p>
<section id="class-types">
<span id="types-class-types"></span><h3>Class Types<a class="headerlink" href="#class-types" title="Link to this heading">¶</a></h3>
<p>A class can contain variables, constants, and methods.</p>
<p>Classes are defined in <a class="reference internal" href="classes.html#chapter-classes"><span class="std std-ref">Classes</span></a>. The class type can
also contain type aliases and parameters. Such a class is generic and is
defined in <a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<p>A class type <code class="docutils literal notranslate"><span class="pre">C</span></code> has several variants:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">C?</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C?</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C?</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C?</span></code></p></li>
</ul>
<p>The variants with a question mark, such as <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C?</span></code>, can store
<code class="docutils literal notranslate"><span class="pre">nil</span></code> (see <a class="reference internal" href="classes.html#nilable-classes"><span class="std std-ref">Nilable Class Types</span></a>). Variants without a
question mark cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The keywords <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>,
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> indicate the memory management strategy
used for the class. When none is specified, as with <code class="docutils literal notranslate"><span class="pre">C</span></code> or <code class="docutils literal notranslate"><span class="pre">C?</span></code>, the
class is considered to have generic memory management strategy.
See <a class="reference internal" href="classes.html#class-types"><span class="std std-ref">Class Types</span></a>.</p>
</section>
<section id="record-types">
<span id="types-record-types"></span><h3>Record Types<a class="headerlink" href="#record-types" title="Link to this heading">¶</a></h3>
<p>Records can contain variables, constants, and methods. Unlike class
types, records are values rather than references. Records are defined
in <a class="reference internal" href="records.html#chapter-records"><span class="std std-ref">Records</span></a>.</p>
</section>
<section id="union-types">
<span id="types-union-types"></span><h3>Union Types<a class="headerlink" href="#union-types" title="Link to this heading">¶</a></h3>
<p>The union type defines a type that contains one of a set of variables.
Like classes and records, unions may also define methods. Unions are
defined in <a class="reference internal" href="unions.html#chapter-unions"><span class="std std-ref">Unions</span></a>.</p>
</section>
<section id="tuple-types">
<span id="types-tuple-types"></span><h3>Tuple Types<a class="headerlink" href="#tuple-types" title="Link to this heading">¶</a></h3>
<p>A tuple is a light-weight record that consists of one or more anonymous
fields. If all the fields are of the same type, the tuple is
homogeneous. Tuples are defined in <a class="reference internal" href="tuples.html#chapter-tuples"><span class="std std-ref">Tuples</span></a>.</p>
</section>
</section>
<section id="data-parallel-types">
<span id="index-13"></span><span id="id13"></span><h2>Data Parallel Types<a class="headerlink" href="#data-parallel-types" title="Link to this heading">¶</a></h2>
<p>The data parallel types are summarized by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>dataparallel-type:
  range-type
  domain-type
  mapped-domain-type
  array-type
  index-type
</pre></div>
</div>
<p>Ranges and their index types are discussed in <a class="reference internal" href="ranges.html#chapter-ranges"><span class="std std-ref">Ranges</span></a>.
Domains and their index types are discussed in
<a class="reference internal" href="domains.html#chapter-domains"><span class="std std-ref">Domains</span></a>. Arrays are discussed in
<a class="reference internal" href="arrays.html#chapter-arrays"><span class="std std-ref">Arrays</span></a>.</p>
<section id="range-types">
<span id="types-range-types"></span><h3>Range Types<a class="headerlink" href="#range-types" title="Link to this heading">¶</a></h3>
<p>A range defines an integral sequence of some integral type. Ranges are
defined in <a class="reference internal" href="ranges.html#chapter-ranges"><span class="std std-ref">Ranges</span></a>.</p>
</section>
<section id="domain-array-and-index-types">
<span id="domain-and-array-types"></span><h3>Domain, Array, and Index Types<a class="headerlink" href="#domain-array-and-index-types" title="Link to this heading">¶</a></h3>
<p>A domain defines a set of indices. An array defines a set of elements
that correspond to the indices in its domain. A domain’s indices can be
of any type. Domains, arrays, and their index types are defined in
<a class="reference internal" href="domains.html#chapter-domains"><span class="std std-ref">Domains</span></a> and <a class="reference internal" href="arrays.html#chapter-arrays"><span class="std std-ref">Arrays</span></a>.</p>
</section>
</section>
<section id="synchronization-types">
<span id="index-14"></span><span id="id14"></span><h2>Synchronization Types<a class="headerlink" href="#synchronization-types" title="Link to this heading">¶</a></h2>
<p>The synchronization types are summarized by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>synchronization-type:
  sync-type
  atomic-type
</pre></div>
</div>
<p>The sync type is discussed in
<a class="reference internal" href="task-parallelism-and-synchronization.html#synchronization-variables"><span class="std std-ref">Synchronization Variables</span></a>. The atomic type is discussed
in <a class="reference internal" href="task-parallelism-and-synchronization.html#atomic-variables"><span class="std std-ref">Atomic Variables</span></a>.</p>
</section>
<section id="type-aliases">
<span id="index-15"></span><span id="id15"></span><h2>Type Aliases<a class="headerlink" href="#type-aliases" title="Link to this heading">¶</a></h2>
<p>Type aliases are declared with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>type-alias-declaration-statement:
  privacy-specifier[OPT] &#39;config&#39;[OPT] &#39;type&#39; type-alias-declaration-list ;
  external-type-alias-declaration-statement

type-alias-declaration-list:
  type-alias-declaration
  type-alias-declaration , type-alias-declaration-list

type-alias-declaration:
  identifier = type-expression
  identifier
</pre></div>
</div>
<p>A type alias is a symbol that aliases the type specified in the
<code class="docutils literal notranslate"><span class="pre">type-expression</span></code>. A use of a type alias has the same meaning as using
the type specified by <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> directly.</p>
<p>Type aliases defined at the module level are public by default. The
optional <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> keywords are provided to specify or
change this behavior. For more details on the visibility of symbols, see
 <a class="reference internal" href="modules.html#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>.</p>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">config</span></code> precedes the keyword <code class="docutils literal notranslate"><span class="pre">type</span></code>, the type alias
is called a configuration type alias. Configuration type aliases can be
set at compilation time via compilation flags or other
implementation-defined means. The <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> in the program is
ignored if the type-alias is alternatively set.</p>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">extern</span></code> precedes the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword, the type alias
is external. The declared type name is used by Chapel for type
resolution, but no type alias is generated by the backend. See the
chapter on interoperability
(<a class="reference internal" href="interoperability.html#chapter-interoperability"><span class="std std-ref">Interoperability</span></a>) for more information on
external types.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> is optional in the definition of a class or
record. Such a type alias is called an unspecified type alias. Classes
and records that contain type aliases, specified or unspecified, are
generic (<a class="reference internal" href="generics.html#type-aliases-in-generic-types"><span class="std std-ref">Type Aliases in Generic Types</span></a>).</p>
<blockquote>
<div><p><em>Example (type-alias.chpl)</em>.</p>
<p>The declaration</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">t</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>defines a <code class="docutils literal notranslate"><span class="pre">t</span></code> as a synonym for the type <code class="docutils literal notranslate"><span class="pre">int</span></code>. Functions and
methods available on <code class="docutils literal notranslate"><span class="pre">int</span></code> will apply to variables declared with
type <code class="docutils literal notranslate"><span class="pre">t</span></code>. For example,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</pre></div>
</div>
<p>will print out <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</div></blockquote>
</section>
<section id="querying-the-type-of-an-expression">
<span id="id16"></span><h2>Querying the Type of an Expression<a class="headerlink" href="#querying-the-type-of-an-expression" title="Link to this heading">¶</a></h2>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>type-query-expression:
  expression . &#39;type&#39;
</pre></div>
</div>
<p>The type of a an expression can be queried with <code class="docutils literal notranslate"><span class="pre">.type</span></code>. This
functionality is particularly useful when doing generic programming
(see <a class="reference internal" href="generics.html#chapter-generics"><span class="std std-ref">Generics</span></a>).</p>
<blockquote>
<div><p><em>Example (dot-type.chpl)</em>.</p>
<p>For example, this code uses <code class="docutils literal notranslate"><span class="pre">.type</span></code> to query the type of the
variable <code class="docutils literal notranslate"><span class="pre">x</span></code> and store that in the type alias <code class="docutils literal notranslate"><span class="pre">t</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
</pre></div>
</div>
<p><em>Open issue</em>.</p>
<p>Given a nested expression that has <code class="docutils literal notranslate"><span class="pre">.type</span></code> called on it,
for example <code class="docutils literal notranslate"><span class="pre">f()</span></code> in <code class="docutils literal notranslate"><span class="pre">f().type</span></code>, in which circumstances should
<code class="docutils literal notranslate"><span class="pre">f()</span></code> be evaluated for side effects?</p>
<p>At first it might seem that <code class="docutils literal notranslate"><span class="pre">f()</span></code> should never be evaluated for side
effects. However, it must be evaluated for side effects if <code class="docutils literal notranslate"><span class="pre">f()</span></code> returns an
array or domain type, as these have a runtime component (see
<a class="reference internal" href="#types-with-runtime-components"><span class="std std-ref">Types with Runtime Components</span></a>). As a result, should <code class="docutils literal notranslate"><span class="pre">f()</span></code> in
such a setting always be evaluated for side effects?  The answer to
this question also also connected to the question of whether or not a
when a function returning a <code class="docutils literal notranslate"><span class="pre">type</span></code> is evaluated for side effects at
runtime.</p>
<p>One approach might be to introduce different means to query only the
compile-time component of the type or only the runtime component of
the time.</p>
</div></blockquote>
</section>
<section id="operations-available-on-types">
<span id="id17"></span><h2>Operations Available on Types<a class="headerlink" href="#operations-available-on-types" title="Link to this heading">¶</a></h2>
<p>This section discusses how type expressions can be used. Type expressions
include types, type aliases, <code class="docutils literal notranslate"><span class="pre">.type</span></code> queries, and calls to functions
that use the <code class="docutils literal notranslate"><span class="pre">type</span></code> return intent.</p>
<p>A type expression can be used to indicate the type of a value, as with
<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x:</span> <span class="pre">typeExpression;</span></code> (see <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">Variable Declarations</span></a>).</p>
<p>A type expression can be passed to a <code class="docutils literal notranslate"><span class="pre">type</span></code> formal of a generic
function (see <a class="reference internal" href="generics.html#formal-type-arguments"><span class="std std-ref">Formal Type Arguments</span></a>).</p>
<p>The <a class="reference internal" href="../../modules/standard/Types.html#module-Types" title="Types: Functions related to predefined types."><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">Types</span></code></a> module provides many functions to query properties of
types.</p>
<p>The language provides <a class="reference internal" href="../../modules/standard/Types.html#Types.isCoercible" title="Types.isCoercible"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">isCoercible</span></code></a>,
<a class="reference internal" href="../../modules/standard/Types.html#Types.isSubtype" title="Types.isSubtype"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">isSubtype</span></code></a>, and
<a class="reference internal" href="../../modules/standard/Types.html#Types.isProperSubtype" title="Types.isProperSubtype"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">isProperSubtype</span></code></a> for comparing types.
The normal comparison operators are also available to compare types:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">==</span></code> checks if two types are equivalent</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!=</span></code> checks if two types are different</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> check if one type is a proper subtype of another (see
<a class="reference internal" href="../../modules/standard/Types.html#Types.&lt;" title="Types.&lt;"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">&lt;</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> check if one type is a subtype of another (see
<a class="reference internal" href="../../modules/standard/Types.html#Types.&lt;=" title="Types.&lt;="><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">&lt;=</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p>It is possible to cast a type to a <code class="docutils literal notranslate"><span class="pre">param</span></code> string. This allows a type
to be printed out.</p>
<blockquote>
<div><p><em>Example (type-to-string.chpl)</em>.</p>
<blockquote>
<div><p>For example, this code casts the type <code class="docutils literal notranslate"><span class="pre">myType</span></code> to a string in order
to print it out:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">myType</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">param</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">myType</span><span class="p">:</span><span class="kt">string</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
</pre></div>
</div>
<p>It produces the output:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>int(64)
</pre></div>
</div>
<p><em>Open issue</em>.</p>
<p>If type comparison with <code class="docutils literal notranslate"><span class="pre">==</span></code> is called on two types with runtime
components (see <a class="reference internal" href="#types-with-runtime-components"><span class="std std-ref">Types with Runtime Components</span></a>), should the
runtime component be included in the comparison? Or, should <code class="docutils literal notranslate"><span class="pre">==</span></code> on
types only consider if the compile-time components match?</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="types-with-runtime-components">
<span id="id18"></span><h2>Types with Runtime Components<a class="headerlink" href="#types-with-runtime-components" title="Link to this heading">¶</a></h2>
<p>Domain and array types include a <em>runtime component</em>. (See
<a class="reference internal" href="domains.html#chapter-domains"><span class="std std-ref">Domains</span></a> and <a class="reference internal" href="arrays.html#chapter-arrays"><span class="std std-ref">Arrays</span></a> for more on arrays and
domains).</p>
<p>For a domain type, the runtime component of the type is the distribution over
which the domain was declared.</p>
<p>For an array type, the runtime component of the type contains the domain
over which the array was declared and the runtime component of the
array’s element type, if present.</p>
<p>As a result, an array or domain type will be represented and manipulated
at runtime. In particular, a function that returns a type with a runtime
component will be executed at runtime.</p>
<p>These features combine with the <code class="docutils literal notranslate"><span class="pre">.type</span></code> syntax to allow one to create
an array that has the same element type, shape, and distribution as an
existing array.</p>
<blockquote>
<div><p><em>Example (same-domain-array.chpl)</em>.</p>
<blockquote>
<div><p>The example below shows a function that accepts an array and then
creates another array with the same element type, shape, and distribution:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">makeAnotherArray</span><span class="p">(</span><span class="nx">arr</span><span class="p">:</span> <span class="p">[])</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">newArray</span><span class="p">:</span> <span class="nx">arr</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">newArray</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above program is equivalent to this program:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">equivalentAlternative</span><span class="p">(</span><span class="nx">arr</span><span class="p">:</span> <span class="p">[])</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">newArray</span><span class="p">:[</span><span class="nx">arr</span><span class="p">.</span><span class="k">domain</span><span class="p">]</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">eltType</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">newArray</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both create and return an array storing the same element type as the
passed array.</p>
<blockquote>
<div></div></blockquote>
<p><em>Open issue</em>.</p>
<p>Should a record or class type also have a runtime component when it
contains array/domain field(s)? This runtime component is needed, for
example, to create a default-initialized instance of such a type in
the absence of user-defined default initializer.</p>
<p><em>Open issue</em>.</p>
<p>Class types are not currently considered to have a runtime component.
Should class types be considered to have a runtime component, so that
querying an instance’s type with <code class="docutils literal notranslate"><span class="pre">myObject.type</span></code> will produce the
type of the object known at runtime, rather than the type with which
<code class="docutils literal notranslate"><span class="pre">myObject</span></code> was declared?</p>
<p><em>Open issue</em>.</p>
<p>Should functions returning a type always be evaluated for side
effects, or only evaluated for side effects when returning a type with
a runtime component?</p>
</div></blockquote>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lexical-structure.html" class="btn btn-neutral float-left" title="Lexical Structure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="variables.html" class="btn btn-neutral float-right" title="Variables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>