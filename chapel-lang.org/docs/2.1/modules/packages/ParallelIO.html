<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ParallelIO &mdash; Chapel Documentation 2.1</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=20623aea"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="RecordParser" href="RecordParser.html" />
    <link rel="prev" title="ObjectSerialization" href="ObjectSerialization.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.1
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.1";
$pagename = "modules/packages/ParallelIO";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../standard.html">Standard Modules</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../packages.html">Package Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../packages.html#algorithms">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#communication-inter-locale">Communication (Inter-Locale)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#data-structures">Data Structures</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../packages.html#file-formats-and-i-o">File Formats and I/O</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ChplFormat.html">ChplFormat</a></li>
<li class="toctree-l3"><a class="reference internal" href="HDF5.html">HDF5</a></li>
<li class="toctree-l3"><a class="reference internal" href="HDFS.html">HDFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="Image.html">Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetCDF.html">NetCDF</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectSerialization.html">ObjectSerialization</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">ParallelIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="RecordParser.html">RecordParser</a></li>
<li class="toctree-l3"><a class="reference internal" href="TOML.html">TOML</a></li>
<li class="toctree-l3"><a class="reference internal" href="YAML.html">YAML</a></li>
<li class="toctree-l3"><a class="reference internal" href="Zarr.html">Zarr</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#math-numerical-computing">Math / Numerical Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#networking-inter-process-communication">Networking / Inter-Process Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#parallel-computing">Parallel Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#tool-support">Tool Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../packages.html">Package Modules</a></li>
      <li class="breadcrumb-item active">ParallelIO</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/packages/ParallelIO.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="parallelio">
<span id="module-ParallelIO"></span><h1>ParallelIO<a class="headerlink" href="#parallelio" title="Link to this heading">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">ParallelIO</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">ParallelIO</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>the ‘parallelIO’ module is unstable and subject to change in a future release</p>
</div>
<p>Helper procedures for doing parallel I/O</p>
<p>This module provides a few procedures for reading a file’s contents into
a distributed array in parallel. The procedures are designed to be used for
cases where a large file contains a header followed by a continuous stream
of delimited values of the same type. The procedures are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ParallelIO.readLinesAsBlockArray" title="ParallelIO.readLinesAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readLinesAsBlockArray</span></code></a>: read each of the lines of a file as a
<code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> value</p></li>
<li><p><a class="reference internal" href="#ParallelIO.readDelimitedAsBlockArray" title="ParallelIO.readDelimitedAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readDelimitedAsBlockArray</span></code></a>: read a file where each value is strictly
separated by a delimiter, and the delimiter cannot be found in the
value (e.g., CSV)</p></li>
<li><p><a class="reference internal" href="#ParallelIO.readItemsAsBlockArray" title="ParallelIO.readItemsAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readItemsAsBlockArray</span></code></a>: read a file where values are separated by a
delimiter, but the delimiter can be found in the value</p></li>
</ul>
<p>There are also non-distributed versions of these procedures that return a
default rectangular array instead of a block-distributed array. These tend
to be a faster option if the file is small enough to fit in memory on a
single locale.</p>
<p>Two parallel iterators are also provided:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ParallelIO.readLines" title="ParallelIO.readLines"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readLines</span></code></a>: iterate over a file’s lines in parallel</p></li>
<li><p><a class="reference internal" href="#ParallelIO.readDelimited" title="ParallelIO.readDelimited"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readDelimited</span></code></a>: iterate over the values of a delimited file in parallel</p></li>
</ul>
<p>Both iterators only work in a standalone context (i.e., they cannot be used
for zippered iteration). Adding leader/follower support is a future goal.</p>
<p>This module also exposes some helper procedures used to break files into chunks.
These could be used as building blocks to implement other parallel I/O routines:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ParallelIO.findDelimChunks" title="ParallelIO.findDelimChunks"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findDelimChunks</span></code></a>: find a set of byte offsets that divide a file into
roughly equal chunks where each chunk begins with a delimiter</p></li>
<li><p><a class="reference internal" href="#ParallelIO.findItemOffsets" title="ParallelIO.findItemOffsets"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findItemOffsets</span></code></a>: get a prefix sum of the number of items in each
chunk of a file, where the chunks are defined by the <code class="docutils literal notranslate"><span class="pre">byteOffsets</span></code> array,
and each item is strictly separated by the given delimiter</p></li>
<li><p><a class="reference internal" href="#ParallelIO.findDelimChunksChecked" title="ParallelIO.findDelimChunksChecked"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findDelimChunksChecked</span></code></a>: find a set of byte offsets that divide a file
into roughly equal chunks where each chunk begins with a delimiter and each
chunk starts with a deserializable value of the given type</p></li>
</ul>
<dl class="chpl iterfunction">
<dt class="sig sig-object chpl" id="ParallelIO.readLines">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">readLines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">lineType</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">here.maxTaskPar</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">lineType</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">lineType</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">lineType</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#ParallelIO.readLines" title="Link to this definition">¶</a></dt>
<dd><p>Iterate over a file’s lines in parallel.</p>
<p>This routine is similar to <a class="reference internal" href="#ParallelIO.readLinesAsArray" title="ParallelIO.readLinesAsArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readLinesAsArray</span></code></a>, except that it yields
each line as it is read instead of returning an array of lines.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This routine will halt if the file cannot be opened or if an
I/O error occurs while reading the file. This limitation is
expected to be removed in a future release.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only serial and standalone-parallel iteration is supported. This
iterator cannot yet be used in a zippered context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>lineType</strong> – which type to return for each line — either <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>nTasks</strong> – the number of tasks used to read the file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl iterfunction">
<dt class="sig sig-object chpl" id="ParallelIO.readDelimited">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">readDelimited</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">b&quot;\n&quot;</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">here.maxTaskPar</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#ParallelIO.readDelimited" title="Link to this definition">¶</a></dt>
<dd><p>Iterate over the values of a delimited file in parallel.</p>
<p>This routine is similar to <a class="reference internal" href="#ParallelIO.readDelimitedAsArray" title="ParallelIO.readDelimitedAsArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readDelimitedAsArray</span></code></a>, except that it
yields each value as it is read instead of returning an array of values.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This routine will halt if the file cannot be opened or if an
I/O error occurs while reading the file. This limitation is
expected to be removed in a future release.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only serial and standalone-parallel iteration is supported. This
iterator cannot yet be used in a zippered context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>t</strong> – the type of value to read from the file</p></li>
<li><p><strong>delim</strong> – the delimiter to use to separate <code class="docutils literal notranslate"><span class="pre">t</span></code> values in the file</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>nTasks</strong> – the number of tasks used to read the file</p></li>
<li><p><strong>deserializerType</strong> – the type of deserializer to use when reading values</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.readLinesAsBlockArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLinesAsBlockArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">lineType</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">targetLocales:</span> <span class="pre">[?d]</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">Locales</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">lineType</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">lineType</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">lineType</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#ParallelIO.readLinesAsBlockArray" title="Link to this definition">¶</a></dt>
<dd><p>Read a file’s lines in parallel into a block-distributed array.</p>
<p>This routine is similar to <a class="reference internal" href="#ParallelIO.readDelimitedAsBlockArray" title="ParallelIO.readDelimitedAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readDelimitedAsBlockArray</span></code></a>, except that it
reads each line as a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> value.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>lineType</strong> – which type to represent a line: either <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
<li><p><strong>nTasks</strong> – the number of tasks to use per locale
(if <code class="docutils literal notranslate"><span class="pre">-1</span></code>, query <code class="docutils literal notranslate"><span class="pre">here.maxTaskPar</span></code> on each locale)</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>targetLocales</strong> – the locales to read the file on</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a block-distributed array of <code class="docutils literal notranslate"><span class="pre">lineType</span></code> values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a starting offset cannot be found
in any of the chunks</p>
</dd>
</dl>
<p>See <a class="reference internal" href="../standard/IO.html#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> for other errors that could be thrown when attempting
to open the file</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.readLinesAsArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLinesAsArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">lineType</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">here.maxTaskPar</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">lineType</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">lineType</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">lineType</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#ParallelIO.readLinesAsArray" title="Link to this definition">¶</a></dt>
<dd><p>Read a file’s lines in parallel into an array.</p>
<p>This routine is essentially the same as <a class="reference internal" href="#ParallelIO.readLinesAsBlockArray" title="ParallelIO.readLinesAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readLinesAsBlockArray</span></code></a>, except
that it only executes on the calling locale. As such, it does not accept a
<code class="docutils literal notranslate"><span class="pre">targetLocales</span></code> argument and returns a non-distributed array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>lineType</strong> – which type to represent a line: either <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
<li><p><strong>nTasks</strong> – the number of tasks to use</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a default rectangular array of <code class="docutils literal notranslate"><span class="pre">lineType</span></code> values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a starting offset cannot be found
in any of the chunks</p>
</dd>
</dl>
<p>See <a class="reference internal" href="../standard/IO.html#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> for other errors that could be thrown when attempting</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.readDelimitedAsBlockArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readDelimitedAsBlockArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">b&quot;\n&quot;</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span></em>, <em class="sig-param"><span class="pre">targetLocales:</span> <span class="pre">[?d]</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">Locales</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">d.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">(dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string)</span></em><a class="headerlink" href="#ParallelIO.readDelimitedAsBlockArray" title="Link to this definition">¶</a></dt>
<dd><p>Read a delimited file in parallel into a block-distributed array.</p>
<p>This routine assumes that the file is composed of a series of deserializable
values of type <code class="docutils literal notranslate"><span class="pre">t</span></code> (optionally with a header at the beginning of the file).
Each <code class="docutils literal notranslate"><span class="pre">t</span></code> must be separated by exactly one delimiter which can either be
provided as a <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> value.</p>
<p>This routine will use the delimiter to split the file into <code class="docutils literal notranslate"><span class="pre">d.size</span></code> chunks
of roughly equal size and read each chunk concurrently across the target locales.
If multiple tasks are used per locale, each locale will further decompose its
chunk into smaller chunks and read each of those in parallel. The chunks and
corresponding array indices are computed using <a class="reference internal" href="#ParallelIO.findDelimChunks" title="ParallelIO.findDelimChunks"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findDelimChunks</span></code></a> and
<a class="reference internal" href="#ParallelIO.findItemOffsets" title="ParallelIO.findItemOffsets"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findItemOffsets</span></code></a> respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">t</span></code> must:</p>
<ul class="simple">
<li><p>have a ‘deserialize method’</p></li>
<li><p>have a default (zero argument) initializer</p></li>
<li><p>not contain the delimiter in its serialized form (if it does,
consider using <a class="reference internal" href="#ParallelIO.readItemsAsBlockArray" title="ParallelIO.readItemsAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readItemsAsBlockArray</span></code></a> instead)</p></li>
</ul>
</div>
<p>This procedure can be used for a variety of purposes, such as reading a CSV
file. To do so, the delimiter should keep its default value of <code class="docutils literal notranslate"><span class="pre">b&quot;\n&quot;</span></code>.
The file will then be split by lines, where each line will be parsed as a
<code class="docutils literal notranslate"><span class="pre">t</span></code> value. For CSV, the commas between <code class="docutils literal notranslate"><span class="pre">t</span></code>’s fields must be parsed by
it’s <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. This can be accomplished in one of two ways:
(1) by using a custom deserialize method that parses the comma values
manually, e.g.,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">color</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">ref</span> <span class="nx">color</span><span class="p">.</span><span class="nx">deserialize</span><span class="p">(</span><span class="nx">reader</span><span class="p">,</span> <span class="kd">ref</span> <span class="nx">deserializer</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">readLiteral</span><span class="p">(</span><span class="nx">b</span><span class="s">&quot;,&quot;</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">g</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">readLiteral</span><span class="p">(</span><span class="nx">b</span><span class="s">&quot;,&quot;</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or (2) by using a deserializer that will handle commas appropriately
with <code class="docutils literal notranslate"><span class="pre">t</span></code>’s default <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>delim</strong> – the delimiter to use to separate <code class="docutils literal notranslate"><span class="pre">t</span></code> values in the file</p></li>
<li><p><strong>t</strong> – the type of value to read from the file</p></li>
<li><p><strong>nTasks</strong> – the number of tasks to use per locale
(if <code class="docutils literal notranslate"><span class="pre">-1</span></code>, query <code class="docutils literal notranslate"><span class="pre">here.maxTaskPar</span></code> on each locale)</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>deserializerType</strong> – the type of deserializer to use</p></li>
<li><p><strong>targetLocales</strong> – the locales to read the file on</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a block-distributed array of <code class="docutils literal notranslate"><span class="pre">t</span></code> values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a starting offset cannot be found
in any of the chunks</p>
</dd>
</dl>
<p>See <a class="reference internal" href="../standard/IO.html#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> for other errors that could be thrown when attempting
to open the file</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.readDelimitedAsArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readDelimitedAsArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">b&quot;\n&quot;</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">here.maxTaskPar</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string</span></em><a class="headerlink" href="#ParallelIO.readDelimitedAsArray" title="Link to this definition">¶</a></dt>
<dd><p>Read a delimited file in parallel into an array.</p>
<p>This procedure is essentially the same as <a class="reference internal" href="#ParallelIO.readDelimitedAsBlockArray" title="ParallelIO.readDelimitedAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readDelimitedAsBlockArray</span></code></a>,
except that it only executes on the calling locale. As such, it does not
accept a <code class="docutils literal notranslate"><span class="pre">targetLocales</span></code> argument and returns a non-distributed array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>delim</strong> – the delimiter to use to separate <code class="docutils literal notranslate"><span class="pre">t</span></code> values in the file</p></li>
<li><p><strong>t</strong> – the type of value to read from the file</p></li>
<li><p><strong>nTasks</strong> – the number of tasks to use</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>deserializerType</strong> – the type of deserializer to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a default rectangular array of <code class="docutils literal notranslate"><span class="pre">t</span></code> values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a starting offset cannot be found in
any of the chunks</p>
</dd>
</dl>
<p>See <a class="reference internal" href="../standard/IO.html#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> for other errors that could be thrown when attempting
to open the file</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.readItemsAsBlockArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readItemsAsBlockArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">b&quot;\n&quot;</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span></em>, <em class="sig-param"><span class="pre">targetLocales:</span> <span class="pre">[?d]</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">Locales</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">d.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">(dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string)</span></em><a class="headerlink" href="#ParallelIO.readItemsAsBlockArray" title="Link to this definition">¶</a></dt>
<dd><p>Read items from a file in parallel into a block-distributed array.</p>
<p>This routine assumes that the file is composed of a series of deserializable
values of type <code class="docutils literal notranslate"><span class="pre">t</span></code> (optionally with a header at the beginning of the file).
Each <code class="docutils literal notranslate"><span class="pre">t</span></code> must be separated by a delimiter which can either be provided as
a <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> value. Unlike <a class="reference internal" href="#ParallelIO.readDelimitedAsBlockArray" title="ParallelIO.readDelimitedAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readDelimitedAsBlockArray</span></code></a>
the delimiter can also be found in the serialized form of <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>This routine uses the following heuristic to split the file into chunks, which
may not be accurate in all cases:</p>
<p>A given byte offset is a valid offset for a task to start deserializing
values of type <code class="docutils literal notranslate"><span class="pre">t</span></code> if:</p>
<ul class="simple">
<li><p>it is preceded by, or begins with the delimiter</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">t</span></code> can be deserialized at that offset (i.e., calling <code class="docutils literal notranslate"><span class="pre">t.deserialize</span></code>
on the bytes starting at that offset does not throw an error)</p></li>
</ul>
<p>The heuristic, implemented in <a class="reference internal" href="#ParallelIO.findDelimChunksChecked" title="ParallelIO.findDelimChunksChecked"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findDelimChunksChecked</span></code></a>, will be used to
split the file in <code class="docutils literal notranslate"><span class="pre">d.size</span></code> chunks with a roughly equal number of items per
chunk. If multiple tasks per locale are used, each locale will further decompose
its chunk into smaller chunks and read each of those in parallel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">t</span></code> must:</p>
<ul class="simple">
<li><p>have a ‘deserialize’ method that throws when a valid <code class="docutils literal notranslate"><span class="pre">t</span></code> cannot be read</p></li>
<li><p>have a default (zero argument) initializer</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>delim</strong> – the delimiter used to guide file chunking</p></li>
<li><p><strong>t</strong> – the type of value to read from the file</p></li>
<li><p><strong>nTasks</strong> – the number of tasks to use per locale
(if <code class="docutils literal notranslate"><span class="pre">-1</span></code>, query <code class="docutils literal notranslate"><span class="pre">here.maxTaskPar</span></code> on each locale)</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>deserializerType</strong> – the type of deserializer to use</p></li>
<li><p><strong>targetLocales</strong> – the locales to read the file on</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a block-distributed array of <code class="docutils literal notranslate"><span class="pre">t</span></code> values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a valid byte offset cannot be found
in any of the chunks</p>
</dd>
</dl>
<p>See <a class="reference internal" href="../standard/IO.html#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> for other errors that could be thrown when attempting
to open the file</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.readItemsAsArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readItemsAsArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filePath:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">b&quot;\n&quot;</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">nTasks:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">here.maxTaskPar</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string</span></em><a class="headerlink" href="#ParallelIO.readItemsAsArray" title="Link to this definition">¶</a></dt>
<dd><p>Read items from a file in parallel into an array.</p>
<p>This procedure is essentially the same as <a class="reference internal" href="#ParallelIO.readItemsAsBlockArray" title="ParallelIO.readItemsAsBlockArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readItemsAsBlockArray</span></code></a>,
except that it only executes on the calling locale. As such, it does not
accept a <code class="docutils literal notranslate"><span class="pre">targetLocales</span></code> argument and returns a non-distributed array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filePath</strong> – a path to the file to read from</p></li>
<li><p><strong>delim</strong> – the delimiter used to guide file chunking</p></li>
<li><p><strong>t</strong> – the type of value to read from the file</p></li>
<li><p><strong>nTasks</strong> – the number of tasks to use</p></li>
<li><p><strong>header</strong> – how to handle the file header (see <a class="reference internal" href="#ParallelIO.headerPolicy" title="ParallelIO.headerPolicy"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">headerPolicy</span></code></a>)</p></li>
<li><p><strong>deserializerType</strong> – the type of deserializer to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a default rectangular array of <code class="docutils literal notranslate"><span class="pre">t</span></code> values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a valid byte offset cannot be found
in any of the chunks</p>
</dd>
</dl>
<p>See <a class="reference internal" href="../standard/IO.html#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> for other errors that could be thrown when attempting
to open the file</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.findDelimChunks">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">findDelimChunks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">f:</span> <span class="pre">file</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span></em>, <em class="sig-param"><span class="pre">n:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">bounds:</span> <span class="pre">range</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string</span></em><a class="headerlink" href="#ParallelIO.findDelimChunks" title="Link to this definition">¶</a></dt>
<dd><p>Get an array of <code class="docutils literal notranslate"><span class="pre">n+1</span></code> byte offsets that divide the file <code class="docutils literal notranslate"><span class="pre">f</span></code> into <code class="docutils literal notranslate"><span class="pre">n</span></code>
roughly equally sized chunks, where each byte offset lines up with a
delimiter.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – the file to search</p></li>
<li><p><strong>delim</strong> – the delimiter to use to separate the file into chunks</p></li>
<li><p><strong>n</strong> – the number of chunks to find</p></li>
<li><p><strong>bounds</strong> – a range of byte offsets to break into chunks</p></li>
<li><p><strong>header</strong> – a header policy to use when searching for the first byte offset</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a length <code class="docutils literal notranslate"><span class="pre">n+1</span></code> array of byte offsets (the last offset is
<code class="docutils literal notranslate"><span class="pre">bounds.high</span></code>)</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a valid byte offset cannot be found
in any of the chunks</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.findDelimChunksChecked">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">findDelimChunksChecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">f:</span> <span class="pre">file</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span></em>, <em class="sig-param"><span class="pre">n:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em>, <em class="sig-param"><span class="pre">bounds:</span> <span class="pre">range</span></em>, <em class="sig-param"><span class="pre">header</span> <span class="pre">=</span> <span class="pre">headerPolicy.noHeader</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[]</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string</span></em><a class="headerlink" href="#ParallelIO.findDelimChunksChecked" title="Link to this definition">¶</a></dt>
<dd><p>Get an array of <code class="docutils literal notranslate"><span class="pre">n+1</span></code> byte offsets that divide the file <code class="docutils literal notranslate"><span class="pre">f</span></code> into <code class="docutils literal notranslate"><span class="pre">n</span></code>
roughly equally sized chunks, where each byte offset lines up with a
delimiter and a <code class="docutils literal notranslate"><span class="pre">t</span></code> can be deserialized at that offset.</p>
<p>This procedure is similar to <a class="reference internal" href="#ParallelIO.findDelimChunks" title="ParallelIO.findDelimChunks"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">findDelimChunks</span></code></a>, except that when it
finds a delimiter, it confirms that a <code class="docutils literal notranslate"><span class="pre">t</span></code> can be deserialized at that
offset before recording it. This way, the serialized values can also
contain the delimiter.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – the file to search</p></li>
<li><p><strong>delim</strong> – the delimiter to use to separate the file into chunks</p></li>
<li><p><strong>n</strong> – the number of chunks to find</p></li>
<li><p><strong>t</strong> – the type of value to read from the file</p></li>
<li><p><strong>bounds</strong> – a range of byte offsets to break into chunks</p></li>
<li><p><strong>header</strong> – a header policy to use when searching for the first byte offset</p></li>
<li><p><strong>deserializerType</strong> – the type of deserializer to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a length <code class="docutils literal notranslate"><span class="pre">n+1</span></code> array of byte offsets (the last offset is
<code class="docutils literal notranslate"><span class="pre">bounds.high</span></code>)</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ParallelIO.OffsetNotFoundError" title="ParallelIO.OffsetNotFoundError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OffsetNotFoundError</span></code></a> if a valid byte offset cannot be found
in any of the chunks</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ParallelIO.findItemOffsets">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">findItemOffsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">f:</span> <span class="pre">file</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">delim:</span> <span class="pre">?dt</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">byteOffsets:</span> <span class="pre">[?d]</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">[d]</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">bytes</span> <span class="pre">||</span> <span class="pre">dt</span> <span class="pre">==</span> <span class="pre">string</span></em><a class="headerlink" href="#ParallelIO.findItemOffsets" title="Link to this definition">¶</a></dt>
<dd><p>Get a prefix sum of the number of items in each chunk of the file <code class="docutils literal notranslate"><span class="pre">f</span></code>,
where the chunks are defined by the <code class="docutils literal notranslate"><span class="pre">byteOffsets</span></code> array, and each item
is separated by the given delimiter.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – the file to search</p></li>
<li><p><strong>delim</strong> – the delimiter used to separate items in the file</p></li>
<li><p><strong>byteOffsets</strong> – an array of byte offsets that divide the file into chunks</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an array of length <code class="docutils literal notranslate"><span class="pre">byteOffsets.size</span></code> containing the number of
items in the file before the start of each chunk. The last entry
contains the total number of items in the file.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl class">
<dt class="sig sig-object chpl" id="ParallelIO.OffsetNotFoundError">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">OffsetNotFoundError</span></span><em class="property"> <span class="pre">:</span> <span class="pre">Error</span></em><a class="headerlink" href="#ParallelIO.OffsetNotFoundError" title="Link to this definition">¶</a></dt>
<dd><p>An error thrown when a starting offset cannot be found in a chunk of a file.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="ParallelIO.OffsetNotFoundError.init">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ParallelIO.OffsetNotFoundError.init" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msg:</span> <span class="pre">string</span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="ParallelIO.headerPolicy">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">headerPolicy</span></span><a class="headerlink" href="#ParallelIO.headerPolicy" title="Link to this definition">¶</a></dt>
<dd><p>A type describing how to handle the file header when reading a file
in parallel.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ParallelIO.headerPolicy.skipLines">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">headerPolicy.</span></span><span class="sig-name descname"><span class="pre">skipLines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">n:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ParallelIO.headerPolicy.skipLines" title="Link to this definition">¶</a></dt>
<dd><p>Skip the first <code class="docutils literal notranslate"><span class="pre">n</span></code> lines of the file</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ParallelIO.headerPolicy.skipBytes">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">headerPolicy.</span></span><span class="sig-name descname"><span class="pre">skipBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">n:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ParallelIO.headerPolicy.skipBytes" title="Link to this definition">¶</a></dt>
<dd><p>Skip the first <code class="docutils literal notranslate"><span class="pre">n</span></code> bytes of the file</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ParallelIO.headerPolicy.findStart">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">headerPolicy.</span></span><span class="sig-name descname"><span class="pre">findStart</span></span><a class="headerlink" href="#ParallelIO.headerPolicy.findStart" title="Link to this definition">¶</a></dt>
<dd><p>Find the first byte offset in the file that can be used to start reading</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ParallelIO.headerPolicy.noHeader">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-prename descclassname"><span class="pre">headerPolicy.</span></span><span class="sig-name descname"><span class="pre">noHeader</span></span><a class="headerlink" href="#ParallelIO.headerPolicy.noHeader" title="Link to this definition">¶</a></dt>
<dd><p>Don’t expect a header in the file</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ObjectSerialization.html" class="btn btn-neutral float-left" title="ObjectSerialization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="RecordParser.html" class="btn btn-neutral float-right" title="RecordParser" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>