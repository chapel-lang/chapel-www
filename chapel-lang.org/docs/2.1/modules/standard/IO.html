<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IO &mdash; Chapel Documentation 2.1</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=20623aea"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FormattedIO" href="IO/FormattedIO.html" />
    <link rel="prev" title="Types" href="Types.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.1
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.1";
$pagename = "modules/standard/IO";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#automatic-modules">Automatic Modules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">A subset of the IO symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#automatically-available-symbols">Automatically Available Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-overview">I/O Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-rationale">Design Rationale</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-serialize-and-deserialize-methods">The ‘serialize’ and ‘deserialize’ Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-filereader-and-filewriter-creation">Functions for fileReader and fileWriter Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races">Synchronization of fileReader and fileWriter Data and Avoiding Data Races</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performing-i-o-with-filereaders-and-filewriters">Performing I/O with FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-closing-filereaders-and-filewriters">Functions for Closing FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-stdin-filereader-and-stdout-and-stderr-filewriters">The <code class="docutils literal notranslate"><span class="pre">stdin</span></code> fileReader, and <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> fileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unicode-support">Unicode Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-transactions">I/O Transactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specifying-the-region-of-a-filereader-or-filewriter">Specifying the region of a fileReader or fileWriter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#locking-behavior-of-filereaders-and-filewriters">Locking Behavior of FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ensuring-successful-i-o">Ensuring Successful I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correspondence-with-c-i-o">Correspondence with C I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#automatically-included-io-functions">Automatically Included IO Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#io-functions-and-types">IO Functions and Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Math.html">A subset of the Math symbols</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#data-structures">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#files-io">Files/IO</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="FileSystem.html">FileSystem</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">IO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#automatically-available-symbols">Automatically Available Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-overview">I/O Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-rationale">Design Rationale</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-serialize-and-deserialize-methods">The ‘serialize’ and ‘deserialize’ Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-filereader-and-filewriter-creation">Functions for fileReader and fileWriter Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races">Synchronization of fileReader and fileWriter Data and Avoiding Data Races</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performing-i-o-with-filereaders-and-filewriters">Performing I/O with FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-closing-filereaders-and-filewriters">Functions for Closing FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-stdin-filereader-and-stdout-and-stderr-filewriters">The <code class="docutils literal notranslate"><span class="pre">stdin</span></code> fileReader, and <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> fileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unicode-support">Unicode Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-transactions">I/O Transactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specifying-the-region-of-a-filereader-or-filewriter">Specifying the region of a fileReader or fileWriter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#locking-behavior-of-filereaders-and-filewriters">Locking Behavior of FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ensuring-successful-i-o">Ensuring Successful I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correspondence-with-c-i-o">Correspondence with C I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#automatically-included-io-functions">Automatically Included IO Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#io-functions-and-types">IO Functions and Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="JSON.html">JSON</a></li>
<li class="toctree-l3"><a class="reference internal" href="Path.html">Path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#language-support">Language Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#math-numerical">Math/Numerical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#parallelism-distributed-computing">Parallelism/Distributed Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#system-interoperability">System/Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#utilities">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../standard.html">Standard Modules</a></li>
      <li class="breadcrumb-item active">IO</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/standard/IO.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="io">
<span id="module-IO"></span><h1>IO<a class="headerlink" href="#io" title="Link to this heading">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Submodules</strong></p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
</ul>
</div>
<p>Support for a variety of kinds of input and output.</p>
<p>Input/output (I/O) facilities in Chapel include the types <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>,
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>; the constants <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stdin</span></code></a>,
<a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stderr</span></code></a>; the functions <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a>,
<a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a>, <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a>, <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a>,
<a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a>, <a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.write</span></code></a>, and many others.</p>
<section id="automatically-available-symbols">
<h2>Automatically Available Symbols<a class="headerlink" href="#automatically-available-symbols" title="Link to this heading">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These symbols can also be accessed using <code class="docutils literal notranslate"><span class="pre">IO.</span></code> as their qualified access
prefix.</p>
</div>
<p>All Chapel programs include <a class="reference internal" href="#IO.write" title="IO.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">write</span></code></a>, <a class="reference internal" href="#IO.writeln" title="IO.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writeln</span></code></a> and
<a class="reference internal" href="#IO.writef" title="IO.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writef</span></code></a> by default. This allows for a simple implementation of a
Hello World program:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello, World!&quot;</span><span class="p">);</span>
<span class="c1">// outputs</span>
<span class="c1">// Hello, World!</span>
</pre></div>
</div>
</section>
<section id="i-o-overview">
<span id="about-io-overview"></span><h2>I/O Overview<a class="headerlink" href="#i-o-overview" title="Link to this heading">¶</a></h2>
<p>A <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> in Chapel identifies a file in the underlying operating system.
Reads to a file are done via one or more fileReaders associated with the file
and writes to a file are done via one or more fileWriters.  Each
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> uses a buffer to provide sequential
read or write access to its file.</p>
<p>For example, the following program opens a file and writes an integer to it:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="c1">// open the file &quot;test-file.txt&quot; for writing, creating it if</span>
  <span class="c1">// it does not exist yet.</span>
  <span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">cw</span><span class="p">);</span>

  <span class="c1">// create a fileWriter starting at the beginning of the file</span>
  <span class="c1">// (this fileWriter will not be used in parallel, so does not need to use</span>
  <span class="c1">// locking)</span>
  <span class="kd">var</span> <span class="nx">myFileWriter</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">writer</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>

  <span class="c1">// This function will write the human-readable text version of x;</span>
  <span class="c1">// binary I/O is also possible.</span>
  <span class="nx">myFileWriter</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

  <span class="c1">// Now test-file.txt contains:</span>
  <span class="c1">// 17</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Error</span> <span class="p">{</span>
  <span class="c1">// Generally speaking, the I/O functions throw errors.  Handling these</span>
  <span class="c1">// errors is application-dependent and is left out of this example for</span>
  <span class="c1">// brevity.  Please see the documentation for individual functions for more</span>
  <span class="c1">// details about errors that they can throw.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, the following program can be used to read the integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="c1">// open the file &quot;test-file.txt&quot; for reading only</span>
  <span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>

  <span class="c1">// create a fileReader starting at the beginning of the file</span>
  <span class="c1">// (this fileReader will not be used in parallel, so does not need to use</span>
  <span class="c1">// locking)</span>
  <span class="kd">var</span> <span class="nx">myFileReader</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">reader</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

  <span class="c1">// Now read a textual integer. Note that the</span>
  <span class="c1">// fileReader.read function returns a bool to indicate</span>
  <span class="c1">// if it read something or if the end of the file</span>
  <span class="c1">// was reached before something could be read.</span>
  <span class="kd">var</span> <span class="nx">readSomething</span> <span class="o">=</span> <span class="nx">myFileReader</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Read integer &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="c1">// prints out:</span>
  <span class="c1">// Read integer 17</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Error</span> <span class="p">{</span>
  <span class="c1">// Generally speaking, the I/O functions throw errors.  Handling these</span>
  <span class="c1">// errors is application-dependent and is left out of this example for</span>
  <span class="c1">// brevity.  Please see the documentation for individual functions for more</span>
  <span class="c1">// details about errors that they can throw.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#IO.read" title="IO.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">read</span></code></a> functions allow one to read values into variables as
the following example demonstrates. It shows three ways to read values into
a pair of variables <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="cm">/* reading into variable expressions, returning</span>
<span class="cm">   true if the values were read, false on EOF */</span>
<span class="kd">var</span> <span class="nx">ok</span><span class="p">:</span><span class="kt">bool</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>

<span class="cm">/* reading via a single type argument */</span>
<span class="nx">x</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="nx">y</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="kt">real</span><span class="p">);</span>

<span class="cm">/* reading via multiple type arguments */</span>
<span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">real</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="design-rationale">
<h2>Design Rationale<a class="headerlink" href="#design-rationale" title="Link to this heading">¶</a></h2>
<p>Since fileReaders and fileWriters operate independently, concurrent I/O to the
same open file is possible without contending for locks.  Furthermore, since the
fileReader or fileWriter (and not the file) stores the current file offset, it
is straightforward to create programs that access the same open file in
parallel. Note that such parallel access is not possible in C when multiple
threads are using the same <code class="docutils literal notranslate"><span class="pre">FILE*</span></code> to write to different regions of a file
because of the race condition between <code class="docutils literal notranslate"><span class="pre">fseek</span></code> and <code class="docutils literal notranslate"><span class="pre">fwrite</span></code>. Because of these
issues, Chapel programmers wishing to perform I/O will need to know how to open
files as well as create fileReaders and fileWriters.</p>
</section>
<section id="the-serialize-and-deserialize-methods">
<span id="serialize-deserialize"></span><h2>The ‘serialize’ and ‘deserialize’ Methods<a class="headerlink" href="#the-serialize-and-deserialize-methods" title="Link to this heading">¶</a></h2>
<p>A Chapel program can implement <code class="docutils literal notranslate"><span class="pre">serialize</span></code> and <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> methods
on a user-defined data type to define how that type is deserialized from a
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or serialized to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>. The method signatures for
non-class types are:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">T.serialize</span><span class="p">(</span><span class="nx">writer</span><span class="p">:</span> <span class="nx">fileWriter</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="p">?),</span>
                 <span class="kd">ref</span> <span class="nx">serializer</span><span class="p">:</span> <span class="p">?</span><span class="nx">st</span><span class="p">)</span> <span class="k">throws</span>

<span class="k">proc</span> <span class="nf">ref</span> <span class="nx">T</span><span class="p">.</span><span class="nx">deserialize</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">fileReader</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="p">?),</span>
                       <span class="kd">ref</span> <span class="nx">deserializer</span><span class="p">:</span> <span class="p">?</span><span class="nx">dt</span><span class="p">)</span> <span class="k">throws</span>
</pre></div>
</div>
<p>The signatures for classes are slightly different:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">proc</span> <span class="nf">T.serialize</span><span class="p">(</span><span class="nx">writer</span><span class="p">:</span> <span class="nx">fileWriter</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="p">?),</span>
                          <span class="kd">ref</span> <span class="nx">serializer</span><span class="p">:</span> <span class="p">?</span><span class="nx">st</span><span class="p">)</span> <span class="k">throws</span>

<span class="k">override</span> <span class="k">proc</span> <span class="nf">T.deserialize</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">fileReader</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="p">?),</span>
                            <span class="kd">ref</span> <span class="nx">deserializer</span><span class="p">:</span> <span class="p">?</span><span class="nx">dt</span><span class="p">)</span> <span class="k">throws</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">serializer</span></code> and <code class="docutils literal notranslate"><span class="pre">deserializer</span></code> arguments must satisfy the
<a class="reference internal" href="../../technotes/ioSerializers.html#io-serializer-api"><span class="std std-ref">Serializer API</span></a> and the
<a class="reference internal" href="../../technotes/ioSerializers.html#io-deserializer-api"><span class="std std-ref">Deserializer API</span></a>, respectively.</p>
<section id="basic-usage">
<h3>Basic Usage<a class="headerlink" href="#basic-usage" title="Link to this heading">¶</a></h3>
<p>Implementations of <code class="docutils literal notranslate"><span class="pre">serialize</span></code> and <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> methods are not
necessarily required to utilize their <code class="docutils literal notranslate"><span class="pre">serializer</span></code> and <code class="docutils literal notranslate"><span class="pre">deserializer</span></code>
arguments, and can instead trivially read and write from their <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> arguments. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// A record &#39;R&#39; that serializes as an integer</span>
<span class="k">record</span> <span class="nc">R</span> <span class="p">:</span> <span class="nx">writeSerializable</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">serialize</span><span class="p">(</span><span class="nx">writer</span><span class="p">:</span> <span class="nx">fileWriter</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="p">?),</span>
                 <span class="kd">ref</span> <span class="nx">serializer</span><span class="p">:</span> <span class="p">?</span><span class="nx">st</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">writer</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span> <span class="c1">// prints &#39;5&#39;</span>
</pre></div>
</div>
</section>
<section id="using-serializers-and-deserializers">
<h3>Using Serializers and Deserializers<a class="headerlink" href="#using-serializers-and-deserializers" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../../technotes/ioSerializers.html#io-serializer-user-api"><span class="std std-ref">Serializers</span></a> and
<a class="reference internal" href="../../technotes/ioSerializers.html#io-deserializer-user-api"><span class="std std-ref">Deserializers</span></a> support a variety of methods
to support serializing various kinds of types. These methods can be used
to serialize or deserialize a type in a format-agnostic way. For example,
consider a simple ‘point’ type:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">point</span> <span class="p">:</span> <span class="nx">writeSerializable</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The default implementation of <code class="docutils literal notranslate"><span class="pre">point</span></code>’s <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method will naturally
serialize <code class="docutils literal notranslate"><span class="pre">point</span></code> as a record. In the default serialization format, this
would look something like <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">=</span> <span class="pre">2,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">4)</span></code>. In the JSON serialization format,
the output would instead be <code class="docutils literal notranslate"><span class="pre">{&quot;x&quot;:4,</span> <span class="pre">&quot;y&quot;:2}</span></code>. While this may be perfectly
acceptable, what if the author of <code class="docutils literal notranslate"><span class="pre">point</span></code> wished to always serialize a
<code class="docutils literal notranslate"><span class="pre">point</span></code> as a tuple?</p>
<p>Serializers and Deserializers have “start” methods that begin serialization
or deserialization of a type, and then return a helper object that implements
methods to continue the process. To begin serializing <code class="docutils literal notranslate"><span class="pre">point</span></code> as a tuple,
a user may invoke the <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> method on the <code class="docutils literal notranslate"><span class="pre">serializer</span></code>, passing in
the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to use when writing serialized output and the number of
elements in the tuple. The returned value from <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> is a helper
object that implements <code class="docutils literal notranslate"><span class="pre">writeElement</span></code> and <code class="docutils literal notranslate"><span class="pre">endTuple</span></code> methods:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">point.serialize</span><span class="p">(</span><span class="nx">writer</span><span class="p">:</span> <span class="nx">fileWriter</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="p">?),</span>
                     <span class="kd">ref</span> <span class="nx">serializer</span><span class="p">:</span> <span class="p">?</span><span class="nx">st</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Start serializing and get the helper object</span>
  <span class="c1">// &#39;2&#39; represents the number of tuple elements to be serialized</span>
  <span class="kd">var</span> <span class="nx">ser</span> <span class="o">=</span> <span class="nx">serializer</span><span class="p">.</span><span class="nx">startTuple</span><span class="p">(</span><span class="nx">writer</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="nx">ser</span><span class="p">.</span><span class="nx">writeElement</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// serialize &#39;x&#39; as a tuple element</span>
  <span class="nx">ser</span><span class="p">.</span><span class="nx">writeElement</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// serialize &#39;y&#39; as a tuple element</span>

  <span class="c1">// End serialization of the tuple</span>
  <span class="nx">ser</span><span class="p">.</span><span class="nx">endTuple</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, when using different Serializers like the <a class="reference internal" href="#IO.defaultSerializer" title="IO.defaultSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">defaultSerializer</span></code></a> or
the <a class="reference internal" href="JSON.html#JSON.jsonSerializer" title="JSON.jsonSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">jsonSerializer</span></code></a>, the <code class="docutils literal notranslate"><span class="pre">point</span></code> type can be serialized without
introducing special cases for each format:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// Prints &#39;(4, 2)&#39; in the default serialization format</span>
<span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="c1">// Prints &#39;[4, 2]&#39; in the JSON serialization format</span>
<span class="kd">var</span> <span class="nx">jsonWriter</span> <span class="o">=</span> <span class="nx">stdout</span><span class="p">.</span><span class="nx">withSerializer</span><span class="p">(</span><span class="nx">jsonSerializer</span><span class="p">);</span>
<span class="nx">jsonWriter</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</pre></div>
</div>
<p>A similar API exists for deserialization that would allow for deserializing a
<code class="docutils literal notranslate"><span class="pre">point</span></code> as a tuple. Please refer to the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">IO Serializers technote</span></a> for more detail on the various
kinds of types that can be serialized and deserialized. As of Chapel 1.32 the
supported type-kinds are Classes, Records, Tuples, Arrays, Lists, and Maps.</p>
</section>
<section id="compiler-generated-default-methods">
<span id="about-io-generated-default-methods"></span><h3>Compiler-Generated Default Methods<a class="headerlink" href="#compiler-generated-default-methods" title="Link to this heading">¶</a></h3>
<p>Default <code class="docutils literal notranslate"><span class="pre">serialize</span></code> methods are created for all types for which a
user-defined <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method is not provided.</p>
<p>Classes will be serialized as a ‘Class’ type-kind using the Serializer API,
and will invoke their parent <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method before serializing their
own fields.</p>
<p>Records will be serialized as a ‘Record’ type-kind using the Serializer API,
and will serialize each field in the record.</p>
<p>Default <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> methods are created for all types for which a
user-defined <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method is not provided.  The default
<code class="docutils literal notranslate"><span class="pre">deserialize</span></code> methods will mirror the relevant API calls in the default
<code class="docutils literal notranslate"><span class="pre">serialize</span></code> methods.</p>
<p>For more information on the default serialization format, please refer to the
<a class="reference internal" href="#IO.defaultSerializer" title="IO.defaultSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">defaultSerializer</span></code></a> and <a class="reference internal" href="#IO.defaultDeserializer" title="IO.defaultDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">defaultDeserializer</span></code></a> types.</p>
<p>If the compiler sees a user-defined implementation of the <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method,
the <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method, or the deserializing initializer, then the compiler
may choose to not automatically generate any of the other unimplemented
methods. This is out of concern that the user has intentionally deviated from
the default implementation of serialization and deserialization.</p>
<p>Types with compiler-generated versions of these methods do not need to
explicitly indicate that they satisfy any of the relevant serialization
interfaces (such as <code class="docutils literal notranslate"><span class="pre">writeSerializable</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that it is not currently possible to read and write circular
data structures with these mechanisms.</p>
</div>
</section>
</section>
<section id="files">
<span id="about-io-files"></span><h2>Files<a class="headerlink" href="#files" title="Link to this heading">¶</a></h2>
<p>There are several functions that open a file and return a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>
including <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a>, <a class="reference internal" href="#IO.openTempFile" title="IO.openTempFile"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openTempFile</span></code></a>, <a class="reference internal" href="#IO.openMemFile" title="IO.openMemFile"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openMemFile</span></code></a>, the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> initializer that takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> argument, and the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> initializer that takes a <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a> argument.</p>
<p>Once a file is open, it is necessary to create associated fileReader(s) and/or
fileWriter(s) - see <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> and <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> - to read from
and/or write to the file.</p>
<p>Use the <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> function to explicitly synchronize the file to
ensure that file data is committed to the file’s underlying device for
persistence.</p>
<p>Files, fileReaders, and fileWriters will be kept alive while there are variables
referring to them and closed when all variables referring to them have gone out
of scope.  However, each can be closed explicitly with <code class="docutils literal notranslate"><span class="pre">close</span></code> methods.  Note
that <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a> will not work if the file has open fileReaders and/or
fileWriters.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../../language/spec/strings.html#string-nonunicode"><span class="std std-ref">Escaped strings</span></a> can be used for paths on systems
where UTF-8 file names are not enforced.</p>
</div>
</div></blockquote>
</section>
<section id="functions-for-filereader-and-filewriter-creation">
<span id="about-io-filereader-filewriter-creation"></span><h2>Functions for fileReader and fileWriter Creation<a class="headerlink" href="#functions-for-filereader-and-filewriter-creation" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> creates a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> for writing to a file, and
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> creates a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> for reading from a file.</p>
<p>The helper functions <a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a> and <a class="reference internal" href="#IO.openWriter" title="IO.openWriter"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openWriter</span></code></a> can also be used
to open a file and create a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>/<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to it in a
single step.</p>
</section>
<section id="synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races">
<span id="about-io-filereader-filewriter-synchronization"></span><h2>Synchronization of fileReader and fileWriter Data and Avoiding Data Races<a class="headerlink" href="#synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races" title="Link to this heading">¶</a></h2>
<p>FileReaders and fileWriters (and files) contain locks in order to keep their
operation safe for multiple tasks. When creating a fileReader or fileWriter, it
is possible to disable the lock (for performance reasons) by passing
<code class="docutils literal notranslate"><span class="pre">locking=false</span></code> to e.g.  file.writer(), or by using
<a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a>/<a class="reference internal" href="#IO.openWriter" title="IO.openWriter"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openWriter</span></code></a>.  Some <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
methods should only be called on locked fileReaders or fileWriters.  With these
methods, it is possible to perform I/O “transactions” (see
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a>, e.g.). To use these methods, e.g., first lock the
fileWriter with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a>, call the methods you need, then unlock
the fileWriter with <a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a>. Note that in the future, we may
move to alternative ways of calling these functions that guarantee that they are
not called on a fileReader or fileWriter without the appropriate locking.</p>
<p>Besides data races that can occur if locking is not used in fileWriters when it
should be, it is also possible for there to be data races on file data that is
buffered simultaneously in multiple fileReader/fileWriter combinations.  The
main way to avoid such data races is the <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a>
synchronization operation.  <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> will make all writes to the
fileWriter, if any, available to concurrent viewers of its associated file, such
as other fileWriters, fileReaders or other applications accessing this file
concurrently. See the note below for more details on the situation in which this
kind of data race can occur.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since fileWriters can buffer data until <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> is called, it
is possible to write programs that have undefined behavior because of race
conditions on fileWriter buffers. In particular, the problem comes up for
programs that make:</p>
<blockquote>
<div><ul class="simple">
<li><p>concurrent operations on multiple fileWriters and/or fileReaders that
operate on overlapping regions of a file</p></li>
<li><p>where at least one fileWriter is used along with other fileWriters or
fileReaders</p></li>
<li><p>and where data could be stored in more than one of the overlapping
fileWriter’s buffers at the same time (i.e., write and read ordering are
not enforced through <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> and other means such as
sync variables).</p></li>
</ul>
</div></blockquote>
<p>Note that it is possible in some cases to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> that does
not allow multiple fileWriters and/or fileReaders at different
offsets. FileWriters created on such files will not change the file’s offset
based on a <code class="docutils literal notranslate"><span class="pre">region=</span></code> offset argument. Instead, each read or write operation
will use the file descriptor’s current offset. Therefore, only one
fileWriter or fileReader should be created for files created in the following
situations:</p>
<blockquote>
<div><ul class="simple">
<li><p>with the file initializer that takes a <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a> argument</p></li>
<li><p>with the file initializer that takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> argument, where the
<code class="docutils literal notranslate"><span class="pre">int</span></code> represents a non-seekable system file descriptor</p></li>
</ul>
</div></blockquote>
</div>
</section>
<section id="performing-i-o-with-filereaders-and-filewriters">
<h2>Performing I/O with FileReaders and FileWriters<a class="headerlink" href="#performing-i-o-with-filereaders-and-filewriters" title="Link to this heading">¶</a></h2>
<p>FileReaders have a variety of read methods and fileWriters have a variety of
write methods. The most common variety of these are generic methods that can
read or write values of any type. For non-primitive types, the relevant
<code class="docutils literal notranslate"><span class="pre">deserialize</span></code> or <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method is used to control the I/O formatting;
see <a class="reference internal" href="#serialize-deserialize"><span class="std std-ref">The ‘serialize’ and ‘deserialize’ Methods</span></a>. These functions generally take any number of
arguments and <cite>throw</cite> if there was an error:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.write</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeln" title="IO.fileWriter.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeln</span></code></a></p></li>
<li><p><a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileWriter.writef" title="FormattedIO.fileWriter.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileWriter.writef</span></code></a> (see also <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a>)</p></li>
<li><p><a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readln" title="IO.fileReader.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readln</span></code></a></p></li>
<li><p><a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileReader.readf" title="FormattedIO.fileReader.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileReader.readf</span></code></a> (see also <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a>)</p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> type also has the following methods for executing write
operations with more specific types. These methods can provide finer control
over the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s behavior as well as some performance advantages over
the generic <cite>write</cite> methods:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileWriter.writeBits" title="IO.fileWriter.writeBits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeBits</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeCodepoint" title="IO.fileWriter.writeCodepoint"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeCodepoint</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeByte" title="IO.fileWriter.writeByte"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeByte</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeString" title="IO.fileWriter.writeString"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeString</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeBytes" title="IO.fileWriter.writeBytes"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeBytes</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeBinary" title="IO.fileWriter.writeBinary"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeBinary</span></code></a></p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> type has similar methods for executing read operations with
more specific types, where the goal of these methods is also to provide finer
control over the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s behavior and the potential for performance
advantages:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileReader.readBits" title="IO.fileReader.readBits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBits</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readCodepoint" title="IO.fileReader.readCodepoint"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readCodepoint</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readByte" title="IO.fileReader.readByte"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readByte</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readString" title="IO.fileReader.readString"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readString</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readBytes" title="IO.fileReader.readBytes"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBytes</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readBinary" title="IO.fileReader.readBinary"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBinary</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Additionally, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> has the following methods which read arbitrary
amounts of data from the file until some stop condition is met. These methods
generally have multiple overloads for reading into values of different types:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.lines" title="IO.fileReader.lines"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lines</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readThrough</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readTo" title="IO.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readTo</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readAll" title="IO.fileReader.readAll"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readAll</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Sometimes it’s important to flush the buffer in a fileWriter - to do that, use
the <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush()</span></code></a> method. Flushing the buffer will make all writes
available to other applications or other views of the file (e.g., it will call
the OS call <code class="docutils literal notranslate"><span class="pre">pwrite()</span></code>).  It is also possible to close a fileWriter, which
will implicitly flush it and release any buffer memory used by the fileWriter.
Note that if you need to ensure that data from a fileWriter is on disk, you’ll
have to call <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> or <a class="reference internal" href="#IO.fileWriter.close" title="IO.fileWriter.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.close</span></code></a> and then
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> on the related file.</p>
</section>
<section id="functions-for-closing-filereaders-and-filewriters">
<span id="about-io-closing-filereader-filewriter"></span><h2>Functions for Closing FileReaders and FileWriters<a class="headerlink" href="#functions-for-closing-filereaders-and-filewriters" title="Link to this heading">¶</a></h2>
<p>A fileReader or fileWriter must be closed in order to free the resources
allocated for it, to ensure that data written to it is visible to other
fileReaders, or to allow the associated file to be closed.</p>
<p>See <a class="reference internal" href="#IO.fileReader.close" title="IO.fileReader.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.close</span></code></a> and <a class="reference internal" href="#IO.fileWriter.close" title="IO.fileWriter.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.close</span></code></a>.</p>
<p>It is an error to perform any I/O operations on a fileReader or fileWriter
that has been closed.
It is an error to close a file when it has fileReaders and/or fileWriters that
have not been closed.</p>
<p>Files, fileReaders and fileWriters are reference counted. Each file, fileReader
and fileWriter is closed automatically when no references to it remain. For
example, if a local variable is the only reference to a fileReader, the
fileReader will be closed when that variable goes out of scope.  Programs may
also close a file, fileReader or fileWriter explicitly.</p>
</section>
<section id="the-stdin-filereader-and-stdout-and-stderr-filewriters">
<span id="stdin-stdout-stderr"></span><h2>The <code class="docutils literal notranslate"><span class="pre">stdin</span></code> fileReader, and <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> fileWriters<a class="headerlink" href="#the-stdin-filereader-and-stdout-and-stderr-filewriters" title="Link to this heading">¶</a></h2>
<p>Chapel provides the predefined fileReader <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a>, and the predefined
fileWriters <a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdout</span></code></a>, and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stderr</span></code></a> to access the corresponding
operating system streams standard input, standard output, and standard error.</p>
<p><a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a> supports reading;
<a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stderr</span></code></a> support writing.</p>
<p>All three are safe to use concurrently.</p>
</section>
<section id="unicode-support">
<h2>Unicode Support<a class="headerlink" href="#unicode-support" title="Link to this heading">¶</a></h2>
<p>Most I/O operations default to working with textual data in the UTF-8 encoding.
This choice of UTF-8 matches the encoding used by the <code class="docutils literal notranslate"><span class="pre">string</span></code> type (see
<a class="reference internal" href="../../language/spec/strings.html#chapter-strings"><span class="std std-ref">Strings</span></a>).</p>
<p>To work with non-UTF-8 data, it’s necessary to use binary I/O routines (e.g.
<a class="reference internal" href="#IO.fileReader.readByte" title="IO.fileReader.readByte"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readByte</span></code></a>, <a class="reference internal" href="#IO.fileReader.readBytes" title="IO.fileReader.readBytes"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBytes</span></code></a>,
<a class="reference internal" href="#IO.fileReader.readBinary" title="IO.fileReader.readBinary"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBinary</span></code></a> <a class="reference internal" href="#IO.fileReader.readBits" title="IO.fileReader.readBits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBits</span></code></a>) or do I/O with a
serializer or deserializer that uses a binary format, such as
<a class="reference internal" href="#IO.binaryDeserializer" title="IO.binaryDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binaryDeserializer</span></code></a>.</p>
<p>Generally speaking, if invalid UTF-8 is encountered when reading textual data, a
<code class="docutils literal notranslate"><span class="pre">SystemError</span></code> will be throw with <code class="docutils literal notranslate"><span class="pre">EILSEQ</span></code> and the channel position will be
left just after the first byte of UTF-8 that was determined to be invalid. Some
routines have other error handling behavior as described in their documentation
(for example, see <a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readThrough</span></code></a>).</p>
</section>
<section id="error-handling">
<span id="about-io-error-handling"></span><h2>Error Handling<a class="headerlink" href="#error-handling" title="Link to this heading">¶</a></h2>
<p>Most I/O routines throw an <a class="reference internal" href="Errors.html#Errors.Error" title="Errors.Error"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">Error</span></code></a>, which can be handled
appropriately with <code class="docutils literal notranslate"><span class="pre">try</span></code> and <code class="docutils literal notranslate"><span class="pre">catch</span></code> (see the
<a class="reference internal" href="../../language/spec/error-handling.html#handling-errors"><span class="std std-ref">documentation</span></a> for more detail).</p>
<p>Additionally, some subclasses of <a class="reference internal" href="Errors.html#Errors.Error" title="Errors.Error"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">Error</span></code></a> are commonly used within
the I/O implementation. These are:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a> - the end of file was reached</p></li>
<li><p><a class="reference internal" href="OS.html#OS.UnexpectedEofError" title="OS.UnexpectedEofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.UnexpectedEofError</span></code></a> - a read or write only returned part of the requested data</p></li>
<li><p><a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> - data read did not adhere to the requested format</p></li>
</ul>
</div></blockquote>
<p id="io-general-sys-error"><strong>System Errors:</strong></p>
<p>For other error cases, a general <a class="reference internal" href="OS.html#OS.SystemError" title="OS.SystemError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SystemError</span></code></a> is typically thrown.
These errors are often produced by less predictable circumstances that are
more challenging to recover from. For example, a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> could run
out of memory when attempting to allocate more buffer space.</p>
<p>As such, it is typically recommended that more specific errors are caught and
recovered from separately from a <code class="docutils literal notranslate"><span class="pre">SystemError</span></code>. See the following example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">openReader</span><span class="p">(</span><span class="s">&quot;test.txt&quot;</span><span class="p">);</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">EofError</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;r is at EOF&quot;</span><span class="p">);</span>
  <span class="c1">// we&#39;re done reading</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">UnexpectedEofError</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;unable to read an &#39;int&#39;&quot;</span><span class="p">);</span>
  <span class="c1">// try to read something else? ...</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">SystemError</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;system error in IO implementation: &quot;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="c1">// try to recover from the error? ...</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Error</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;something else went wrong...&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="i-o-transactions">
<span id="io-transactions"></span><h2>I/O Transactions<a class="headerlink" href="#i-o-transactions" title="Link to this heading">¶</a></h2>
<p>An <em>I/O transaction</em> is a common pattern afforded by the IO interface that
provides the ability to temporarily hold a particular region of a file in a
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>’s buffer. This allows I/O
operations within that region of the file to easily be undone in the event
of some unexpected data or other errors.</p>
<p>To support <em>I/O transactions</em>, each <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is fitted
with a <em>mark stack</em> which contains a series of file offsets. The region of the
file between the minimum and maximum offset on the <em>mark stack</em> will always be
retained in the buffer.</p>
<p>The steps of a typical <em>I/O transaction</em> are as follows:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">mark</span></code> the current file offset with <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a> or
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a>. This pushes the current offset onto the <em>mark stack</em></p></li>
<li><p>do a speculative I/O operation:</p>
<blockquote>
<div><ul class="simple">
<li><p>reading example: read 200 bytes followed by a <cite>b</cite>.</p></li>
<li><p>writing example: write 200 bytes without exceeding the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s
region.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>if the operation fails, <code class="docutils literal notranslate"><span class="pre">revert</span></code> the operation by calling <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.revert</span></code></a>
or <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.revert</span></code></a>. Subsequent operations will continue from the
originally marked offset as if nothing happened.</p></li>
<li><p>if the operation is successful, call <a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.commit</span></code></a> or
<a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.commit</span></code></a> to pop the value from the <em>mark stack</em> and continue
performing I/O operations from the current offset.</p></li>
</ul>
<p>Note that when the mark stack is emptied, a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is allowed to flush
any portion of its buffer to its file and a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is allowed to discard
any portion of its buffer.</p>
<p>See the following example of a simple I/O transaction:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">fr</span> <span class="o">=</span> <span class="nx">openReader</span><span class="p">(</span><span class="s">&quot;file.txt&quot;</span><span class="p">);</span>

<span class="c1">// mark the current channel position</span>
<span class="nx">fr</span><span class="p">.</span><span class="nx">mark</span><span class="p">();</span>

<span class="c1">// read an array of bytes</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..&lt;</span><span class="mi">200</span><span class="p">]</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nx">fr</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>

<span class="c1">// try to match a pattern</span>
<span class="k">if</span> <span class="nx">fr</span><span class="p">.</span><span class="nx">matchLiteral</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fr</span><span class="p">.</span><span class="nx">commit</span><span class="p">();</span> <span class="c1">// &quot;b&quot; was found, continue reading from the current offset</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">fr</span><span class="p">.</span><span class="nx">revert</span><span class="p">();</span> <span class="c1">// &quot;b&quot; was&#39;t found, revert back to the marked position</span>

  <span class="c1">// try to read something else from the file, throw an error, etc.</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="specifying-the-region-of-a-filereader-or-filewriter">
<span id="filereader-filewriter-regions"></span><h2>Specifying the region of a fileReader or fileWriter<a class="headerlink" href="#specifying-the-region-of-a-filereader-or-filewriter" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> types can be configured to
own a specific <em>region</em> of their associated file.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is initialized using one of the
following routines, the optional <code class="docutils literal notranslate"><span class="pre">region</span></code> argument can be set to designate
some region of the file (a zero-based <a class="reference internal" href="../../language/spec/ranges.html#chapter-ranges"><span class="std std-ref">range</span></a> of integers
in bytes) that can be read from or written to:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a></p></li>
</ul>
<p>I/O operations that fall outside of the <em>region</em> are illegal. The <code class="docutils literal notranslate"><span class="pre">region</span></code>
argument defaults to <code class="docutils literal notranslate"><span class="pre">0..</span></code>, meaning that the owned region starts at the 0th
byte, and extends indefinitely.</p>
<p>Note that <a class="reference internal" href="#IO.fileReader.seek" title="IO.fileReader.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.seek</span></code></a> and <a class="reference internal" href="#IO.fileWriter.seek" title="IO.fileWriter.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.seek</span></code></a> can be used to
adjust a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s region after initialization.</p>
<p>Creating a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> that points to a sub-region of
a file can be useful for concurrently reading from or writing to multiple
portions of a file from separate tasks. See the following example, which
uses multiple tasks to concurrently read bytes from a binary file into an
array of bytes:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="c1">// the number of tasks to use</span>
<span class="kd">config</span> <span class="kd">const</span> <span class="nx">nWorkers</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="c1">// open a (large) binary file</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;file.dat&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>

<span class="c1">// compute how many bytes each worker will read</span>
<span class="kd">const</span> <span class="nx">nBytes</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span>
      <span class="nx">nPerLoc</span> <span class="o">=</span> <span class="nx">nBytes</span><span class="o">/</span> <span class="nx">nWorkers</span><span class="p">;</span>

<span class="c1">// create an array to hold the file contents</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..&lt;</span><span class="nx">nBytes</span><span class="p">]</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

<span class="c1">// concurrently read each worker&#39;s region into &#39;a&#39;</span>
<span class="k">coforall</span> <span class="nx">w</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="nx">nWorkers</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">myRegion</span> <span class="o">=</span> <span class="p">(</span><span class="nx">w</span><span class="o">*</span><span class="nx">nPerLoc</span><span class="p">)</span><span class="o">..&lt;</span><span class="p">((</span><span class="nx">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">nPerLoc</span><span class="p">),</span>
        <span class="nx">fr</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">reader</span><span class="p">(</span><span class="nx">region</span><span class="o">=</span><span class="nx">myRegion</span><span class="p">,</span> <span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>

  <span class="nx">fr</span><span class="p">.</span><span class="nx">readBinary</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">myRegion</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="locking-behavior-of-filereaders-and-filewriters">
<span id="locking-filereaders-and-filewriters"></span><h2>Locking Behavior of FileReaders and FileWriters<a class="headerlink" href="#locking-behavior-of-filereaders-and-filewriters" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> types can be configured to
lock access to their file when executing I/O operations to avoid race conditions
with other <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> instances that may be accessing the
same file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">locking</span></code> field is a <code class="docutils literal notranslate"><span class="pre">param</span></code> and is thus part of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> type. As such, it is possible to use type constraints to
designate whether a reader or writer is locking. For example this could be
useful in a procedure that relies on a <code class="docutils literal notranslate"><span class="pre">reader</span></code> argument being locking:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">readSomething</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">fileReader</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">true</span><span class="p">,</span> <span class="p">?))</span> <span class="p">{</span>
  <span class="c1">// use &#39;reader&#39; concurrently with another fileReader/fileWriter   ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">locking</span></code> field can be set by passing the desired value to one of the
following routines that create a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.openWriter" title="IO.openWriter"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openWriter</span></code></a></p></li>
</ul>
<p>With a locking <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>, one can obtain a lock manually
by calling <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lock</span></code></a> or <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a>, and then release
a lock by calling <a class="reference internal" href="#IO.fileReader.unlock" title="IO.fileReader.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.unlock</span></code></a> or <a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following methods will not automatically acquire/release a lock for
<code class="docutils literal notranslate"><span class="pre">locking=true</span></code>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.commit</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.commit</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.revert</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.revert</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.offset" title="IO.fileReader.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.offset</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.offset" title="IO.fileWriter.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.offset</span></code></a></p></li>
</ul>
</div>
</section>
<section id="ensuring-successful-i-o">
<span id="about-io-ensuring-successful-io"></span><h2>Ensuring Successful I/O<a class="headerlink" href="#ensuring-successful-i-o" title="Link to this heading">¶</a></h2>
<p>It is possible - in some situations - for I/O to fail without returning an
error. In cases where a programmer wants to be sure that there was no error
writing the data to disk, it is important to call <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> to make
sure that data has arrived on disk without an error. Many errors can be
reported with a typical operation, but some errors can only be reported by the
system during <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a> or even <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a>.</p>
<p>When a file (or fileWriter) is closed, data written to that file will be written
to disk eventually by the operating system. If an application needs to be sure
that the data is immediately written to persistent storage, it should use
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> prior to closing the file.</p>
</section>
<section id="correspondence-with-c-i-o">
<h2>Correspondence with C I/O<a class="headerlink" href="#correspondence-with-c-i-o" title="Link to this heading">¶</a></h2>
<p>It is not possible to seek, read, or write to a file directly; fileReaders
and/or fileWriters must be created and used.</p>
<p><a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> in Chapel has the same conceptual meaning as
<code class="docutils literal notranslate"><span class="pre">fflush()</span></code> in C.  However, <code class="docutils literal notranslate"><span class="pre">fflush()</span></code> is not necessarily called in
<a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush()</span></code></a>, unlike <code class="docutils literal notranslate"><span class="pre">fsync()</span></code>, which is actually called by
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync()</span></code></a> in Chapel.</p>
</section>
<section id="automatically-included-io-functions">
<h2>Automatically Included IO Functions<a class="headerlink" href="#automatically-included-io-functions" title="Link to this heading">¶</a></h2>
<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.write">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.write" title="Link to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">try!</span> <span class="pre">stdout.write</span></code>. See <a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">IO.fileWriter.write</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.writeln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.writeln" title="Link to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">try!</span> <span class="pre">stdout.writeln</span></code>. See <a class="reference internal" href="#IO.fileWriter.writeln" title="IO.fileWriter.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">IO.fileWriter.writeln</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.writef">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fmt:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isStringType(t)</span> <span class="pre">||</span> <span class="pre">isBytesType(t)</span></em><a class="headerlink" href="#IO.writef" title="Link to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">try!</span> <span class="pre">stdout.writef</span></code>. See
<a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileWriter.writef" title="FormattedIO.fileWriter.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileWriter.writef</span></code></a>.</p>
</dd></dl>

</section>
<section id="io-functions-and-types">
<h2>IO Functions and Types<a class="headerlink" href="#io-functions-and-types" title="Link to this heading">¶</a></h2>
<dl class="chpl enum">
<dt class="sig sig-object chpl" id="IO.ioMode">
<em class="property"><span class="pre">enum</span> </em><span class="sig-name descname"><span class="pre">ioMode</span></span><span class="w"> </span><em class="property"> <span class="pre">{</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">cw</span> <span class="pre">=</span> <span class="pre">2,</span> <span class="pre">rw</span> <span class="pre">=</span> <span class="pre">3,</span> <span class="pre">cwr</span> <span class="pre">=</span> <span class="pre">4,</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span> <span class="pre">}</span></em><a class="headerlink" href="#IO.ioMode" title="Link to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.ioMode" title="IO.ioMode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioMode</span></code></a> type is an enum. When used as arguments when opening files, its
constants have the same meaning as the listed strings passed to <code class="docutils literal notranslate"><span class="pre">fopen()</span></code> in C.
However, <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open()</span></code></a> in Chapel does not necessarily invoke <code class="docutils literal notranslate"><span class="pre">fopen()</span></code> in C.</p>
<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.r">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">r</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">1</span></em><a class="headerlink" href="#IO.ioMode.r" title="Link to this definition">¶</a></dt>
<dd><p>Open an existing file for reading.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “r”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.cw">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">cw</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">2</span></em><a class="headerlink" href="#IO.ioMode.cw" title="Link to this definition">¶</a></dt>
<dd><p>Create a new file for writing.
If the file already exists, its contents are truncated.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “w”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.rw">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">rw</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">3</span></em><a class="headerlink" href="#IO.ioMode.rw" title="Link to this definition">¶</a></dt>
<dd><p>Open an existing file for reading and writing.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “r+”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.cwr">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">cwr</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">4</span></em><a class="headerlink" href="#IO.ioMode.cwr" title="Link to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#IO.ioMode.cw" title="IO.ioMode.cw"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">ioMode.cw</span></code></a>, but reading from the file is also allowed.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “w+”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.a">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">a</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">5</span></em><a class="headerlink" href="#IO.ioMode.a" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.ioMode.a" title="IO.ioMode.a"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">ioMode.a</span></code></a> is unstable and subject to change. It currently only supports one <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> at a time.</p>
</div>
<p>Open a file for appending, creating it if it does not exist.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “a”)</p>
</dd></dl>

</dd></dl>

<dl class="chpl enum">
<dt class="sig sig-object chpl" id="IO.endianness">
<em class="property"><span class="pre">enum</span> </em><span class="sig-name descname"><span class="pre">endianness</span></span><span class="w"> </span><em class="property"> <span class="pre">{</span> <span class="pre">native</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">big</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">little</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">}</span></em><a class="headerlink" href="#IO.endianness" title="Link to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> type is an enum. When used as an argument to the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> methods, its constants have the
following meanings:</p>
<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.endianness.native">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">native</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">0</span></em><a class="headerlink" href="#IO.endianness.native" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">native</span></code> means binary I/O is performed in the byte order that is native
to the target platform.</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.endianness.big">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">big</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">1</span></em><a class="headerlink" href="#IO.endianness.big" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">big</span></code> means binary I/O is performed in big-endian byte order.</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.endianness.little">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">little</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">2</span></em><a class="headerlink" href="#IO.endianness.little" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">little</span></code> means binary I/O is performed in little-endian byte order.</p>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.ioendian">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">ioendian</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">endianness</span></em><a class="headerlink" href="#IO.ioendian" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.ioendian" title="IO.ioendian"><code class="xref chpl chpl-enum docutils literal notranslate"><span class="pre">ioendian</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-enum docutils literal notranslate"><span class="pre">endianness</span></code></a> instead</p>
</div>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.ioHintSet">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ioHintSet</span></span><a class="headerlink" href="#IO.ioHintSet" title="Link to this definition">¶</a></dt>
<dd><p>A value of the <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a> type defines a set of hints to provide
information about the operations that a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>, <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>
or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> will perform. These hints may be used by the
implementation to select optimized versions of the I/O operations.</p>
<p>Most hints have POSIX equivalents associated with posix_fadvise() and
posix_madvise().</p>
<p>This example depicts how an <code class="docutils literal notranslate"><span class="pre">ioHintSet</span></code> might be used.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="c1">// define a set of hints using a union operation</span>
<span class="kd">var</span> <span class="nx">hints</span> <span class="o">=</span> <span class="nx">ioHintSet</span><span class="p">.</span><span class="nx">sequential</span> <span class="o">|</span> <span class="nx">ioHintSet</span><span class="p">.</span><span class="nx">prefetch</span><span class="p">;</span>

<span class="c1">// open a file using the hints</span>
<span class="kd">var</span> <span class="nx">f</span><span class="p">:</span> <span class="nx">file</span><span class="p">;</span>
<span class="k">try</span><span class="o">!</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;path/to/my/file.txt&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">hints</span><span class="o">=</span><span class="nx">hints</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.empty">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">empty</span></span><a class="headerlink" href="#IO.ioHintSet.empty" title="Link to this definition">¶</a></dt>
<dd><p>Defines an empty set, which provides no hints.
Corresponds to ‘POSIX_*_NORMAL’.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.sequential">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">sequential</span></span><a class="headerlink" href="#IO.ioHintSet.sequential" title="Link to this definition">¶</a></dt>
<dd><p>Suggests that the file will be accessed sequentially.
Corresponds to ‘POSIX_*_SEQUENTIAL’</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.random">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">random</span></span><a class="headerlink" href="#IO.ioHintSet.random" title="Link to this definition">¶</a></dt>
<dd><p>Suggests that the file will be accessed randomly.
Corresponds to ‘POSIX_*_RANDOM’.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.prefetch">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">prefetch</span></span><a class="headerlink" href="#IO.ioHintSet.prefetch" title="Link to this definition">¶</a></dt>
<dd><p>Suggests that the runtime/OS should immediately begin prefetching the file contents.
Corresponds to ‘POSIX_*_WILLNEED’.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.mmap">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">mmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">useMmap</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.mmap" title="Link to this definition">¶</a></dt>
<dd><p>Suggests whether or not ‘mmap’ should be used to access the file contents.</p>
<blockquote>
<div><ul class="simple">
<li><p>when <code class="docutils literal notranslate"><span class="pre">useMmap</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>, suggests that ‘mmap’ should be used</p></li>
<li><p>when <code class="docutils literal notranslate"><span class="pre">useMmap</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, suggests that ‘mmap’ should not be used and ‘pread’/’pwrite’ should be used instead</p></li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.|">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">|</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.|" title="Link to this definition">¶</a></dt>
<dd><p>Compute the union of two hint sets</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.&amp;">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">&amp;</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.&" title="Link to this definition">¶</a></dt>
<dd><p>Compute the intersection of two hint sets</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.==">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">==</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.==" title="Link to this definition">¶</a></dt>
<dd><p>Compare two hint sets for equality</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.!=">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">!=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.!=" title="Link to this definition">¶</a></dt>
<dd><p>Compare two hint sets for inequality</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.file">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">file</span></span><a class="headerlink" href="#IO.file" title="Link to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type is implementation-defined.  A value of the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type refers to the state that is used by the implementation to
identify and interact with the OS file.</p>
<p>When a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> formal argument has default intent, the actual is passed
by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the formal upon a function call, and the formal
cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type does not represent any OS file.
It is illegal to perform any I/O operations on the default value.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.init">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fp:</span> <span class="pre">c_ptr(c_FILE)</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">own</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.init" title="Link to this definition">¶</a></dt>
<dd><p>Create a Chapel <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> that wraps around an open C file. A pointer to
a C <code class="docutils literal notranslate"><span class="pre">FILE</span></code> object can be obtained via Chapel’s
<a class="reference internal" href="../../primers/interopWithC.html#primers-c-interop-using-c"><span class="std std-ref">C Interoperability</span></a> functionality.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an alternative way to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>.  The main way to do so
is via the <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> function.</p>
</div>
<p>Once the Chapel file is created, you will need to use <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to
create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a fileWriter to perform I/O
operations on the C file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The resulting file value should only be used with one <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> at a time. The I/O system will ignore the offsets when
reading or writing to a file opened using this initializer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fp</strong> – a pointer to a C <code class="docutils literal notranslate"><span class="pre">FILE</span></code>. See <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a>.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
<li><p><strong>own</strong> – set to indicate if the <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a> provided should be
cleaned up when the <code class="docutils literal notranslate"><span class="pre">file</span></code> is closed.  Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – If the C file could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fileDescriptor:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">own</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Create a Chapel file that works with a system file descriptor.  Note that once
the file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a
fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a fileWriter to actually perform I/O
operations</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an alternative way to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>.  The main way to do so
is via the <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> function.</p>
</div>
<p>The system file descriptor will be closed when the Chapel file is closed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can be used to create Chapel files that refer to system file
descriptors that do not support the <code class="docutils literal notranslate"><span class="pre">seek</span></code> functionality. For example, file
descriptors that represent pipes or open socket connections have this
property. In that case, the resulting file value should only be used with one
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> at a time.  The I/O system will
ignore the fileReader offsets when reading (or the fileWriter offsets when
writing) to files backed by non-seekable file descriptors.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fileDescriptor</strong> – a system file descriptor.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
<li><p><strong>own</strong> – set to indicate if the <cite>fileDescriptor</cite> provided should be cleaned up
when the <code class="docutils literal notranslate"><span class="pre">file</span></code> is closed.  Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – If the file descriptor could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.isOpen">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">isOpen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#IO.file.isOpen" title="Link to this definition">¶</a></dt>
<dd><p>Indicates if the file is currently open.  Will return <code class="docutils literal notranslate"><span class="pre">false</span></code> for both
closed and invalid files</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.close">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.close" title="Link to this definition">¶</a></dt>
<dd><p>Close a file.</p>
<p>In order to free the resources allocated for a file, it
must be closed using this method.</p>
<p>Closing a file does not guarantee immediate persistence of the performed
updates, if any. In cases where immediate persistence is important,
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> should be used for that purpose prior to closing the file.
In particular, even though closing the file might complete without errors,
the data written might not persist in the event of a severe error like
running out of storage space or power loss. See also
<a class="reference internal" href="#about-io-ensuring-successful-io"><span class="std std-ref">Ensuring Successful I/O</span></a>.</p>
<p>Files are automatically closed when the file variable goes out of scope and
all fileReaders and fileWriters using that file are closed. Programs may also
explicitly close a file using this method.</p>
<p>It is an error to perform any I/O operations on a file that has been closed.
It is an error to close a file when it has fileReaders and/or fileWriters
that have not been closed.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the file could not be closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.fsync">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">fsync</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.fsync" title="Link to this definition">¶</a></dt>
<dd><p>Sync a file to disk.</p>
<p>Commits file data to the device associated with this file.
Data written to the file by a fileWriter will only be guaranteed
committed if the fileWriter has been closed or flushed.</p>
<p>This function will typically call the <code class="docutils literal notranslate"><span class="pre">fsync</span></code> system call.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the file could not be synced.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.path">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">path</span></span><em class="property"> <span class="pre">:</span> <span class="pre">string</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.path" title="Link to this definition">¶</a></dt>
<dd><p>Get the absolute path to an open file.</p>
<p>Note that not all files have a path (e.g. files opened with <a class="reference internal" href="#IO.openMemFile" title="IO.openMemFile"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openMemFile</span></code></a>),
and that this procedure may not work on all operating systems.</p>
<p>The function <a class="reference internal" href="Path.html#Path.realPath" title="Path.realPath"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">Path.realPath</span></code></a> is an alternative way
to get the path to a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the absolute path to the file</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the path could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.size">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">size</span></span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.size" title="Link to this definition">¶</a></dt>
<dd><p>Get the current size of an open file. Note that the size can always
change if other fileWriters, tasks or programs are writing to the file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the current file size</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – If the size could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.open">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">mode:</span> <span class="pre">ioMode</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.open" title="Link to this definition">¶</a></dt>
<dd><p>Open a file on a filesystem. Note that once the file is open, you will need to
use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to
create a fileWriter to actually perform I/O operations</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – which file to open (for example, “some/file.txt”).</p></li>
<li><p><strong>mode</strong> – specify whether to open the file for reading or writing and
whether or not to create the file if it doesn’t exist.
See <a class="reference internal" href="#IO.ioMode" title="IO.ioMode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioMode</span></code></a>.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an open file to the requested resource.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If part of the provided path did not exist</p></li>
<li><p><strong>PermissionError</strong> – If part of the provided path had inappropriate
permissions</p></li>
<li><p><strong>NotADirectoryError</strong> – If part of the provided path was expected to
be a directory but was not</p></li>
<li><p><strong>SystemError</strong> – If the file could not be opened.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openTempFile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openTempFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.openTempFile" title="Link to this definition">¶</a></dt>
<dd><p>Open a temporary file. Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a
fileWriter to actually perform I/O operations.</p>
<p>The temporary file will be created in an OS-dependent temporary directory,
for example “/tmp” is the typical location. The temporary file will be
deleted upon closing.</p>
<p>Temporary files are opened with <a class="reference internal" href="#IO.ioMode" title="IO.ioMode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioMode</span></code></a> <code class="docutils literal notranslate"><span class="pre">ioMode.cwr</span></code>; that is, a new
file is created that supports both writing and reading.  When possible, it may
be opened using OS support for temporary files in order to make sure that a new
file is created only for use by the current application.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an open temporary file.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the temporary file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openMemFile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openMemFile</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.openMemFile" title="Link to this definition">¶</a></dt>
<dd><p>Open a file that is backed by a buffer in memory that will not persist when the
file is closed.  Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a
fileWriter to actually perform I/O operations.</p>
<p>The resulting file supports both reading and writing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an open memory file.</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – If the memory buffered file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.fileReader">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">fileReader</span></span><a class="headerlink" href="#IO.fileReader" title="Link to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> supports sequential reading from an underlying <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>
object. It can buffer data. Read operations on it might return old data.</p>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type is implementation-defined.
A value of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type refers to the state that is used
to implement the reading operations.</p>
<p>When a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> formal argument has default intent, the actual is
passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the formal upon a function call, and the formal
cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type is not associated
with any file, and so cannot be used to perform I/O.</p>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type is generic.</p>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileReader.locking">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">locking</span></span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#IO.fileReader.locking" title="Link to this definition">¶</a></dt>
<dd><p>locking is a boolean indicating whether it is safe to use this
fileReader concurrently (when <cite>true</cite>).</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileReader.deserializerType">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">deserializerType</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">defaultSerializeType(false)</span></em><a class="headerlink" href="#IO.fileReader.deserializerType" title="Link to this definition">¶</a></dt>
<dd><p>deserializerType indicates the type of the deserializer that this
fileReader will use to deserialize data.</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.getFile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">getFile</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.getFile" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The ‘fileReader.getFile()’ method may change based on feedback</p>
</div>
<p>Get the <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type underlying a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.deserializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">deserializer</span></span><span class="w"> </span><em class="property"> <span class="pre">ref</span></em><em class="property"> <span class="pre">:</span> <span class="pre">deserializerType</span></em><a class="headerlink" href="#IO.fileReader.deserializer" title="Link to this definition">¶</a></dt>
<dd><p>Return a mutable reference to this fileReader’s deserializer.</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.fileWriter">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">fileWriter</span></span><a class="headerlink" href="#IO.fileWriter" title="Link to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> supports sequential writing to an underlying <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>
object. A <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> can buffer data. Write operations might not have an
immediate effect. Use <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> to control this buffering.</p>
<p>The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type is implementation-defined.
A value of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type refers to the state that is used
to implement the writing operations.</p>
<p>When a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> formal argument has default intent, the actual is
passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the formal upon a function call, and the formal
cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type is not associated with any
file, and so cannot be used to perform I/O.</p>
<p>The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type is generic.</p>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileWriter.locking">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">locking</span></span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#IO.fileWriter.locking" title="Link to this definition">¶</a></dt>
<dd><p>locking is a boolean indicating whether it is safe to use this
fileWriter concurrently (when <cite>true</cite>).</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileWriter.serializerType">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">serializerType</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">defaultSerializeType(true)</span></em><a class="headerlink" href="#IO.fileWriter.serializerType" title="Link to this definition">¶</a></dt>
<dd><p>serializerType indicates the type of the serializer that this fileWriter
will use to serialize data.</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.getFile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">getFile</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.getFile" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The ‘fileWriter.getFile()’ method may change based on feedback</p>
</div>
<p>Get the <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type underlying a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.serializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">serializer</span></span><span class="w"> </span><em class="property"> <span class="pre">ref</span></em><em class="property"> <span class="pre">:</span> <span class="pre">serializerType</span></em><a class="headerlink" href="#IO.fileWriter.serializer" title="Link to this definition">¶</a></dt>
<dd><p>Return a mutable reference to this fileWriter’s serializer.</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">defaultSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer" title="Link to this definition">¶</a></dt>
<dd><p>The default Serializer used by <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Serializers and their usage.</p>
<p>Otherwise, please refer to the individual methods in this type for a
description of the default IO format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.serializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">serializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.serializeValue" title="Link to this definition">¶</a></dt>
<dd><p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code> with <code class="docutils literal notranslate"><span class="pre">writer</span></code>.</p>
<p>Numeric values are serialized as though they were written with the format
as <code class="docutils literal notranslate"><span class="pre">%i</span></code> for integers and <code class="docutils literal notranslate"><span class="pre">%r</span></code> for <code class="docutils literal notranslate"><span class="pre">real</span></code> numbers. Complex numbers are
serialized as <code class="docutils literal notranslate"><span class="pre">%z</span></code>. Please refer to <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">the section on Formatted
IO</span></a> for more information.</p>
<p>Booleans are serialized as the literal strings <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> values are serialized using the same format as <code class="docutils literal notranslate"><span class="pre">%s</span></code> — that is,
literally and without quotes. <code class="docutils literal notranslate"><span class="pre">bytes</span></code> values are also serialized
literally without extra formatting.</p>
<p>Enums are serialized using the name of the corresponding value. For example
with an enum like <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">colors</span> <span class="pre">{red,</span> <span class="pre">green</span> <span class="pre">blue}</span></code>, the value <code class="docutils literal notranslate"><span class="pre">red</span></code>
would simply be serialized as <code class="docutils literal notranslate"><span class="pre">red</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nil</span></code> value and nilable class variables storing <code class="docutils literal notranslate"><span class="pre">nil</span></code> will be
serialized as the text <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>Classes and records will have their <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method invoked, passing
in <code class="docutils literal notranslate"><span class="pre">writer</span></code> and this Serializer as arguments. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more information.</p>
<p>Classes and records are expected to implement the <code class="docutils literal notranslate"><span class="pre">writeSerializable</span></code>
or <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> used to write serialized output.</p></li>
<li><p><strong>val</strong> – The value to be serialized.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.startClass" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a class by writing the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer" title="IO.defaultSerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.startRecord" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a record by writing the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the record type.</p></li>
<li><p><strong>size</strong> – The number of fields in the record.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer" title="IO.defaultSerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startClass</span></code> or <code class="docutils literal notranslate"><span class="pre">startRecord</span></code> to provide the API for
serializing classes or records.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">class</span></code> with integer fields ‘x’ and ‘y’ with values ‘0’ and ‘5’ would
be serialized as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{x = 0, y = 5}
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">record</span></code> with matching fields would be serialized in the same way, but
would use <code class="docutils literal notranslate"><span class="pre">(</span></code> and <code class="docutils literal notranslate"><span class="pre">)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.writeField">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">field:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.writeField" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">field</span></code> named <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>Serializes fields in the form ‘&lt;name&gt; = &lt;field&gt;’. Adds a comma before the
name if this is not the first field.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.startClass">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.startClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start serializing a nested class inside the current class. In this format
inheritance is not represented and parent fields are printed before child
fields. For example, the following classes with values
<code class="docutils literal notranslate"><span class="pre">x=5</span></code> and <code class="docutils literal notranslate"><span class="pre">y=2.0</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>would be serialized as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{x = 5, y = 2.0}
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing. Must match
the writer used to create current AggregateSerializer.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer" title="IO.defaultSerializer.AggregateSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.endClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current class by writing the character <code class="docutils literal notranslate"><span class="pre">}</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is an error to call methods on an AggregateSerializer after
invoking ‘endClass’.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.endRecord" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current record by writing the character <code class="docutils literal notranslate"><span class="pre">)</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is an error to call methods on an AggregateSerializer after
invoking ‘endRecord’.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.startTuple" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a tuple by writing the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.TupleSerializer" title="IO.defaultSerializer.TupleSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">TupleSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.TupleSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer.TupleSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> to provide the API for serializing tuples.</p>
<p>A tuple will be serialized as a comma-separated list between two
parentheses. For example, the tuple literal <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> would be
serialized as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>A 1-tuple will be serialized with a trailing comma. For example, the literal
<code class="docutils literal notranslate"><span class="pre">(4,)</span></code> would be serialized as <code class="docutils literal notranslate"><span class="pre">(4,)</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.TupleSerializer.writeElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.TupleSerializer.writeElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>Writes a leading comma before serializing the element if this is not the
first element in the tuple.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.TupleSerializer.endTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.TupleSerializer.endTuple" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current tuple by writing the character <code class="docutils literal notranslate"><span class="pre">)</span></code>.</p>
<p>Adds a comma between the last value and <code class="docutils literal notranslate"><span class="pre">)</span></code> if there was only one
element.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.startList" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a list by writing the character <code class="docutils literal notranslate"><span class="pre">[</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.ListSerializer" title="IO.defaultSerializer.ListSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ListSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ListSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer.ListSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startList</span></code> to provide the API for serializing lists.</p>
<p>A list will be serialized as a comma-separated series of serialized
elements between two square brackets. For example, serializing a list
with elements <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> will produce the text:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
</pre></div>
</div>
<p>Empty lists will be serialized as <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ListSerializer.writeElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.ListSerializer.writeElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>Writes a leading comma before serializing the element if this is not the
first element in the list.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ListSerializer.endList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.ListSerializer.endList" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current list by writing the character <code class="docutils literal notranslate"><span class="pre">]</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.startArray" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.ArraySerializer" title="IO.defaultSerializer.ArraySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArraySerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ArraySerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArraySerializer</span></span><a class="headerlink" href="#IO.defaultSerializer.ArraySerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.defaultSerializer.startArray" title="IO.defaultSerializer.startArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startArray</span></code></a> to provide the API for
serializing arrays.</p>
<p>In the default format, an array will be serialized as a
whitespace-separated series of serialized elements.</p>
<p>A 1D array is serialized simply using spaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
</pre></div>
</div>
<p>A 2D array is serialized using spaces between elements in a row, and
prints newlines for new rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
</pre></div>
</div>
<p>Arrays with three or more dimensions will be serialized as a series of
2D “panes”, with multiple newlines separating new dimensions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>

<span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span>
<span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span>
<span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span>

<span class="mi">19</span> <span class="mi">20</span> <span class="mi">21</span>
<span class="mi">22</span> <span class="mi">23</span> <span class="mi">24</span>
<span class="mi">25</span> <span class="mi">26</span> <span class="mi">27</span>
</pre></div>
</div>
<p>Empty arrays result in no output to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ArraySerializer.startDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.ArraySerializer.startDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Inform the <a class="reference internal" href="#IO.defaultSerializer.ArraySerializer" title="IO.defaultSerializer.ArraySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArraySerializer</span></code></a> to start
serializing a new dimension of size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ArraySerializer.endDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.ArraySerializer.endDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End the current dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ArraySerializer.writeElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.ArraySerializer.writeElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>Adds a space if this is not the first element in the row.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.ArraySerializer.endArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.ArraySerializer.endArray" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.startMap" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a map by writing the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of entries in the map.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.MapSerializer" title="IO.defaultSerializer.MapSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">MapSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.MapSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer.MapSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.defaultSerializer.startMap" title="IO.defaultSerializer.startMap"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startMap</span></code></a> to provide the API for
serializing maps.</p>
<p>Maps are serialized as a comma-separated series of pairs between curly
braces. Pairs are serialized with a <code class="docutils literal notranslate"><span class="pre">:</span></code> separating the key and value. For
example, the keys <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> with values corresponding to
their squares would be serialized as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">9</span><span class="p">}</span>
</pre></div>
</div>
<p>Empty maps will be serialized as <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.MapSerializer.writeKey">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">key:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.MapSerializer.writeKey" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<p>Adds a leading comma if this is not the first pair in the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.MapSerializer.writeValue">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.MapSerializer.writeValue" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code>, preceded by the character <code class="docutils literal notranslate"><span class="pre">:</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.MapSerializer.endMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultSerializer.MapSerializer.endMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current map by writing the character <code class="docutils literal notranslate"><span class="pre">}</span></code></p>
</dd></dl>

</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">defaultDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>The default Deserializer used by <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Deserializers and their usage.</p>
<p>Otherwise, please refer to <a class="reference internal" href="#IO.defaultSerializer" title="IO.defaultSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">defaultSerializer</span></code></a> for a description
of the default IO format. Individual methods on this type may clarify
behavior specific to deserialization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prior to the 1.32 release and the advent of the ‘serializers’ feature, the
default implementation for reading classes and records permitted reading
fields out of order. This functionality is not supported by the
<code class="docutils literal notranslate"><span class="pre">defaultDeserializer</span></code>.</p>
<p>For an unspecified amount of time this module will retain the ability to
disable automatic use of the <code class="docutils literal notranslate"><span class="pre">defaultDeserializer</span></code> by recompiling
programs with the config-param <code class="docutils literal notranslate"><span class="pre">useIOSerializers</span></code> set to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Eventually, however, users must update their programs to account for
reading fields out of order.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.deserializeType">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">readType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">readType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.deserializeType" title="Link to this definition">¶</a></dt>
<dd><p>Deserialize type <code class="docutils literal notranslate"><span class="pre">readType</span></code> with <code class="docutils literal notranslate"><span class="pre">reader</span></code>.</p>
<p>Classes and records will be deserialized using an appropriate initializer,
passing in <code class="docutils literal notranslate"><span class="pre">reader</span></code> and this Deserializer as arguments. If an
initializer is unavailable, this method may invoke the class or record’s
<code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more information.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> interfaces (or both).
Alternatively, types implementing the entire <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface
are also accepted.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> from which types are deserialized.</p></li>
<li><p><strong>readType</strong> – The type to be deserialized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A value of type <code class="docutils literal notranslate"><span class="pre">readType</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.deserializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">val:</span> <span class="pre">?readType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.deserializeValue" title="Link to this definition">¶</a></dt>
<dd><p>Deserialize from <code class="docutils literal notranslate"><span class="pre">reader</span></code> directly into <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
<p>Like <a class="reference internal" href="#IO.defaultDeserializer.deserializeType" title="IO.defaultDeserializer.deserializeType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">deserializeType</span></code></a>, but reads into an initialized value rather
than creating a new value. For classes and records, this method will first
attempt to invoke a <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. If the <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method
is unavailable, this method may fall back on invoking a suitable
initializer and assigning the resulting value into <code class="docutils literal notranslate"><span class="pre">val</span></code>. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> interfaces (or both).
Alternatively, types implementing the entire <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface
are also accepted.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> from which values are deserialized.</p></li>
<li><p><strong>val</strong> – The value into which this Deserializer will deserialize.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.startClass" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a class by reading the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the class type</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.AggregateDeserializer" title="IO.defaultDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.startRecord" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a record by reading the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the record type</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.AggregateDeserializer" title="IO.defaultDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.defaultDeserializer.startClass" title="IO.defaultDeserializer.startClass"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startClass</span></code></a> or
<a class="reference internal" href="#IO.defaultDeserializer.startRecord" title="IO.defaultDeserializer.startRecord"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startRecord</span></code></a> to provide the API for
deserializing classes or records.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer" title="IO.defaultSerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a> for details of the
default format for classes and records.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.readField">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">fieldType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fieldType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.readField" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize a field named <code class="docutils literal notranslate"><span class="pre">name</span></code> of type <code class="docutils literal notranslate"><span class="pre">fieldType</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">fieldType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">field</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize a field named <code class="docutils literal notranslate"><span class="pre">name</span></code> in-place.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.startClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start deserializing a nested class inside the current class.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer.startClass" title="IO.defaultSerializer.AggregateSerializer.startClass"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">defaultSerializer.AggregateSerializer.startClass</span></code></a> for details
on inheritance on the default format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new AggregateDeserializer</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.endClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current class by reading the character <code class="docutils literal notranslate"><span class="pre">}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.endRecord" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current record by reading the character <code class="docutils literal notranslate"><span class="pre">)</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.startTuple" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a tuple by reading the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.TupleDeserializer" title="IO.defaultDeserializer.TupleDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">TupleDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.TupleDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer.TupleDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> to provide the API for deserializing tuples.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.TupleSerializer" title="IO.defaultSerializer.TupleSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">TupleSerializer</span></code></a> for details of the
default format for tuples.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.TupleDeserializer.readElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.TupleDeserializer.readElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the tuple.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.TupleDeserializer.endTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.TupleDeserializer.endTuple" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current tuple by reading the character <code class="docutils literal notranslate"><span class="pre">)</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startList">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.startList" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a list by reading the character <code class="docutils literal notranslate"><span class="pre">[</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.ListDeserializer" title="IO.defaultDeserializer.ListDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ListDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ListDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer.ListDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startList</span></code> to provide the API for deserializing lists.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.ListSerializer" title="IO.defaultSerializer.ListSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ListSerializer</span></code></a> for details of the
default format for lists.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ListDeserializer.readElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ListDeserializer.readElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the list.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ListDeserializer.endList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ListDeserializer.endList" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current list by reading the character <code class="docutils literal notranslate"><span class="pre">]</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ListDeserializer.hasMore">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ListDeserializer.hasMore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.startArray" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.ArrayDeserializer" title="IO.defaultDeserializer.ArrayDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ArrayDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArrayDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer.ArrayDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startArray</span></code> to provide the API for deserializing arrays.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.ArraySerializer" title="IO.defaultSerializer.ArraySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArraySerializer</span></code></a> for details of the
default format for arrays.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ArrayDeserializer.startDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ArrayDeserializer.startDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Inform the <a class="reference internal" href="#IO.defaultDeserializer.ArrayDeserializer" title="IO.defaultDeserializer.ArrayDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a> to start
deserializing a new dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ArrayDeserializer.endDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ArrayDeserializer.endDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ArrayDeserializer.readElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ArrayDeserializer.readElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the array.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.ArrayDeserializer.endArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.ArrayDeserializer.endArray" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.startMap" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a map by reading the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.MapDeserializer" title="IO.defaultDeserializer.MapDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">MapDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.MapDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer.MapDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startMap</span></code> to provide the API for deserializing maps.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.MapSerializer" title="IO.defaultSerializer.MapSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">MapSerializer</span></code></a> for details of the default
format for map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.MapDeserializer.readKey">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">keyType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">keyType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.MapDeserializer.readKey" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a key of type <code class="docutils literal notranslate"><span class="pre">keyType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">key</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">key</span></code> in-place as a key of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.MapDeserializer.readValue">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">valType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">valType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.MapDeserializer.readValue" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a value of type <code class="docutils literal notranslate"><span class="pre">valType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">value</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">value</span></code> in-place as a value of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.MapDeserializer.endMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.MapDeserializer.endMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current map by reading the character <code class="docutils literal notranslate"><span class="pre">}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.MapDeserializer.hasMore">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.defaultDeserializer.MapDeserializer.hasMore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Behavior of ‘hasMore’ is undefined when called between <code class="docutils literal notranslate"><span class="pre">readKey</span></code> and
<code class="docutils literal notranslate"><span class="pre">readValue</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.warnBinaryStructured">
<em class="property"><span class="pre">config</span> <span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">warnBinaryStructured</span></span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">true</span></em><a class="headerlink" href="#IO.warnBinaryStructured" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This config param is unstable and may be removed without advance notice</p>
</div>
<p>This config param allows users to disable a warning for reading and writing
classes and strings with <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a> and
<a class="reference internal" href="#IO.binaryDeserializer" title="IO.binaryDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binaryDeserializer</span></code></a> following a format change in the 1.33 release.</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">binarySerializer</span></span><a class="headerlink" href="#IO.binarySerializer" title="Link to this definition">¶</a></dt>
<dd><p>A binary Serializer that implements a simple binary format.</p>
<p>This Serializer supports an <code class="docutils literal notranslate"><span class="pre">endian</span></code> field which may be configured at
execution time.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Serializers and their usage.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the 1.32 release this format included bytes representing the length of
a string. Also, classes were serialized beginning with a single byte to
indicate whether the class value was <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This behavior was changed
in the subsequent release to provide users with a more flexible
serializer that did not insert bytes that the user did not request. A
compile-time warning will be issued to indicate that this behavior has
changed. Users can recompile with <code class="docutils literal notranslate"><span class="pre">-swarnBinaryStructured=false</span></code> to
silence the warning.</p>
<p>To mimic the old behavior, please use the unstable
<a class="reference internal" href="../packages/ObjectSerialization.html#module-ObjectSerialization" title="ObjectSerialization: The ObjectSerialization module provides an objectSerializer and"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">ObjectSerialization</span></code></a> module.</p>
</div>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.binarySerializer.endian">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">endian</span></span><em class="property"> <span class="pre">:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><a class="headerlink" href="#IO.binarySerializer.endian" title="Link to this definition">¶</a></dt>
<dd><p>‘endian’ represents the endianness of the binary output produced by this
Serializer.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.serializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">serializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(serializerType</span> <span class="pre">=</span> <span class="pre">binarySerializer</span></em>, <em class="sig-param"><span class="pre">locking</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">?)</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.serializeValue" title="Link to this definition">¶</a></dt>
<dd><p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code> with <code class="docutils literal notranslate"><span class="pre">writer</span></code>.</p>
<p>Numeric values like integers, real numbers, and complex numbers are
serialized directly to the associated <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> as binary data in
the specified endianness.</p>
<p>Booleans are serialized as single byte unsigned values of either <code class="docutils literal notranslate"><span class="pre">0</span></code> or
<code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> values are serialized as a raw sequence of bytes that does not
include a null terminator, nor any bytes representing length. This means
that <code class="docutils literal notranslate"><span class="pre">string</span></code> values cannot be deserialized without manual intervention
by users to decide how their strings should be stored such that they can
be deserialized.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nil</span></code> value is serialized as a single unsigned byte of value <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Classes and records will have their <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method invoked, passing
in <code class="docutils literal notranslate"><span class="pre">writer</span></code> and this Serializer as arguments. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more on the <code class="docutils literal notranslate"><span class="pre">serialize</span></code>
method.</p>
<p>Classes and records are expected to implement the <code class="docutils literal notranslate"><span class="pre">writeSerializable</span></code>
interface. The <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface is also acceptable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Serializing and deserializing enums is not stable in this format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> used to write serialized output.</p></li>
<li><p><strong>val</strong> – The value to be serialized.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.startClass" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a class and return a new <code class="docutils literal notranslate"><span class="pre">AggregateSerializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binarySerializer.AggregateSerializer" title="IO.binarySerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.startRecord" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a record and return a new <code class="docutils literal notranslate"><span class="pre">AggregateSerializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the record type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binarySerializer.AggregateSerializer" title="IO.binarySerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateSerializer</span></span><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binarySerializer.startClass" title="IO.binarySerializer.startClass"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startClass</span></code></a> or
<a class="reference internal" href="#IO.binarySerializer.startRecord" title="IO.binarySerializer.startRecord"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startRecord</span></code></a> to provide the API for serializing
classes or records.</p>
<p>In this simple binary format, classes and records do not begin or end with
any bytes indicating size, and instead serialize their field values in
<code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<p>For example, a record with two <code class="docutils literal notranslate"><span class="pre">uint(8)</span></code> fields with values <code class="docutils literal notranslate"><span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">2</span></code> would be serialized as <code class="docutils literal notranslate"><span class="pre">0x01</span></code> followed by <code class="docutils literal notranslate"><span class="pre">0x02</span></code> (in raw binary).</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.writeField">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">field:</span> <span class="pre">?T</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.writeField" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">field</span></code> in <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.startClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start serializing a nested class inside the current class. In this
binary format, this has no impact on the serialized output.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.endClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of this class.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.endRecord" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of this record.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.startTuple" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a tuple and return a new <a class="reference internal" href="#IO.binarySerializer.TupleSerializer" title="IO.binarySerializer.TupleSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">TupleSerializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new TupleSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer.TupleSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleSerializer</span></span><a class="headerlink" href="#IO.binarySerializer.TupleSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binarySerializer.startTuple" title="IO.binarySerializer.startTuple"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startTuple</span></code></a> to provide the API for
serializing tuples.</p>
<p>In this simple binary format, tuples do not begin or end with any bytes
indicating size, and instead serialize their elements sequentially in
<a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.TupleSerializer.writeElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?T</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.TupleSerializer.writeElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.TupleSerializer.endTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.TupleSerializer.endTuple" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current tuple.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.startList" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a list by serializing <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binarySerializer.ListSerializer" title="IO.binarySerializer.ListSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ListSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ListSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListSerializer</span></span><a class="headerlink" href="#IO.binarySerializer.ListSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binarySerializer.startList" title="IO.binarySerializer.startList"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startList</span></code></a> to provide the API for
serializing lists.</p>
<p>In this simple binary format, lists begin with the serialization of an
<code class="docutils literal notranslate"><span class="pre">int</span></code> representing the size of the list. This data is then followed by
the binary serialization of the specified number of elements.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ListSerializer.writeElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.ListSerializer.writeElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ListSerializer.endList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.ListSerializer.endList" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of  the current list.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.startArray" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing an array and return a new <a class="reference internal" href="#IO.binarySerializer.ArraySerializer" title="IO.binarySerializer.ArraySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArraySerializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new ArraySerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ArraySerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArraySerializer</span></span><a class="headerlink" href="#IO.binarySerializer.ArraySerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binarySerializer.startArray" title="IO.binarySerializer.startArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startArray</span></code></a> to provide the API for
serializing arrays.</p>
<p>In this simple binary format, arrays are serialized element by element
in the order indicated by the caller of <a class="reference internal" href="#IO.binarySerializer.ArraySerializer.writeElement" title="IO.binarySerializer.ArraySerializer.writeElement"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writeElement</span></code></a>. Dimensions and
the start or end of the array are not represented.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ArraySerializer.startDim">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.ArraySerializer.startDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start serializing a new dimension of the array.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ArraySerializer.endDim">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.ArraySerializer.endDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of this dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ArraySerializer.writeElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.ArraySerializer.writeElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ArraySerializer.writeBulkElements">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeBulkElements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data:</span> <span class="pre">c_ptr(?eltType)</span></em>, <em class="sig-param"><span class="pre">numElements:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">isNumericType(eltType)</span></em><a class="headerlink" href="#IO.binarySerializer.ArraySerializer.writeBulkElements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">numElements</span></code> number of elements in <code class="docutils literal notranslate"><span class="pre">data</span></code>, provided that
the element type of <code class="docutils literal notranslate"><span class="pre">data</span></code> is a numeric type.</p>
<p>This performance-motivated implementation of the optional
<code class="docutils literal notranslate"><span class="pre">writeBulkElements</span></code> will write the elements of <code class="docutils literal notranslate"><span class="pre">data</span></code> in the order
in which they are represented in memory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only optimized for the case where the
<a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a> has been configured for <code class="docutils literal notranslate"><span class="pre">native</span></code>
endianness.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method should only be called when the <code class="docutils literal notranslate"><span class="pre">data</span></code> argument is located
on the same locale as the underlying <code class="docutils literal notranslate"><span class="pre">file</span></code> of this serializer.
Otherwise the <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code> will be invalid.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.ArraySerializer.endArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.ArraySerializer.endArray" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.startMap" title="Link to this definition">¶</a></dt>
<dd><p>Start serializing a map by serializing <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of entries in the map.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binarySerializer.MapSerializer" title="IO.binarySerializer.MapSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">MapSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer.MapSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapSerializer</span></span><a class="headerlink" href="#IO.binarySerializer.MapSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binarySerializer.startMap" title="IO.binarySerializer.startMap"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startMap</span></code></a> to provide the API for
serializing maps.</p>
<p>In this simple binary format, maps begin with the serialization of an
<code class="docutils literal notranslate"><span class="pre">int</span></code> representing the size of the map. This data is then followed by the
binary serialization of the specified number of key-value pairs. The binary
serialization of a key-value pair has no structure, and simply consists of
the serialization of the key followed by the serialization of the value.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.MapSerializer.writeKey">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">key:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.MapSerializer.writeKey" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">key</span></code> in <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.MapSerializer.writeValue">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.MapSerializer.writeValue" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code> in <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer</span></code></a>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.MapSerializer.endMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binarySerializer.MapSerializer.endMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current map.</p>
</dd></dl>

</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">binaryDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>A binary Deserializer that implements a simple binary format.</p>
<p>This Deserializer supports an <code class="docutils literal notranslate"><span class="pre">endian</span></code> field which may be configured at
execution time.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Deserializers and their usage.</p>
<p>Otherwise, please refer to <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">binarySerializer</span></code></a> for a description of the
binary format. Individual methods on this type may clarify relevant behavior
specific to deserialization</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deserializing <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> types will
result in an <a class="reference internal" href="Errors.html#Errors.IllegalArgumentError" title="Errors.IllegalArgumentError"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code></a> because these types cannot
currently be deserialized with the raw nature of the format.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the 1.32 release this format included bytes representing the length of
a string. Also, classes were serialized beginning with a single byte to
indicate whether the class value was <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This behavior was changed
in the subsequent release to provide users with a more flexible
deserializer that did not read bytes that the user did not request. A
compile-time warning will be issued to indicate that this behavior has
changed. Users can recompile with <code class="docutils literal notranslate"><span class="pre">-swarnBinaryStructured=false</span></code> to
silence the warning.</p>
<p>To mimic the old behavior, please use the unstable
<a class="reference internal" href="../packages/ObjectSerialization.html#module-ObjectSerialization" title="ObjectSerialization: The ObjectSerialization module provides an objectSerializer and"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">ObjectSerialization</span></code></a> module.</p>
</div>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.endian">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">endian</span></span><em class="property"> <span class="pre">:</span> <span class="pre">IO.endianness</span> <span class="pre">=</span> <span class="pre">IO.endianness.native</span></em><a class="headerlink" href="#IO.binaryDeserializer.endian" title="Link to this definition">¶</a></dt>
<dd><p>‘endian’ represents the endianness that this Deserializer should use when
deserializing input.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.deserializeType">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">readType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">readType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.deserializeType" title="Link to this definition">¶</a></dt>
<dd><p>Deserialize type <code class="docutils literal notranslate"><span class="pre">readType</span></code> with <code class="docutils literal notranslate"><span class="pre">reader</span></code>.</p>
<p>Classes and records will be deserialized using an appropriate initializer,
passing in <code class="docutils literal notranslate"><span class="pre">reader</span></code> and this Deserializer as arguments. If an
initializer is unavailable, this method may invoke the class or record’s
<code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. Please see the <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> interfaces (or both). The
<code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface is also acceptable.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> from which types are deserialized.</p></li>
<li><p><strong>readType</strong> – The type to be deserialized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A value of type <code class="docutils literal notranslate"><span class="pre">readType</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.deserializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">val:</span> <span class="pre">?readType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.deserializeValue" title="Link to this definition">¶</a></dt>
<dd><p>Deserialize from <code class="docutils literal notranslate"><span class="pre">reader</span></code> directly into <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
<p>Like <a class="reference internal" href="#IO.binaryDeserializer.deserializeType" title="IO.binaryDeserializer.deserializeType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">deserializeType</span></code></a>, but reads into an initialized value rather
than creating a new value. For classes and records, this method will first
attempt to invoke a <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. If the <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method
is unavailable, this method may fall back on invoking a suitable
initializer and assigning the resulting value into <code class="docutils literal notranslate"><span class="pre">val</span></code>. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> interfaces (or both). The
<code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface is also acceptable.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> from which values are deserialized.</p></li>
<li><p><strong>val</strong> – The value into which this Deserializer will deserialize.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.startClass" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a class by returning an <a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.startRecord" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a record by returning an
<a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the record type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binaryDeserializer.startClass" title="IO.binaryDeserializer.startClass"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startClass</span></code></a> or
<a class="reference internal" href="#IO.binaryDeserializer.startRecord" title="IO.binaryDeserializer.startRecord"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startRecord</span></code></a> to provide the API for
deserializing classes or records.</p>
<p>See <a class="reference internal" href="#IO.binarySerializer.AggregateSerializer" title="IO.binarySerializer.AggregateSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer.AggregateSerializer</span></code></a> for details of the
binary format for classes and records.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.readField">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">fieldType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fieldType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.readField" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a value of type <code class="docutils literal notranslate"><span class="pre">fieldType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">field</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">field</span></code> in-place.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.startClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start deserializing a nested class inside the current class.</p>
<p>See <a class="reference internal" href="#IO.binarySerializer.AggregateSerializer.startClass" title="IO.binarySerializer.AggregateSerializer.startClass"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">binarySerializer.AggregateSerializer.startClass</span></code></a> for details
on inheritance on the binary format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.endClass" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current class.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.endRecord" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current record.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.startTuple" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a tuple by returning a <a class="reference internal" href="#IO.binaryDeserializer.TupleDeserializer" title="IO.binaryDeserializer.TupleDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">TupleDeserializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.TupleDeserializer" title="IO.binaryDeserializer.TupleDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">TupleDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.TupleDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer.TupleDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binaryDeserializer.startTuple" title="IO.binaryDeserializer.startTuple"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startTuple</span></code></a> to provide the API for
deserializing tuples.</p>
<p>See <a class="reference internal" href="#IO.binarySerializer.TupleSerializer" title="IO.binarySerializer.TupleSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer.TupleSerializer</span></code></a> for details of the binary
format for tuples.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.TupleDeserializer.readElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.TupleDeserializer.readElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the tuple.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.TupleDeserializer.endTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.TupleDeserializer.endTuple" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current tuple.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.startList" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a list by returning a <a class="reference internal" href="#IO.binaryDeserializer.ListDeserializer" title="IO.binaryDeserializer.ListDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ListDeserializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.ListDeserializer" title="IO.binaryDeserializer.ListDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ListDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ListDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer.ListDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binaryDeserializer.startList" title="IO.binaryDeserializer.startList"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startList</span></code></a> to provide the API for
deserializing lists.</p>
<p>See <a class="reference internal" href="#IO.binarySerializer.ListSerializer" title="IO.binarySerializer.ListSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer.ListSerializer</span></code></a> for details of the binary
format for lists.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ListDeserializer.readElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ListDeserializer.readElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the list.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ListDeserializer.endList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ListDeserializer.endList" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current list.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">BadFormatError</span></code></a> if there are remaining elements.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ListDeserializer.hasMore">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ListDeserializer.hasMore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.startArray" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing an array by returning an <a class="reference internal" href="#IO.binaryDeserializer.ArrayDeserializer" title="IO.binaryDeserializer.ArrayDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.ArrayDeserializer" title="IO.binaryDeserializer.ArrayDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ArrayDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArrayDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer.ArrayDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binaryDeserializer.startArray" title="IO.binaryDeserializer.startArray"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startArray</span></code></a> to provide the API for
deserializing arrays.</p>
<p>See <a class="reference internal" href="#IO.binarySerializer.ArraySerializer" title="IO.binarySerializer.ArraySerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer.ArraySerializer</span></code></a> for details of the binary
format for arrays.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ArrayDeserializer.startDim">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ArrayDeserializer.startDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Inform the <a class="reference internal" href="#IO.binaryDeserializer.ArrayDeserializer" title="IO.binaryDeserializer.ArrayDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a> to start
deserializing a new dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ArrayDeserializer.endDim">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ArrayDeserializer.endDim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ArrayDeserializer.readElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ArrayDeserializer.readElement" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the array.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ArrayDeserializer.readBulkElements">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readBulkElements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data:</span> <span class="pre">c_ptr(?eltType)</span></em>, <em class="sig-param"><span class="pre">numElements:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">isNumericType(eltType)</span></em><a class="headerlink" href="#IO.binaryDeserializer.ArrayDeserializer.readBulkElements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">numElements</span></code> number of elements into <code class="docutils literal notranslate"><span class="pre">data</span></code>, provided
that the element type of <code class="docutils literal notranslate"><span class="pre">data</span></code> is a numeric type.</p>
<p>This performance-motivated implementation of the optional
<code class="docutils literal notranslate"><span class="pre">readBulkElements</span></code> will read the elements of <code class="docutils literal notranslate"><span class="pre">data</span></code> in the order in
which they are represented in memory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only optimized for the case where the
<a class="reference internal" href="#IO.binaryDeserializer" title="IO.binaryDeserializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binaryDeserializer</span></code></a> has been configured for <code class="docutils literal notranslate"><span class="pre">native</span></code>
endianness.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method should only be called when the <code class="docutils literal notranslate"><span class="pre">data</span></code> argument is located
on the same locale as the underlying <code class="docutils literal notranslate"><span class="pre">file</span></code> of this deserializer.
Otherwise the <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code> will be invalid.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.ArrayDeserializer.endArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.ArrayDeserializer.endArray" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.startMap" title="Link to this definition">¶</a></dt>
<dd><p>Start deserializing a map by returning a <code class="docutils literal notranslate"><span class="pre">MapDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reader</strong> – The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.MapDeserializer" title="IO.binaryDeserializer.MapDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">MapDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.MapDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer.MapDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Returned by <a class="reference internal" href="#IO.binaryDeserializer.startMap" title="IO.binaryDeserializer.startMap"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">startMap</span></code></a> to provide the API for
deserializing maps.</p>
<p>See <a class="reference internal" href="#IO.binarySerializer.MapSerializer" title="IO.binarySerializer.MapSerializer"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">binarySerializer.MapSerializer</span></code></a> for details of the binary
format for map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.MapDeserializer.readKey">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">keyType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">keyType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.MapDeserializer.readKey" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a key of type <code class="docutils literal notranslate"><span class="pre">keyType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">key</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">key</span></code> in-place as a key of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.MapDeserializer.readValue">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">valType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">valType</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.MapDeserializer.readValue" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a value of type <code class="docutils literal notranslate"><span class="pre">valType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">value</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">value</span></code> in-place as a value of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.MapDeserializer.endMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.MapDeserializer.endMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current map.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">BadFormatError</span></code></a> if there are entries remaining.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.MapDeserializer.hasMore">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.binaryDeserializer.MapDeserializer.hasMore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Behavior of ‘hasMore’ is undefined when called between <a class="reference internal" href="#IO.binaryDeserializer.MapDeserializer.readKey" title="IO.binaryDeserializer.MapDeserializer.readKey"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readKey</span></code></a>
and <a class="reference internal" href="#IO.binaryDeserializer.MapDeserializer.readValue" title="IO.binaryDeserializer.MapDeserializer.readValue"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readValue</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.withDeserializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">withDeserializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(this.locking,</span> <span class="pre">deserializerType)</span></em><a class="headerlink" href="#IO.fileReader.withDeserializer" title="Link to this definition">¶</a></dt>
<dd><p>Create and return an alias of this <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> configured to use
<code class="docutils literal notranslate"><span class="pre">deserializerType</span></code> for deserialization. The provided <code class="docutils literal notranslate"><span class="pre">deserializerType</span></code>
must be able to be default-initialized.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">withDeserializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(this.locking,</span> <span class="pre">dt)</span></em></dt>
<dd><p>Create and return an alias of this <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> configured to use
<code class="docutils literal notranslate"><span class="pre">deserializer</span></code> for deserialization.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.withSerializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">withSerializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">serializerType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileWriter(this.locking,</span> <span class="pre">serializerType)</span></em><a class="headerlink" href="#IO.fileWriter.withSerializer" title="Link to this definition">¶</a></dt>
<dd><p>Create and return an alias of this <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> configured to use
<code class="docutils literal notranslate"><span class="pre">serializerType</span></code> for serialization. The provided <code class="docutils literal notranslate"><span class="pre">serializerType</span></code> must be
able to be default-initialized.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">withSerializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileWriter(this.locking,</span> <span class="pre">st)</span></em></dt>
<dd><p>Create and return an alias of this <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> configured to use
<code class="docutils literal notranslate"><span class="pre">serializer</span></code> for serialization.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.lock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.lock" title="Link to this definition">¶</a></dt>
<dd><p>Acquire a fileReader’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the lock could not be acquired.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.lock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.lock" title="Link to this definition">¶</a></dt>
<dd><p>Acquire a fileWriter’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the lock could not be acquired.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.unlock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">unlock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.unlock" title="Link to this definition">¶</a></dt>
<dd><p>Release a fileReader’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.unlock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">unlock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.unlock" title="Link to this definition">¶</a></dt>
<dd><p>Release a fileWriter’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.offset">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int(64)</span></em><a class="headerlink" href="#IO.fileReader.offset" title="Link to this definition">¶</a></dt>
<dd><p>Return the current offset of a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>.</p>
<p>If the fileReader can be used by multiple tasks, take care when doing
operations that rely on the fileReader’s current offset. To prevent race
conditions, lock the fileReader with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lock</span></code></a> before calling
<a class="reference internal" href="#IO.fileReader.offset" title="IO.fileReader.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.offset</span></code></a>, then unlock it afterwards with
<a class="reference internal" href="#IO.fileReader.unlock" title="IO.fileReader.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.unlock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the current offset of the fileReader</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.offset">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int(64)</span></em><a class="headerlink" href="#IO.fileWriter.offset" title="Link to this definition">¶</a></dt>
<dd><p>Return the current offset of a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>.</p>
<p>If the fileWriter can be used by multiple tasks, take care when doing
operations that rely on the fileWriter’s current offset. To prevent race
conditions, lock the fileWriter with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a> before calling
<a class="reference internal" href="#IO.fileWriter.offset" title="IO.fileWriter.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.offset</span></code></a>, then unlock it afterwards with
<a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the current offset of the fileWriter</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.advance">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">advance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">amount:</span> <span class="pre">int(64)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.advance" title="Link to this definition">¶</a></dt>
<dd><p>Move a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> offset forward.</p>
<p>This routine will consume the next <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes from the file, storing
them in the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s buffer. This can be useful for advancing to some
known offset in the file before reading.</p>
<p>Note that calling <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a> before advancing will cause at
least <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes to be retained in memory until
<a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a> are called. As such,
it is typical to advance by a small number of bytes during an I/O transaction.</p>
<p>To make large adjustments to the offset, consider creating a new
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or using <a class="reference internal" href="#IO.fileReader.seek" title="IO.fileReader.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">seek</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If EOF is reached before the requested number of bytes can
be consumed. The offset will be left at EOF.</p></li>
<li><p><strong>SystemError</strong> – For other failures, for which fileReader offset is not
moved.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.advance">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">advance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">amount:</span> <span class="pre">int(64)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.advance" title="Link to this definition">¶</a></dt>
<dd><p>Move a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> offset forward.</p>
<p>This routine will populate the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s buffer as the offset is moved
forward by <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes. The buffer can be populated with any of the
following data depending on the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s configuration and whether
it was marked before advancing:</p>
<ul class="simple">
<li><p>zeros</p></li>
<li><p>bytes directly from the file</p></li>
<li><p>bytes from a previously buffered portion of the file</p></li>
</ul>
<p>The contents of the buffer will subsequently be written to the file by the
buffering mechanism.</p>
<p>Note that calling <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a> before advancing will cause at
least <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes to be retained in memory until
<a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a> are called. As such,
it is typical to advance by a small number of bytes during an I/O transaction.</p>
<p>To make large adjustments to the offset, consider creating a new
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> or using <a class="reference internal" href="#IO.fileWriter.seek" title="IO.fileWriter.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">seek</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If EOF is reached before the offset can be advanced by the
requested number of bytes. The offset will be left at EOF.</p></li>
<li><p><strong>SystemError</strong> – For other failures, for which fileWriter offset is not
moved.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.advanceThrough">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">advanceThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.advanceThrough" title="Link to this definition">¶</a></dt>
<dd><p>Read until a separator is found, leaving the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> offset just
after it.</p>
<p>If the separator cannot be found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left at EOF
and an <code class="docutils literal notranslate"><span class="pre">UnexpectedEofError</span></code> is thrown.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation is faster for single-byte <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
separators.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>
or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the requested <code class="docutils literal notranslate"><span class="pre">separator</span></code> could not
be found.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">file</span></code>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.advanceTo">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">advanceTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.advanceTo" title="Link to this definition">¶</a></dt>
<dd><p>Read until a separator is found, leaving the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> offset just
before it.</p>
<p>If the separator cannot be found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left at EOF
and an <code class="docutils literal notranslate"><span class="pre">UnexpectedEofError</span></code> is thrown.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation is faster for single-byte <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
separators.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the requested <code class="docutils literal notranslate"><span class="pre">separator</span></code> could not be found.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.mark">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">mark</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.mark" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p><em>Mark</em> a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> - that is, save the current offset of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> on its <em>mark stack</em>.</p>
<p>The <em>mark stack</em> stores several file offsets. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> will keep
the region of the file between its minimum and maximum <em>mark stack</em> values
buffered in memory so that IO operations can be undone. As a result, it is
possible to perform <em>I/O transactions</em> on a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>. The basic steps
for an <em>I/O transaction</em> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>mark</em> the current offset with <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a></p></li>
<li><p>do something speculative (e.g. try to read 200 bytes of anything followed
by a ‘B’)</p></li>
<li><p>if the speculative operation was successful, commit the changes by
calling <a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.commit</span></code></a></p></li>
<li><p>if the speculative operation was not successful, go back to the <em>mark</em> by
calling <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.revert</span></code></a>. Subsequent I/O operations will work
as though nothing happened.</p></li>
</ul>
</div></blockquote>
<p>If a fileReader has <code class="docutils literal notranslate"><span class="pre">locking==true</span></code>, <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> should only
be called once it has been locked with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lock</span></code></a>. The
fileReader should not be unlocked with <a class="reference internal" href="#IO.fileReader.unlock" title="IO.fileReader.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.unlock</span></code></a> until
after the mark has been committed with <a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or reverted
with <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a>.</p>
<p>See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for more.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that it is possible to request an entire file be buffered in memory
using this feature, for example by <em>marking</em> at offset=0 and then
advancing to the end of the file. It is important to be aware of these
memory space requirements.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The offset that was marked</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – if marking the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> failed</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.mark">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">mark</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.mark" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p><em>Mark</em> a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> - that is, save the current offset of the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> on its <em>mark stack</em>.</p>
<p>The <em>mark stack</em> stores several file offsets. The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> will keep
the region of the file between its minimum and maximum <em>mark stack</em> values
buffered in memory so that IO operations can be undone. As a result, it
is possible to perform <em>I/O transactions</em> on a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>. The basic
steps for an <em>I/O transaction</em> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>mark</em> the current offset with <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a></p></li>
<li><p>do something speculative (e.g. try to write 200 bytes)</p></li>
<li><p>if the speculative operation was successful, commit the changes by
calling <a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.commit</span></code></a></p></li>
<li><p>if the speculative operation was not successful, go back to the <em>mark</em> by
calling <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.revert</span></code></a>. Subsequent I/O operations will work
as though nothing happened.</p></li>
</ul>
</div></blockquote>
<p>If a fileWriter has <code class="docutils literal notranslate"><span class="pre">locking==true</span></code>, <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> should only
be called once it has been locked with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a>. The
fileWriter should not be unlocked with <a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a> until
after the mark has been committed with <a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or reverted
with <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a>.</p>
<p>See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for more.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that it is possible to request an entire file be buffered in memory
using this feature, for example by <em>marking</em> at offset=0 and then
advancing to the end of the file. It is important to be aware of these
memory space requirements.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The offset that was marked</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – if marking the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> failed</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.revert">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">revert</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.revert" title="Link to this definition">¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s <em>mark stack</em>
and adjusting its position to that offset. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileReader that has already
been marked. If called on a fileReader with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileReader
should have already been locked manually with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.revert">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">revert</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.revert" title="Link to this definition">¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s <em>mark stack</em>
and adjusting its position to that offset. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileWriter that has already
been marked. If called on a fileWriter with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileWriter
should have already been locked manually with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.commit">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.commit" title="Link to this definition">¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s <em>mark stack</em>
and leaving its position in the file unchanged. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileReader that has already
been marked. If called on a fileReader with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileReader
should have already been locked manually with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.commit">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.commit" title="Link to this definition">¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s <em>mark stack</em>
and leaving its position in the file unchanged. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileWriter that has already
been marked. If called on a fileWriter with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileWriter
should have already been locked manually with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.seek">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">seek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.seek" title="Link to this definition">¶</a></dt>
<dd><p>Adjust a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>’s region. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s buffer will be
discarded.</p>
<p>This routine has the following constraints:</p>
<blockquote>
<div><ul class="simple">
<li><p>the underlying file must be seekable (sockets and pipes are not seekable)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> must be non-locking (to avoid race conditions if two
tasks seek and read simultaneously)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> must not be marked (see: <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset needs to be updated during an I/O transaction
or if discarding the buffer will incur a performance penalty, consider using
<a class="reference internal" href="#IO.fileReader.advance" title="IO.fileReader.advance"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.advance</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>region</strong> – the new region, measured in bytes and counting from 0. An upper
bound can be omitted (e.g., <code class="docutils literal notranslate"><span class="pre">r.seek(range=42..)</span></code>). See
<a class="reference internal" href="#filereader-filewriter-regions"><span class="std std-ref">region</span></a> for more.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – if seeking failed. Possible reasons include
that the file is not seekable, or that the
fileReader is marked.</p></li>
<li><p><strong>IllegalArgumentError</strong> – if region argument did not have a lower bound</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.seek">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">seek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.seek" title="Link to this definition">¶</a></dt>
<dd><p>Adjust a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>’s region. The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s buffer will be
discarded.</p>
<p>This routine has the following constraints:</p>
<blockquote>
<div><ul class="simple">
<li><p>the underlying file must be seekable (sockets and pipes are not seekable)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> must be non-locking (to avoid race conditions if two
tasks seek and read simultaneously)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> must not be marked (see: <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset needs to be updated during an I/O transaction
or if discarding the buffer will incur a performance penalty, consider using
<a class="reference internal" href="#IO.fileWriter.advance" title="IO.fileWriter.advance"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.advance</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>region</strong> – the new region, measured in bytes and counting from 0. An upper
bound can be omitted (e.g., <code class="docutils literal notranslate"><span class="pre">w.seek(range=42..)</span></code>). See
<a class="reference internal" href="#filereader-filewriter-regions"><span class="std std-ref">region</span></a> for more.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – if seeking failed. Possible reasons include
that the file is not seekable, or that the
fileReader is marked.</p></li>
<li><p><strong>IllegalArgumentError</strong> – if region argument did not have a lower bound</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readWriteThisFromLocale">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readWriteThisFromLocale</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.readWriteThisFromLocale" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readWriteThisFromLocale’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Return the locale on which an ongoing I/O was started with a fileReader.
This method will return <code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> unless it is called on a fileReader
that is the formal argument to a <cite>readThis</cite> method.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.readWriteThisFromLocale">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">readWriteThisFromLocale</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.readWriteThisFromLocale" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readWriteThisFromLocale’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Return the locale on which an ongoing I/O was started with a fileWriter.
This method will return <code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> unless it is called on a fileWriter
that is the formal argument to a <cite>writeThis</cite> method.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.OpenReaderLockingDefault">
<em class="property"><span class="pre">config</span> <span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">OpenReaderLockingDefault</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">true</span></em><a class="headerlink" href="#IO.OpenReaderLockingDefault" title="Link to this definition">¶</a></dt>
<dd><p>Controls the default value of the <code class="docutils literal notranslate"><span class="pre">locking</span></code> parameter for <a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">true</span></code>, a warning will be issued if <code class="docutils literal notranslate"><span class="pre">locking</span></code> is not set explicitly.
When <code class="docutils literal notranslate"><span class="pre">false</span></code>, the new default value of <code class="docutils literal notranslate"><span class="pre">false</span></code> will be used.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openReader">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(locking,</span> <span class="pre">dt)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.openReader" title="Link to this definition">¶</a></dt>
<dd><p>Open a file at a particular path and return a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> and then
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> on the resulting file.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – which file to open (for example, “some/file.txt”).</p></li>
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileReader should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type.
Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code> (<em>default deprecated, see warning below</em>).</p></li>
<li><p><strong>region</strong> – zero-based byte offset indicating where in the file the
fileReader should start and stop reading. Defaults to
<code class="docutils literal notranslate"><span class="pre">0..</span></code>, meaning from the start of the file to no specified end
point.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
<li><p><strong>deserializer</strong> – deserializer to use when reading.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an open fileReader to the requested resource.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default value for <code class="docutils literal notranslate"><span class="pre">locking</span></code> will change from <code class="docutils literal notranslate"><span class="pre">true</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code>
in an upcoming release. To avoid the warning, specify the value
of <code class="docutils literal notranslate"><span class="pre">locking</span></code> explicitly, or compile with <code class="docutils literal notranslate"><span class="pre">-sOpenReaderLockingDefault=false</span></code>
to use the new default.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">locking=true</span></code> should only be used when a fileReader will be
used by multiple tasks concurrently.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If part of the provided path did not exist</p></li>
<li><p><strong>PermissionError</strong> – If part of the provided path had inappropriate
permissions</p></li>
<li><p><strong>NotADirectoryError</strong> – If part of the provided path was expected to
be a directory but was not</p></li>
<li><p><strong>SystemError</strong> – If a fileReader could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If trying to read explicitly prior to byte
0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openStringReader">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openStringReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(false,</span> <span class="pre">dt)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.openStringReader" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘openStringReader’ is an experimental feature; its name and behavior are subject to change</p>
</div>
<p>Create a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> around a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a></p>
<p>Note that the string is copied into a local memory file, so it can be modified
after the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is created without affecting the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to read from</p></li>
<li><p><strong>deserializer</strong> – deserializer to use when reading.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> reading from the string</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openBytesReader">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openBytesReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(false,</span> <span class="pre">dt)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.openBytesReader" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘openBytesReader’ is an experimental feature; its name and behavior are subject to change</p>
</div>
<p>Create a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> around a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a></p>
<p>Note that the bytes is copied into a local memory file, so it can be modified
after the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is created without affecting the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to read from</p></li>
<li><p><strong>deserializer</strong> – deserializer to use when reading.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> reading from the string</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.OpenWriterLockingDefault">
<em class="property"><span class="pre">config</span> <span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">OpenWriterLockingDefault</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">true</span></em><a class="headerlink" href="#IO.OpenWriterLockingDefault" title="Link to this definition">¶</a></dt>
<dd><p>Controls the default value of the <code class="docutils literal notranslate"><span class="pre">locking</span></code> parameter for <a class="reference internal" href="#IO.openWriter" title="IO.openWriter"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openWriter</span></code></a>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">true</span></code>, a warning will be issued if <code class="docutils literal notranslate"><span class="pre">locking</span></code> is not set explicitly.
When <code class="docutils literal notranslate"><span class="pre">false</span></code>, the new default value of <code class="docutils literal notranslate"><span class="pre">false</span></code> will be used.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openWriter">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(true)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileWriter(locking,</span> <span class="pre">st)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.openWriter" title="Link to this definition">¶</a></dt>
<dd><p>Open a file at a particular path and return a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> with <code class="docutils literal notranslate"><span class="pre">ioMode.cwr</span></code> and then
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> on the resulting file.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – which file to open (for example, “some/file.txt”).</p></li>
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileWriter should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type.
Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code> (<em>default deprecated, see warning below</em>).</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
<li><p><strong>serializer</strong> – serializer to use when writing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an open fileWriter to the requested resource.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default value for <code class="docutils literal notranslate"><span class="pre">locking</span></code> will change from <code class="docutils literal notranslate"><span class="pre">true</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code>
in an upcoming release. To avoid the warning, specify the value
of <code class="docutils literal notranslate"><span class="pre">locking</span></code> explicitly, or compile with <code class="docutils literal notranslate"><span class="pre">-sOpenWriterLockingDefault=false</span></code>
to use the new default.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">locking=true</span></code> should only be used when a fileWriter will be
used by multiple tasks concurrently.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If part of the provided path did not exist</p></li>
<li><p><strong>PermissionError</strong> – If part of the provided path had inappropriate
permissions</p></li>
<li><p><strong>NotADirectoryError</strong> – If part of the provided path was expected to
be a directory but was not</p></li>
<li><p><strong>SystemError</strong> – If a fileWriter could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If trying to write explicitly prior to byte
0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.reader">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(locking,</span> <span class="pre">dt)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.reader" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> that supports reading from a file. See
<a class="reference internal" href="#about-io-overview"><span class="std std-ref">I/O Overview</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">region=</span></code> argument defines the portion of the file that the fileReader
will read from.  This is a byte offset; the beginning of the file is at the
offset 0.  The default for this argument enables the fileReader to access the
entire file.</p>
<p>A fileReader will never read beyond its maximum end offset. In addition,
reading from a fileReader beyond the end of the underlying file will not
extend that file.  Reading beyond the end of the file or beyond the end
offset of the fileReader will produce the error <code class="docutils literal notranslate"><span class="pre">OS.EofError</span></code> (or just
return <cite>false</cite> in many cases such as <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a>) to indicate
that the end was reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileReader should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type.
Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code> (<em>default deprecated, see warning below</em>).</p></li>
<li><p><strong>region</strong> – zero-based byte offset indicating where in the file the
fileReader should start and stop reading. Defaults to
<code class="docutils literal notranslate"><span class="pre">0..</span></code> - meaning from the start of the file to no end point.</p></li>
<li><p><strong>hints</strong> – provide hints about the I/O that this fileReader will perform.
See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>. The default value of <cite>ioHintSet.empty</cite>
will cause the fileReader to use the hints provided when the
file was opened.</p></li>
<li><p><strong>deserializer</strong> – deserializer to use when reading.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default value for <code class="docutils literal notranslate"><span class="pre">locking</span></code> will be removed in an upcoming release.
To avoid the warning, specify the value of <code class="docutils literal notranslate"><span class="pre">locking</span></code> explicitly.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">locking=true</span></code> should only be used when a fileReader will be
used by multiple tasks concurrently.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – If a fileReader could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If trying to read explicitly prior to
byte 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.writer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(true)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fileWriter(locking,</span> <span class="pre">st)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.file.writer" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> that supports writing to a file. See
<a class="reference internal" href="#about-io-overview"><span class="std std-ref">I/O Overview</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">region=</span></code> argument defines the portion of the file that the fileWriter
will write to.  This is a byte offset; the beginning of the file is at the
offset 0.  The default for this argument enables the fileWriter to access the
entire file.</p>
<p>When a fileWriter writes to a file, it will replace file data that was
previously stored at the relevant offset. If the offset is beyond the
end of the file, the file will be extended.</p>
<p>A fileWriter will never write beyond its maximum end offset.  It will
extend the file only as necessary to store data written to the fileWriter. In
other words, specifying the high bound of the region argument here does not
impact the file size directly; it impacts only the section of the file that
this fileWriter can write to. After all fileWriters to a file are closed,
that file will have a size equal to the last offset written to by any
fileWriter.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileWriter should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type.
Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code> (<em>default deprecated, see warning below</em>).</p></li>
<li><p><strong>region</strong> – zero-based byte offset indicating where in the file the
fileWriter should start and stop writing. Defaults to
<code class="docutils literal notranslate"><span class="pre">0..</span></code> - meaning from the start of the file to no specified end
point.</p></li>
<li><p><strong>hints</strong> – provide hints about the I/O that this fileWriter will perform.
See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>. The default value of <cite>ioHintSet.empty</cite>
will cause the fileWriter to use the hints provided when the
file was opened.</p></li>
<li><p><strong>serializer</strong> – serializer to use when writing.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default value for <code class="docutils literal notranslate"><span class="pre">locking</span></code> will be removed in an upcoming release.
To avoid the warning, specify the value of <code class="docutils literal notranslate"><span class="pre">locking</span></code> explicitly.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">locking=true</span></code> should only be used when a fileWriter will be
used by multiple tasks concurrently.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – If a fileWriter could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If trying to write explicitly prior to
byte 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readLiteral" title="Link to this definition">¶</a></dt>
<dd><p>Advances the offset of a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> within the file by reading the
exact text of the given string <code class="docutils literal notranslate"><span class="pre">literal</span></code> from the fileReader.</p>
<p>If the string is not matched exactly, then the fileReader’s offset is
unchanged. In such cases a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> will be thrown, unless
the end of the fileReader is encountered in which case an <a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>
will be thrown.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the string to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>BadFormatError</strong> – If literal could not be matched.</p></li>
<li><p><strong>EofError</strong> – If end of fileReader is encountered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em></dt>
<dd><p>Advances the offset of a fileReader by reading the exact bytes of the given
<code class="docutils literal notranslate"><span class="pre">literal</span></code> from the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>.</p>
<p>If the bytes are not matched exactly, then the fileReader’s offset is
unchanged. In such cases a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> will be thrown, unless
the end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered in which case an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a> will be thrown.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the bytes to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>BadFormatError</strong> – If literal could not be matched.</p></li>
<li><p><strong>EofError</strong> – If end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readNewline" title="Link to this definition">¶</a></dt>
<dd><p>Advances the offset of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> by reading a newline.</p>
<p>If a newline is not matched exactly, then the fileReader’s offset is
unchanged. In such cases a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> will be thrown, unless
the end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered in which case an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a> will be thrown. By default this method will ignore
leading whitespace when attempting to read a newline.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – If a newline could not be matched.</p></li>
<li><p><strong>EofError</strong> – If end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.matchLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">matchLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.matchLiteral" title="Link to this definition">¶</a></dt>
<dd><p>Advances the offset of a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> by reading the exact text of the
given string <code class="docutils literal notranslate"><span class="pre">literal</span></code> from the fileReader.</p>
<p>If the string is not matched exactly, then the fileReader’s offset is
unchanged and this method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>. In other words, this
fileReader will return <code class="docutils literal notranslate"><span class="pre">false</span></code> in the cases where
<a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a> would throw a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> or an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the string to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the read succeeded, and <code class="docutils literal notranslate"><span class="pre">false</span></code> on end of file or if
the literal could not be matched.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">matchLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Advances the offset of a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> by reading the exact bytes of
the given <code class="docutils literal notranslate"><span class="pre">literal</span></code> from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
<p>If the bytes are not matched exactly, then the fileReader’s offset is
unchanged and this method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>. In other words, this
fileReader will return <code class="docutils literal notranslate"><span class="pre">false</span></code> in the cases where
<a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a> would throw a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> or an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the bytes to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the read succeeded, and <code class="docutils literal notranslate"><span class="pre">false</span></code> on end of file or if
the literal could not be matched.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.matchNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">matchNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.matchNewline" title="Link to this definition">¶</a></dt>
<dd><p>Advances the offset of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> by reading a newline.</p>
<p>If a newline is not matched exactly, then the fileReader’s offset is
unchanged and this method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>. In other words, this
fileReader will return <code class="docutils literal notranslate"><span class="pre">false</span></code> in the cases where
<a class="reference internal" href="#IO.fileReader.readNewline" title="IO.fileReader.readNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readNewline</span></code></a> would throw a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> or an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>.</p>
<p>By default this method will ignore leading whitespace when attempting to
read a newline.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the read succeeded, and <code class="docutils literal notranslate"><span class="pre">false</span></code> on end of file or if
the newline could not be matched.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeLiteral" title="Link to this definition">¶</a></dt>
<dd><p>Writes a string to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>, ignoring any formatting
configured for this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">bytes</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em></dt>
<dd><p>Writes bytes to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>, ignoring any formatting configured
for this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeNewline" title="Link to this definition">¶</a></dt>
<dd><p>Writes a newline to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>, ignoring any formatting
configured for this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="IO.fileReader.lines">
<em class="property"><span class="pre">iter</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">lines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.lines" title="Link to this definition">¶</a></dt>
<dd><p>Iterate over all of the lines ending in <code class="docutils literal notranslate"><span class="pre">\n</span></code> in a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> - the
fileReader lock will be held while iterating over the lines.</p>
<p>Only serial iteration is supported. This iterator will halt on internal
system errors.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This iterator executes on the current locale. This may impact multilocale
performance if the current locale is not the same locale on which the
fileReader was created.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line. Defaults to false</p>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p>lines from the fileReader, by default with a trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.read">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.read" title="Link to this definition">¶</a></dt>
<dd><p>Read one or more values from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s
lock will be held while reading the values — this protects against
interleaved reads.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> – a series of variables to read into. Basic types are handled
internally, but for other types this function will call
value.deserialize() with a <cite>fileReader</cite> argument as described
in <a class="reference internal" href="#serialize-deserialize"><span class="std std-ref">The ‘serialize’ and ‘deserialize’ Methods</span></a>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>true</cite> if the read succeeded, and <cite>false</cite> on end of file.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – If an EOF occurred while reading an item.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
for <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">another reason</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readLine">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">a:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">a.size</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(t</span> <span class="pre">==</span> <span class="pre">uint(8)</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">int(8))</span></em><a class="headerlink" href="#IO.fileReader.readLine" title="Link to this definition">¶</a></dt>
<dd><p>Read a line into an array of bytes.</p>
<p>Reads bytes from the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached. Values
are read in binary format (i.e., this method is not aware of UTF-8 encoding).</p>
<p>The array’s size is not changed to accommodate bytes. If a newline is not
found before the array is filled, or <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes are read, a
<a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">BadFormatError</span></code></a> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is
returned to the position it had when this routine was called.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A 1D DefaultRectangular non-strided array storing <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> or
<code class="docutils literal notranslate"><span class="pre">uint(8)</span></code>. Values are overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to store into the <code class="docutils literal notranslate"><span class="pre">a</span></code> array.
Defaults to the size of the array.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line. If
<code class="docutils literal notranslate"><span class="pre">true</span></code>, the newline isn’t counted in the number of
bytes read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of array elements set by this call, or <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise
(i.e., the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If <code class="docutils literal notranslate"><span class="pre">maxSize</span> <span class="pre">&gt;</span> <span class="pre">a.size</span></code></p></li>
<li><p><strong>BadFormatError</strong> – If the line is longer than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>. The
fileReader’s offset is not moved in that case.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a line into a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents are overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to store into <code class="docutils literal notranslate"><span class="pre">s</span></code>. The
default of -1 means to read an unlimited number of codepoints.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if a line was read without error, <code class="docutils literal notranslate"><span class="pre">false</span></code> upon EOF</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – If the line is longer than <cite>maxSize</cite>. The
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a line into a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to receive the line. Contents are overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to store into <code class="docutils literal notranslate"><span class="pre">b</span></code>. The default of
-1 means to read an unlimited number of bytes.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if a line was read without error, <code class="docutils literal notranslate"><span class="pre">false</span></code> upon EOF</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – If the line is longer than <cite>maxSize</cite>. The file
offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em></dt>
<dd><p>Read a line. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – the type of data to read, which must be <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>. Defaults to <code class="docutils literal notranslate"><span class="pre">string</span></code> if not specified.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. The default of -1
means to read an unlimited number of codepoints.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> up to (and possibly including) the newline.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – If the line is longer than <cite>maxSize</cite>. The file
offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readThrough">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.readThrough" title="Link to this definition">¶</a></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> through that point.</p>
<p>If the separator is found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left immediately
after it. If the separator could not be found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes,
a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">BadFormatError</span></code></a> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s offset is not
changed. Otherwise, if EOF is reached before finding the separator, the
remainder of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s contents are returned and the offset is
left at EOF.</p>
<p>To match with multiple separators, or a more complex separator, use the
overload of <a class="reference internal" href="Regex.html#Regex.fileReader.readThrough" title="Regex.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readThrough</span></code></a> that accepts a
<a class="reference internal" href="Regex.html#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>
or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes (for t==bytes) or codepoints (for
t==string) to read. For the default value of
<code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned
<code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>. If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the returned
value will not include the separator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
up to (and possibly including) the separator.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>EofError</strong> – If nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – If the separator was not found in the next
<cite>maxSize</cite> bytes. The fileReader offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> through that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned <code class="docutils literal notranslate"><span class="pre">string</span></code>.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the separator will not be included in <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>BadFormatError</strong> – If the separator was not found in the next
<cite>maxSize</cite> bytes. The fileReader offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> through that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>b</strong> – The <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the separator will not be included in <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>BadFormatError</strong> – If the separator was not found in the next
<code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes. The fileReader offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readTo">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.readTo" title="Link to this definition">¶</a></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> up to that point.</p>
<p>If the separator is found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left immediately
before it. If the separator could not be found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes,
a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">BadFormatError</span></code></a> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s offset is not
changed. Otherwise, if EOF is reached before finding the separator, the
remainder of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s contents are returned and the offset is
left at EOF.</p>
<p>To match with multiple separators, or a more complex separator, use the
overload of <a class="reference internal" href="Regex.html#Regex.fileReader.readTo" title="Regex.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readTo</span></code></a> that accepts a
<a class="reference internal" href="Regex.html#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>
or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes (for t==bytes) or codepoints (for
t==string) to read. For the default
value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
up to the <code class="docutils literal notranslate"><span class="pre">separator</span></code>.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>EofError</strong> – If nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – If the separator was not found in the next
<code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not
moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> up to that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readTo" title="IO.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method will read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>BadFormatError</strong> – If the separator was not found in the next
<cite>maxSize</cite> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not
moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> up to that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readTo" title="IO.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>b</strong> – The <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method will read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – If the separator is empty</p></li>
<li><p><strong>BadFormatError</strong> – If the separator was not found in the next
<code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not
moved.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset is not moved
by this routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readAll">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">bytes</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.readAll" title="Link to this definition">¶</a></dt>
<dd><p>Read the remaining contents of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into an instance of
the specified type</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> – the type to read into; must be <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>. Defaults to <code class="docutils literal notranslate"><span class="pre">bytes</span></code> if not specified.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> as a <code class="docutils literal notranslate"><span class="pre">t</span></code></p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em></dt>
<dd><p>Read the remaining contents of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into a <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
<p>Note that any existing contents of the <code class="docutils literal notranslate"><span class="pre">string</span></code> are overwritten.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>s</strong> – the <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of codepoints that were stored in <code class="docutils literal notranslate"><span class="pre">s</span></code>, or 0 if
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is at EOF.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em></dt>
<dd><p>Read the remaining contents of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
<p>Note that any existing contents of the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> are overwritten.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>b</strong> – the <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of bytes that were stored in <code class="docutils literal notranslate"><span class="pre">b</span></code>, or 0 if
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is at EOF.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">a:</span> <span class="pre">[?d]</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(t</span> <span class="pre">==</span> <span class="pre">uint(8)</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">int(8))</span></em></dt>
<dd><p>Read the remaining contents of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into an array of
bytes.</p>
<p>Note that this routine currently requires a 1D rectangular non-strided array.</p>
<p>If the remaining contents of the fileReader exceed the size of <code class="docutils literal notranslate"><span class="pre">a</span></code>, the
first <code class="docutils literal notranslate"><span class="pre">a.size</span></code> bytes will be read into <code class="docutils literal notranslate"><span class="pre">a</span></code>, and then an
<a class="reference internal" href="OS.html#OS.InsufficientCapacityError" title="OS.InsufficientCapacityError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">InsufficientCapacityError</span></code></a> will be thrown. In such a case, the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is advanced <code class="docutils literal notranslate"><span class="pre">a.size</span></code> bytes from its original
position.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> – the array of bytes to read into</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of bytes that were stored in <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>InsufficientCapacityError</strong> – If the fileReader’s contents do not
fit into <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readString">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">string</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readString" title="Link to this definition">¶</a></dt>
<dd><p>Read a given number of codepoints from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>, returning a new
<a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">string</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached while
reading. If nothing is read, the empty string (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>maxSize</strong> – the maximum number of codepoints to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new <code class="docutils literal notranslate"><span class="pre">string</span></code> containing up to the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> codepoints
from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a given number of codepoints from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into a
<a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>.</p>
<p>The updated <code class="docutils literal notranslate"><span class="pre">string</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is
reached while reading. If nothing is read, it will be set to the empty
string (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to read into — contents will be overwritten</p></li>
<li><p><strong>maxSize</strong> – the maximum number of codepoints to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readBytes">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bytes</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readBytes" title="Link to this definition">¶</a></dt>
<dd><p>Read a given number of bytes from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>, returning a new
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bytes</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached while
reading. If nothing is read, the empty bytes (<code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>) will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>maxSize</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new <code class="docutils literal notranslate"><span class="pre">bytes</span></code> containing up to the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes
from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a given number of bytes from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into a
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>The updated <code class="docutils literal notranslate"><span class="pre">bytes</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is
reached while reading. If nothing is read, it will be set to the empty
bytes (<code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to read into — contents will be overwritten</p></li>
<li><p><strong>maxSize</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readBits">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">x:</span> <span class="pre">integral</span></em>, <em class="sig-param"><span class="pre">numBits:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readBits" title="Link to this definition">¶</a></dt>
<dd><p>Read bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – where to store the read bits. This value will have its <em>numBits</em>
least-significant bits set.</p></li>
<li><p><strong>numBits</strong> – how many bits to read</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the bits were read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered before <code class="docutils literal notranslate"><span class="pre">numBits</span></code>
could be read.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">resultType</span></em>, <em class="sig-param"><span class="pre">numBits:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">resultType</span> <span class="pre">throws</span></em></dt>
<dd><p>Read bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resultType</strong> – type of the value returned</p></li>
<li><p><strong>numBits</strong> – how many bits to read</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>bits read. This value will have its <em>numBits</em> least-significant
bits set</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered before <code class="docutils literal notranslate"><span class="pre">numBits</span></code>
could be read.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeBits">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x:</span> <span class="pre">integral</span></em>, <em class="sig-param"><span class="pre">numBits:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeBits" title="Link to this definition">¶</a></dt>
<dd><p>Write bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – a value containing <em>numBits</em> bits to write the least-significant bits</p></li>
<li><p><strong>numBits</strong> – how many bits to write</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If writing more bits than fit into <cite>x</cite>.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeCodepoint">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeCodepoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">codepoint:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeCodepoint" title="Link to this definition">¶</a></dt>
<dd><p>Write a single Unicode codepoint to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>codepoint</strong> – Unicode codepoint to write</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readCodepoint">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readCodepoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readCodepoint" title="Link to this definition">¶</a></dt>
<dd><p>Read a single Unicode codepoint from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Unicode codepoint read</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered while reading a
codepoint.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readCodepoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">codepoint:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a single Unicode codepoint from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>codepoint</strong> – where to store the read codepoint</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the codepoint was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered while reading a
codepoint.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeByte">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeByte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">byte:</span> <span class="pre">uint(8)</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeByte" title="Link to this definition">¶</a></dt>
<dd><p>Write a single byte to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>byte</strong> – the byte to write</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readByte">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readByte</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">uint(8)</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readByte" title="Link to this definition">¶</a></dt>
<dd><p>Read a single byte from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the byte read</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readByte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">byte:</span> <span class="pre">uint(8)</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a single byte from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>byte</strong> – where to store the read byte</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the byte was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.IOSkipBufferingForLargeOps">
<em class="property"><span class="pre">config</span> <span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">IOSkipBufferingForLargeOps</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">true</span></em><a class="headerlink" href="#IO.IOSkipBufferingForLargeOps" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>IOSkipBufferingForLargeOps is unstable and could change or be removed in the future</p>
</div>
<p>Controll whether large read/write operations can bypass the IO runtime’s
buffering mechanism.</p>
<p>This optimization is on by default as it can improve performance for large
operations where buffering doesn’t significantly reduce the number of system
I/O calls and thus adds unnecessary overhead.</p>
<p>To disable the optimization, compile with <code class="docutils literal notranslate"><span class="pre">-sIOSkipBufferingForLargeOps=false</span></code>.</p>
<p>Note that this flag controls an implementation-specific feature and
thus is not part of the Chapel language specification.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeString">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">s.size</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeString" title="Link to this definition">¶</a></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">size</span></code> codepoints from a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to a
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of codepoints to write from the <code class="docutils literal notranslate"><span class="pre">string</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">s.size</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeBytes">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">b.size</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeBytes" title="Link to this definition">¶</a></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes from a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of bytes to write from the <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">b.size</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeBinary">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(?t)</span></em>, <em class="sig-param"><span class="pre">numBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeBinary" title="Link to this definition">¶</a></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">numBytes</span></code> of data from a <a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to a
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<p>Note that native endianness is always used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">numBytes</span></code> is not evenly divisible by the size of <code class="docutils literal notranslate"><span class="pre">t</span></code>, the remaining
bytes will be ignored. For example, if the <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code>’s internal type is 4
bytes in length, and <code class="docutils literal notranslate"><span class="pre">numBytes=17</span></code>, only 16 bytes will be written.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method provides no protection against attempting to access invalid
memory</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to some valid memory</p></li>
<li><p><strong>numBytes</strong> – the number of bytes to write</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(void)</span></em>, <em class="sig-param"><span class="pre">numBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">numBytes</span></code> of data from a <code class="docutils literal notranslate"><span class="pre">CTypes.c_ptr(void)</span></code> to a
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<p>The data are written to the file one byte at a time.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method provides no protection against attempting to access invalid
memory</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <code class="docutils literal notranslate"><span class="pre">c_ptr(void)</span></code> to some valid memory</p></li>
<li><p><strong>numBytes</strong> – the number of bytes to write</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Write a binary number to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be written</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to write the number. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Write a binary number to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be written</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to write the number.</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">s.size</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Write a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> in binary format</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of codepoints to write from the <code class="docutils literal notranslate"><span class="pre">string</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">s.size</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">b.size</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Write a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> in binary format</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of bytes to write from the <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – If <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">b.size</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[?d]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Write an array of binary numbers to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<p>Note that this routine currently requires a local rectangular non-strided
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array of numbers to write to the fileWriter</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to read the numbers. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Write an array of binary numbers to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a></p>
<p>Note that this routine currently requires a local rectangular non-strided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array of numbers to write to the fileWriter</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to write the number.</p></li>
</ul>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readBinary">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readBinary" title="Link to this definition">¶</a></dt>
<dd><p>Read a binary number from the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be read</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to read the number. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the number was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered while reading the
number.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a binary number from the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be read</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to read the number.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the number was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered while reading the
number.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a specified number of codepoints into a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a></p>
<p>The resulting string <code class="docutils literal notranslate"><span class="pre">s</span></code> may be smaller than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached
before reading the specified number of codepoints. Additionally, if nothing is
read from the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>, <code class="docutils literal notranslate"><span class="pre">s</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> (the empty
string) and the method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method always uses UTF-8 encoding regardless of the fileReader’s
configuration</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the string to read into — this value is overwritten</p></li>
<li><p><strong>maxSize</strong> – the number of codepoints to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if some codepoints were read, or <code class="docutils literal notranslate"><span class="pre">false</span></code> on EOF</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Read a specified number of bytes into a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a></p>
<p>The bytes <code class="docutils literal notranslate"><span class="pre">b</span></code> may be smaller than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached before
reading the specified number of bytes. Additionally, if nothing is read from
the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>, <code class="docutils literal notranslate"><span class="pre">b</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code> (the empty bytes) and
the method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the bytes to read into — this value is overwritten</p></li>
<li><p><strong>maxSize</strong> – the number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if some bytes were read, or <code class="docutils literal notranslate"><span class="pre">false</span></code> on EOF</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[?d]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Read an array of binary numbers from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<p>Binary values of the type <code class="docutils literal notranslate"><span class="pre">data.eltType</span></code> are consumed from the fileReader
until <code class="docutils literal notranslate"><span class="pre">data</span></code> is full or EOF is reached.</p>
<p>Note that this routine currently requires a local rectangular non-strided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array to read into – existing values are overwritten.</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to read the numbers in. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of values that were read into the array. This can be
less than <code class="docutils literal notranslate"><span class="pre">data.size</span></code> if EOF was reached, or an error occurred,
before filling the array.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Read an array of binary numbers from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<p>Binary values of the type <code class="docutils literal notranslate"><span class="pre">data.eltType</span></code> are consumed from the fileReader
until <code class="docutils literal notranslate"><span class="pre">data</span></code> is full or EOF is reached.</p>
<p>Note that this routine currently requires a local rectangular non-strided
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array to read into – existing values are overwritten.</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to read the number.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of values that were read into the array. This can be
less than <code class="docutils literal notranslate"><span class="pre">data.size</span></code> if EOF was reached, or an error occurred,
before filling the array.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(?t)</span></em>, <em class="sig-param"><span class="pre">maxBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em></dt>
<dd><p>Read up to <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> bytes from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into a
<a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a></p>
<p>Note that native endianness is always used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> is not evenly divisible by the size of <code class="docutils literal notranslate"><span class="pre">t</span></code>, then the
remaining bytes are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to some memory — existing values will be
overwritten</p></li>
<li><p><strong>maxBytes</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of bytes that were read. this can be less than
<code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> if EOF was reached before reading the specified
number of bytes, or if <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> is not evenly divisible by
the size of <code class="docutils literal notranslate"><span class="pre">t</span></code></p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(void)</span></em>, <em class="sig-param"><span class="pre">maxBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em></dt>
<dd><p>Read up to <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> bytes from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> into a
<code class="docutils literal notranslate"><span class="pre">CTypes.c_ptr(void)</span></code></p>
<p>Note that data are read from the file one byte at a time.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <code class="docutils literal notranslate"><span class="pre">c_ptr(void)</span></code> to some memory — existing
values will be overwritten</p></li>
<li><p><strong>maxBytes</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of bytes that were read. this can be less than
<code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> if EOF was reached before reading the specified number
of bytes</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.
In that event, the fileReader’s offset will be
left near the position where the error occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.readln" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Read values from a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and then consume any bytes until
newline is reached. The input will be consumed atomically - the
fileReader lock will be held while reading all of the passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> – a list of arguments to read. This routine can be called
with zero or more such arguments. Basic types are handled
internally, but for other types this function will call
value.deserialize() with a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> argument as described
in <a class="reference internal" href="#serialize-deserialize"><span class="std std-ref">The ‘serialize’ and ‘deserialize’ Methods</span></a>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>true</cite> if the read succeeded, and <cite>false</cite> upon end of file.</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered before data could
be read.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Read a value of passed type.</p>
<p>For example, the following line of code reads a value of type <cite>int</cite>
from <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a> and uses it to initialize a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> – the type to read</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value read</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered before data could
be fully read.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Read a value of passed type followed by a newline.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> – the type to read</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value read</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> is at already EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered before data could
be fully read.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">numTypes</span> <span class="pre">&gt;</span> <span class="pre">1</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Read values of passed types followed by a newline
and return a tuple containing the read values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> – more than one type to read</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple of the read values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered before data could
be fully read.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">numTypes</span> <span class="pre">&gt;</span> <span class="pre">1</span></em></dt>
<dd><p>Read values of passed types and return a tuple containing the read values.
The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>’s lock will be held while reading — this protects
against interleaved reads.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> – more than one type to read</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple of the read values</p>
</dd>
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF was encountered while more data was
expected.</p></li>
<li><p><strong>SystemError</strong> – If data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.write">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.write" title="Link to this definition">¶</a></dt>
<dd><p>Write values to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>. The output will be produced
atomically - the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> lock will be held while writing all of the
passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> – a list of arguments to write. Basic types are handled
internally, but for other types this function will call
value.serialize() with the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> as an argument.</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If EOF is reached before all the arguments could be
written.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF is encountered while writing one of
the arguments.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.writeln" title="Link to this definition">¶</a></dt>
<dd><p>Write values to a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> followed by a newline.  The output
will be produced atomically - the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> lock will be held while
writing all of the passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> – a variable number of arguments to write. This method can be
called with zero or more arguments. Basic types are handled
internally, but for other types this function will call
value.serialize() with the fileWriter as an argument.</p>
</dd>
<dt class="field-even">Throws<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – If EOF is reached before all the arguments
could be written.</p></li>
<li><p><strong>UnexpectedEofError</strong> – If EOF is encountered while writing one of
the arguments.</p></li>
<li><p><strong>SystemError</strong> – If data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.flush">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.flush" title="Link to this definition">¶</a></dt>
<dd><p>Makes all writes to the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>, if any, available to concurrent
viewers of its associated file, such as other fileWriters/fileReader or other
applications accessing this file concurrently.</p>
<p>Unlike <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a>, this does not commit the written data
to the file’s device.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the flush fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.assertEOF">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">assertEOF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">errStr:</span> <span class="pre">string</span> <span class="pre">=</span> <span class="pre">&quot;-</span> <span class="pre">Not</span> <span class="pre">at</span> <span class="pre">EOF&quot;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.assertEOF" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘assertEOF’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Assert that a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> has reached end-of-file and that there was
no error doing the read.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.close">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileReader.close" title="Link to this definition">¶</a></dt>
<dd><p>Close a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is not successfully closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.close">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#IO.fileWriter.close" title="Link to this definition">¶</a></dt>
<dd><p>Close a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>. Implicitly performs the <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a>
operation (see <a class="reference internal" href="#about-io-filereader-filewriter-synchronization"><span class="std std-ref">Synchronization of fileReader and fileWriter Data and Avoiding Data Races</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Throws<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SystemError</strong> – If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is not successfully closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.isClosed">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">isClosed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#IO.fileReader.isClosed" title="Link to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> is currently closed.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.isClosed">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">isClosed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#IO.fileWriter.isClosed" title="Link to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> is currently closed.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.stdin">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">stdin</span></span><em class="property"> <span class="pre">:</span> <span class="pre">fileReader(true)</span></em><a class="headerlink" href="#IO.stdin" title="Link to this definition">¶</a></dt>
<dd><p>A locking <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> instance that reads from standard input.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.stdout">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"> <span class="pre">:</span> <span class="pre">fileWriter(true)</span></em><a class="headerlink" href="#IO.stdout" title="Link to this definition">¶</a></dt>
<dd><p>A locking <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> instance that writes to standard output.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.stderr">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">stderr</span></span><em class="property"> <span class="pre">:</span> <span class="pre">fileWriter(true)</span></em><a class="headerlink" href="#IO.stderr" title="Link to this definition">¶</a></dt>
<dd><p>A locking <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> instance that writes to standard error.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.read">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?n</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.read" title="Link to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.read</span></code>. See <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.read</span></code>. See <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a> for types</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.readLine">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">a:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">a.size</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(t</span> <span class="pre">==</span> <span class="pre">uint(8)</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">int(8))</span></em><a class="headerlink" href="#IO.readLine" title="Link to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.readln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?n</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></em><a class="headerlink" href="#IO.readln" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readln</span></code>. See <a class="reference internal" href="#IO.fileReader.readln" title="IO.fileReader.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readln</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readln</span></code>. See <a class="reference internal" href="#IO.fileReader.readln" title="IO.fileReader.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readln</span></code></a> for types</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Types.html" class="btn btn-neutral float-left" title="Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="IO/FormattedIO.html" class="btn btn-neutral float-right" title="FormattedIO" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>