

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Domain Map Standard Interface &mdash; Chapel Documentation 1.13</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  

  
    <link rel="top" title="Chapel Documentation 1.13" href="../index.html"/>
        <link rel="up" title="Technical Notes" href="index.html"/>
        <link rel="next" title="C Interoperability" href="extern.html"/>
        <link rel="prev" title="Interactive Chapel" href="chpl-ipe.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Chapel Documentation
          

          
          </a>

          
            
            
          

          
<?php   // Variables given by sphinx 
   $chplTitle = "1.13";   $pagename = "./technotes/dsi";   include "../versionButton.php";   ?>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="allocators.html">Chapel's Use of Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="atomics.html">Runtime Support for Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="auxIO.html">Auxiliary I/O Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="chpl-ipe.html">Interactive Chapel</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Domain Map Standard Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#status-of-this-document">Status of this document</a></li>
<li class="toctree-l4"><a class="reference internal" href="#additional-resources">Additional Resources</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-1-the-essentials">Phase 1: The Essentials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-globaldistribution">class <code class="docutils literal"><span class="pre">GlobalDistribution</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-globaldomain">class <code class="docutils literal"><span class="pre">GlobalDomain</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-globalarray">class <code class="docutils literal"><span class="pre">GlobalArray</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#naming">Naming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#phase-2-additional-operations">Phase 2: Additional Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-3-privatization">Phase 3: Privatization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-privatization">What is privatization?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-does-privatization-work-with-dsi">How does privatization work with DSI?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-is-reprivatization">What is reprivatization?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dsi-privatization-requirements">DSI privatization requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tip-testing-privatization">Tip: testing privatization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tip-privatized-copies-should-reference-privatized-copies">Tip: privatized copies should reference privatized copies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation">Tip: &quot;privatize&quot; the domains and arrays used in the implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="extern.html">C Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="firstClassFns.html">First-class Functions in Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="libraries.html">Exporting Chapel as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="llvm.html">LLVM Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="local.html">The 'local' keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="localeModels.html">Locale Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="main.html">Support for main() Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_search.html">Module Search Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="reduceIntents.html">Reduce Intents</a></li>
<li class="toctree-l2"><a class="reference internal" href="sets.html">Associative Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="subquery.html">Querying a Local Subdomain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/builtins.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/modules.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Chapel Documentation 1.13</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Technical Notes</a> &raquo;</li>
      
    <li>Domain Map Standard Interface</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/technotes/dsi.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="domain-map-standard-interface">
<span id="readme-dsi"></span><h1><a class="toc-backref" href="#id1">Domain Map Standard Interface</a><a class="headerlink" href="#domain-map-standard-interface" title="Permalink to this headline">Â¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#domain-map-standard-interface" id="id1">Domain Map Standard Interface</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a><ul>
<li><a class="reference internal" href="#status-of-this-document" id="id3">Status of this document</a></li>
<li><a class="reference internal" href="#additional-resources" id="id4">Additional Resources</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview" id="id5">Overview</a></li>
<li><a class="reference internal" href="#phase-1-the-essentials" id="id6">Phase 1: The Essentials</a><ul>
<li><a class="reference internal" href="#class-globaldistribution" id="id7">class <code class="docutils literal"><span class="pre">GlobalDistribution</span></code></a></li>
<li><a class="reference internal" href="#class-globaldomain" id="id8">class <code class="docutils literal"><span class="pre">GlobalDomain</span></code></a><ul>
<li><a class="reference internal" href="#a-subdomain-description" id="id9">A. Subdomain Description</a></li>
<li><a class="reference internal" href="#b-follower-yield-order" id="id10">B. Follower Yield Order</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-globalarray" id="id11">class <code class="docutils literal"><span class="pre">GlobalArray</span></code></a></li>
<li><a class="reference internal" href="#naming" id="id12">Naming</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phase-2-additional-operations" id="id13">Phase 2: Additional Operations</a></li>
<li><a class="reference internal" href="#phase-3-privatization" id="id14">Phase 3: Privatization</a><ul>
<li><a class="reference internal" href="#what-is-privatization" id="id15">What is privatization?</a></li>
<li><a class="reference internal" href="#how-does-privatization-work-with-dsi" id="id16">How does privatization work with DSI?</a></li>
<li><a class="reference internal" href="#what-is-reprivatization" id="id17">What is reprivatization?</a></li>
<li><a class="reference internal" href="#dsi-privatization-requirements" id="id18">DSI privatization requirements</a></li>
<li><a class="reference internal" href="#tip-testing-privatization" id="id19">Tip: testing privatization</a></li>
<li><a class="reference internal" href="#tip-privatized-copies-should-reference-privatized-copies" id="id20">Tip: privatized copies should reference privatized copies</a></li>
<li><a class="reference internal" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation" id="id21">Tip: &quot;privatize&quot; the domains and arrays used in the implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">Â¶</a></h2>
<p>This document defines <strong>DSI</strong> -- the Domain map Standard Interface.
It is the interface that a domain map must implement.
This interface is currently in place and is implemented by the standard
domain maps provided with this Chapel distribution.</p>
<p>The specification is split into &quot;phases&quot;. The intention is to suggest
an implementation order. The requirements of first phase are relied
upon by the more essential operations on domains and arrays. Later
phases support additional functionality and/or improved performance.
The phasing is approximate and is not required.</p>
<div class="section" id="status-of-this-document">
<h3><a class="toc-backref" href="#id3">Status of this document</a><a class="headerlink" href="#status-of-this-document" title="Permalink to this headline">Â¶</a></h3>
<p>This document, as well as the DSI interface itself, are work in progress.
We solicit feedback on both.</p>
<p>The following aspects are not documented yet:</p>
<ul class="simple">
<li>a summary of the six descriptor classes</li>
<li>the requirements for a domain map to support
associative, opaque, or sparse domains;</li>
<li>the significance of dsiClone();</li>
<li>the &quot;local descriptor&quot; classes;</li>
<li>some required methods.</li>
</ul>
</div>
<div class="section" id="additional-resources">
<h3><a class="toc-backref" href="#id4">Additional Resources</a><a class="headerlink" href="#additional-resources" title="Permalink to this headline">Â¶</a></h3>
<p>Implementations of the standard domain maps may be consulted as
examples.  They are available in:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span>$CHPL_HOME/modules/dists
$CHPL_HOME/modules/layouts
</pre></div>
</div>
</div></blockquote>
<p>In addition, the following publication provide more background
information on domain maps in general.</p>
<ul>
<li><p class="first">&quot;User-Defined Distributions and Layouts in Chapel: Philosophy and
Framework.&quot; Bradford L. Chamberlain, Steven J. Deitz, David
Iten, Sung-Eun Choi. 2nd USENIX Workshop on Hot Topics in
Parallelism, June 2010.</p>
<blockquote>
<div><p>The high level motivation and overview of DSI.</p>
<p><a class="reference external" href="https://chapel-lang.org/publications/hotpar10-final.pdf">https://chapel-lang.org/publications/hotpar10-final.pdf</a></p>
</div></blockquote>
</li>
<li><p class="first">&quot;Authoring User-Defined Domain Maps in Chapel.&quot;  Bradford
L. Chamberlain, Sung-Eun Choi, Steven J. Deitz, David Iten, Vassily
Litvinov. CUG 2011, May 2011.</p>
<blockquote>
<div><p>A follow-on paper that outlines how to write a domain map.</p>
<p><a class="reference external" href="https://chapel-lang.org/publications/cug11-final.pdf">https://chapel-lang.org/publications/cug11-final.pdf</a></p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id5">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h2>
<p>A domain map must provide three (or more) &quot;global descriptor&quot; classes.
Here they are called <code class="docutils literal"><span class="pre">GlobalDistribution</span></code>, <code class="docutils literal"><span class="pre">GlobalDomain</span></code>,
and <code class="docutils literal"><span class="pre">GlobalArray</span></code>.
Their required fields and methods, as well as suggested naming,
are specified below.</p>
<p>A domain map is allowed to contain/provide features, data structures
and functionality (internally to facilitate implementation and/or
externally for users' benefit) beyond the DSI requirements.
For example, a distribution (i.e. a domain map that distributes data across
multiple locales) will typically define &quot;local descriptor&quot; classes as well.</p>
</div>
<div class="section" id="phase-1-the-essentials">
<h2><a class="toc-backref" href="#id6">Phase 1: The Essentials</a><a class="headerlink" href="#phase-1-the-essentials" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="class-globaldistribution">
<h3><a class="toc-backref" href="#id7">class <code class="docutils literal"><span class="pre">GlobalDistribution</span></code></a><a class="headerlink" href="#class-globaldistribution" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div>This class is visible to the users of the domain map: the <code class="docutils literal"><span class="pre">dmap</span></code> wrapper
in Chapel's <cite>dmapped</cite> clauses wraps instances of this class.
This class must be a subclass of <code class="docutils literal"><span class="pre">BaseDist</span></code>.</div></blockquote>
<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.GlobalDistribution() // or with arguments</code></dt>
<dd><p>Constructor(s)  These are not regulated by DSI - their specifics are
at the domain map implementor's discretion.</p>
<p>We suggest providing constructor(s) that accept, as an argument,
an array of locales over which to distribute, with <code class="docutils literal"><span class="pre">Locales</span></code>
as the default value.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiClone(): GlobalDistribution</code></dt>
<dd><p>Returns a duplicate of <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiDisplayRepresentation(): void</code></dt>
<dd><p>A debugging method. It implements displayRepresentation()
on the dmap wrapper.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiEqualDMaps(that: /*some other GlobalDistribution*/): bool</code></dt>
<dd><p>Return whether or not the two domain maps are &quot;equal&quot; (specify the
same distribution).  This is invoked when <code class="docutils literal"><span class="pre">==</span></code> is appled to two
domain maps.</p>
</dd></dl>

</div>
<div class="section" id="class-globaldomain">
<h3><a class="toc-backref" href="#id8">class <code class="docutils literal"><span class="pre">GlobalDomain</span></code></a><a class="headerlink" href="#class-globaldomain" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div><p>An instance of this class is created whenever a <code class="docutils literal"><span class="pre">GlobalDistribution</span></code>-mapped
Chapel domain is created (e.g. when a domain variable is declared).
There is a one-to-one correspondence at run time between a
(conceptual) Chapel domain value and an instance of <code class="docutils literal"><span class="pre">GlobalDomain</span></code>.
For presentation simplicity, <code class="docutils literal"><span class="pre">GlobalDomain</span></code>'s properties refer to
the properties of the corresponding Chapel domain value, when
clear from the context.</p>
<p>Depending on the domain kind, this class is returned by the following
method on <code class="docutils literal"><span class="pre">GlobalDistribution</span></code>
and must be a subclass of the following class:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="42%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">domain kind</th>
<th class="head">creating method</th>
<th class="head">required superclass</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rectangular</td>
<td><code class="docutils literal"><span class="pre">dsiNewRectangularDom</span></code></td>
<td><code class="docutils literal"><span class="pre">BaseRectangularDom</span></code></td>
</tr>
<tr class="row-odd"><td>associative</td>
<td><code class="docutils literal"><span class="pre">dsiNewAssociativeDom</span></code></td>
<td><code class="docutils literal"><span class="pre">BaseAssociativeDom</span></code></td>
</tr>
<tr class="row-even"><td>opaque</td>
<td><code class="docutils literal"><span class="pre">dsiNewOpaqueDom</span></code></td>
<td><code class="docutils literal"><span class="pre">BaseOpaqueDom</span></code></td>
</tr>
<tr class="row-odd"><td>sparse</td>
<td><code class="docutils literal"><span class="pre">dsiNewSparseDom</span></code></td>
<td><code class="docutils literal"><span class="pre">BaseSparseDom</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>It is legal for these methods to return instances of different classes
in different circumstances. (For example, due to the absence of multiple
inheritance, different domain kinds require different classes.)</p>
<p>The DSI requirements apply to each of those classes.
<code class="docutils literal"><span class="pre">GlobalDomain</span></code> is used in this document to refer to each such class.</p>
<p>The DSI requirements depend on the domain kind that is supported.
The following requirements apply when supporting rectangular domains.</p>
</div></blockquote>
<dl class="class">
<dt id="GlobalDomain">
<em class="property">class </em><code class="descname">GlobalDomain</code><a class="headerlink" href="#GlobalDomain" title="Permalink to this definition">Â¶</a></dt>
<dd><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="kd">param</span> <span class="nx">rank</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">idxType</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">stridable</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The fields <code class="docutils literal"><span class="pre">rank</span></code>, <code class="docutils literal"><span class="pre">idxType</span></code>, <code class="docutils literal"><span class="pre">stridable</span></code> are the attributes
of the corresponding Chapel domain. (They could be replaced with
parenthesesless functions of the same names and param/type intents.)</p>
<p>The field <code class="docutils literal"><span class="pre">dist</span></code> must contain a reference
to the <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> object
that created this <code class="docutils literal"><span class="pre">GlobalDomain</span></code>. It is used when creating the (runtime)
type for this domain, which contains the domain's domain map.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiMyDist() return dist;</code></dt>
<dd><p>Returns this domain's domain map. This procedure should be provided as shown.
(Exception: see <code class="docutils literal"><span class="pre">dsiLinksDistribution()</span></code>.)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiNewRectangularDom(param rank: int, type idxType, param stridable: bool) : GlobalDomain(rank, idxType, stridable)</code></dt>
<dd><p>This method is invoked when the Chapel program is creating an uninitialized
domain value of the type domain(rank, idxType, stridable)
mapped using the domain map <cite>this</cite>.</p>
<p>This method returns a new <code class="docutils literal"><span class="pre">GlobalDomain</span></code> instance that will correspond to
that Chapel domain value, i.e., be that value's runtime representation.
The field <code class="docutils literal"><span class="pre">dist</span></code> of the returned <code class="docutils literal"><span class="pre">GlobalDomain</span></code> must point to <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiGetIndices(): rank * range(idxType, BoundedRangeType.bounded, stridable)</code></dt>
<dd><p>Returns a tuple of ranges describing the dimensions of this domain.</p>
<p><code class="docutils literal"><span class="pre">dsiDims()</span></code> and <code class="docutils literal"><span class="pre">dsiGetIndices()</span></code> have the same specification
and so may be implemented in terms of one another.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiSetIndices(dom: domain(rank, idxType, stridable)): void</code></dt>
<dd><p>Updates the internal representation of <cite>this</cite>
to match the index set of <code class="docutils literal"><span class="pre">dom</span></code>.</p>
<p><code class="docutils literal"><span class="pre">dsiSetIndices</span></code> and <code class="docutils literal"><span class="pre">dsiGetIndices</span></code> are used to assign a domain value to
a domain variable (or any domain l-value).
Note: the arrays associated with this domain will be updated
outside these method.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiSetIndices(ranges: rank * range(idxType)): void</code></dt>
<dd><p>The same as the other <code class="docutils literal"><span class="pre">dsiSetIndices</span></code>. Could be implemented like this:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="nx">dsiSetIndices</span><span class="p">([(</span><span class="o">..</span><span class="p">.</span><span class="nx">rangesArg</span><span class="p">)]);</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>It is used to initialize the index set of the object returned by
<code class="docutils literal"><span class="pre">dsiNewRectangularDom()</span></code> to the index set of the corresponding Chapel
domain value.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these()</code></dt>
<dd><p>The serial iterator over the indices of this domain.
Yields values of the type <code class="docutils literal"><span class="pre">idxType</span></code> if <code class="docutils literal"><span class="pre">rank==1</span></code>,
otherwise <code class="docutils literal"><span class="pre">rank*idxType</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these(param tag) where tag == iterKind.leader</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these(param tag, followThis) where tag == iterKind.follower</code></dt>
<dd><p>The &quot;leader&quot; and &quot;follower&quot; iterators (defined below). They are
invoked implicitly to implement parallel (&quot;forall&quot;) loops over this domain.
Currently the serial iterator must also be defined for &quot;forall&quot; loops to work.</p>
<p>The presentation below is tailored to the use of leader/follower iterators
in domain maps. For a more general discussion, see:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span>$CHPL_HOME/examples/primers/leaderfollower.chpl
</pre></div>
</div>
</div></blockquote>
<p>The job of the leader iterator is to:</p>
<blockquote>
<div><ul class="simple">
<li>subdivide the given domain into subdomains,</li>
<li>introduce parallelism between these subdomains, and</li>
<li>place computations for each subdomain on the desired locale,
as appropriate for this domain map.</li>
</ul>
</div></blockquote>
<p>The leader iterator must yield, for each subdomain it chooses,
a description of that subdomain, created as defined below.
Parallelism and placement are achieved, for example, by placing the
yield statements within parallel loops and <cite>on</cite> statements.
The leader is invoked (implicitly) once per parallel loop or expression
over the corresponding domain.</p>
<p>The job of the follower iterator is simply to iterate sequentially
over a subdomain whose description is yielded by the leader iterator,
yielding all indices in that subdomain.
Each time the leader yields a description, the follower is invoked
(implicitly) with that description passed to its <code class="docutils literal"><span class="pre">followThis</span></code> argument.
(The argument name must be exactly &quot;followThis&quot;.)</p>
<p>For a zippered loop, only the leader for the first of the zippered
items is invoked. Each time that leader yields a description,
all followers are invoked in a zippered manner, with that description
passed to their <code class="docutils literal"><span class="pre">followThis</span></code> arguments.</p>
<p>In general, it is up to the implementer of the leaders/followers
whether and how to support their interoperability in this situation.
That is, whether and how the description from the leader of one
zippered item is handled by the follower of another item.
For example, one could support zippering of similar items
and generate a compile-time or run-time error when the items
are not &quot;similar&quot;.</p>
<p>DSI requires interoperability between domain maps only
for <em>rectangular</em> domains, by prescribing:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>how the leader builds the description of a subdomain, and</li>
<li>in what order the follower yields the indices of that subdomain.</li>
</ol>
</div></blockquote>
</dd></dl>

<div class="section" id="a-subdomain-description">
<h4><a class="toc-backref" href="#id9">A. Subdomain Description</a><a class="headerlink" href="#a-subdomain-description" title="Permalink to this headline">Â¶</a></h4>
<blockquote>
<div><p>Let <code class="docutils literal"><span class="pre">Dwhole</span></code> be the Chapel domain corresponding to this <code class="docutils literal"><span class="pre">GlobalDomain</span></code>.</p>
<p>Let <code class="docutils literal"><span class="pre">Dsub</span></code> be a subdomain chosen by the leader iterator.</p>
<p>Let <code class="docutils literal"><span class="pre">DD</span></code> be the number of dimensions in Dwhole and Dsub.</p>
<p>The description of <code class="docutils literal"><span class="pre">Dsub</span></code> is its &quot;densification&quot; w.r.t. <code class="docutils literal"><span class="pre">Dwhole</span></code>:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span>// densification of a domain is a tuple of densifications
// of ranges for each dimension
densify(Dsub, Dwhole) =
  ( densify(Dsub.dim(1), Dwhole.dim(1)),
    ...,
    densify(Dsub.dim(DD), Dwhole.dim(DD)) )

// densification of a range is the sequence of densifications
// of its elements, preserving their order
if Rsub describes the sequence
  i_1, ..., i_N
then densify(Rsub, Rwhole) describes the sequence
  densify(i_1, Rwhole), ..., densify(i_N, Rwhole)

For example, densify(Rwhole, Rwhole) == 0.. #(Rwhole.length)

// densification of an index is its indexOrder
densify(i, Rwhole) = Rwhole.indexOrder(i)
</pre></div>
</div>
</div></blockquote>
<p>The optional module DSIUtil provides the following implementations
of densifications and the reverse transformation:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span>densify(Dsub, Dwhole)
densify(RSsub, RSwhole)  // on tuples of ranges
densify(Rsub, Rwhole)
unDensify(Dsub, Dwhole)
unDensify(RSsub, RSwhole)  // on tuples of ranges
unDensify(Rsub, Rwhole)
</pre></div>
</div>
</div></blockquote>
<p>Hint: when developing a new domain map, skip densification and
de-densification, but ensure it is used in zippering only
with domains/arrays of the same domain map.</p>
</div></blockquote>
</div>
<div class="section" id="b-follower-yield-order">
<h4><a class="toc-backref" href="#id10">B. Follower Yield Order</a><a class="headerlink" href="#b-follower-yield-order" title="Permalink to this headline">Â¶</a></h4>
<blockquote>
<div><p>The follower iterator must traverse the subdomain for which the above
description is created in the order given by the default domain map.
(That order can be observed, e.g., by assigning <code class="docutils literal"><span class="pre">Rsub</span></code> to a domain
variable whose type does not specify a domain map explicitly,
then invoking <code class="docutils literal"><span class="pre">write()</span></code> on that variable.)</p>
<p>(Interoperability of domain maps implies that the follower must
accept a densification of any subdomain of <code class="docutils literal"><span class="pre">Dwhole</span></code>, not just the
ones that can be generated by its leader.)</p>
</div></blockquote>
<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these(param tag) where tag == iterKind.standalone</code></dt>
<dd><p>A &quot;standlone&quot; parallel iterator. It is optional. If it is provided,
it is used in non-zippered &quot;forall&quot; loops
instead of a combination of leader+follower iterators.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiSerialWrite(f: Writer): void</code></dt>
<dd><p>Writes out the domain to the given Writer (e.g. a file or stdout) serially.
Is used to implement write() on the corresponding domain.</p>
<p>This method will typically invoke f.write() on <code class="docutils literal"><span class="pre">GlobalDomain</span></code>'s components
(e.g. bounds) and strings (e.g. &quot;[&quot; and &quot;]&quot;). Such invocations, whether
direct or indirect, must occur within the same task that <code class="docutils literal"><span class="pre">dsiSerialWrite()</span></code>
is invoked in, and not within any <cite>on</cite> statements, direct or indirect.
Otherwise a deadlock may occur.
(Invoking <code class="docutils literal"><span class="pre">write()</span></code> on <code class="docutils literal"><span class="pre">Writers</span></code> other than <code class="docutils literal"><span class="pre">f</span></code>
is not affected by this.)</p>
<p><code class="docutils literal"><span class="pre">dsiSerialWrite()</span></code> will always be invoked on <code class="docutils literal"><span class="pre">Locales(0)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiDisplayRepresentation(): void</code></dt>
<dd><p>A debugging method. It implements <code class="docutils literal"><span class="pre">displayRepresentation()</span></code>
on the corresponding Chapel domain value.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-globalarray">
<h3><a class="toc-backref" href="#id11">class <code class="docutils literal"><span class="pre">GlobalArray</span></code></a><a class="headerlink" href="#class-globalarray" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div><p>An instance of this class is created whenever a Chapel array is created
over a domain represented by a <code class="docutils literal"><span class="pre">GlobalDomain</span></code>.
There is a one-to-one correspondence at run time between a
(conceptual) Chapel array value and an instance of <code class="docutils literal"><span class="pre">GlobalArray</span></code>.</p>
<p>This class is returned by <code class="docutils literal"><span class="pre">GlobalDomain.dsiBuildArray</span></code>.
It must be a subclass of <code class="docutils literal"><span class="pre">BaseArr</span></code>.</p>
<p>It is legal for <code class="docutils literal"><span class="pre">GlobalDomain.dsiBuildArray</span></code> to return instances of
different classes in different circumstances.
The DSI requirements apply to each of those classes.
Here <code class="docutils literal"><span class="pre">GlobalArray</span></code> refers to each such class.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalArray</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dom</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The field <code class="docutils literal"><span class="pre">eltType</span></code> gives the type of the array elements.</p>
<p>The field <code class="docutils literal"><span class="pre">dom</span></code> must contain a reference to the <code class="docutils literal"><span class="pre">GlobalDomain</span></code> object
that created this <code class="docutils literal"><span class="pre">GlobalArray</span></code>. This is used when creating the (runtime)
type for this array, which contains the array's domain.</p>
</div></blockquote>
<dl class="method">
<dt>
<code class="descname">proc GlobalArray.GlobalArray() // or with arguments</code></dt>
<dd><p>Constructor(s). These are not regulated by DSI -- their specifics are
at the domain map implementor's discretion.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiBuildArray(type eltType) : GlobalArray(eltType, this.type)</code></dt>
<dd><p>This method is invoked when the Chapel program is creating
an array value over the domain <cite>this</cite> with the element type <code class="docutils literal"><span class="pre">eltType</span></code>.
This method returns a new <code class="docutils literal"><span class="pre">GlobalArray</span></code> instance that will correspond to
that Chapel array value, i.e., be that value's runtime representation.
The field <code class="docutils literal"><span class="pre">dom</span></code> of the returned <code class="docutils literal"><span class="pre">GlobalDomain</span></code> must point to <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiGetBaseDom() return dom;</code></dt>
<dd><p>Returns this array's <code class="docutils literal"><span class="pre">GlobalDomain</span></code>.
This procedure should be provided as shown.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiAccess(indexx) var: eltType</code></dt>
<dd><p>Given an index, returns the corresponding array element (as an l-value).</p>
<p>The domain map implementer is allowed to restrict the type of indexx
that this method accepts.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiSerialWrite(f: Writer): void</code></dt>
<dd><p>Writes out the array to the given <code class="docutils literal"><span class="pre">Writer</span></code>
(e.g. a <code class="docutils literal"><span class="pre">file</span></code> or <code class="docutils literal"><span class="pre">stdout</span></code>) serially.
Is used to implement <code class="docutils literal"><span class="pre">write()</span></code> on the corresponding array.</p>
<p>The restrictions on this method are the same as on
<code class="docutils literal"><span class="pre">GlobalDomain.dsiSerialWrite()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these() var: eltType</code></dt>
<dd><p>The serial iterator over the elements of this array.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these(param tag) where tag == iterKind.leader</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these(param tag, followThis) var  where tag == iterKind.follower</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these(param tag) where tag == iterKind.standalone</code></dt>
<dd><p>The leader, follower, and standalone iterators.</p>
<p>These are defined in the same way as the leader and follower for
<code class="docutils literal"><span class="pre">GlobalDomain</span></code>, except the follower must yield array locations.</p>
<p>Given a subdomain description passed to the <code class="docutils literal"><span class="pre">followThis</span></code> argument,
the <code class="docutils literal"><span class="pre">GlobalArray</span></code> follower iterator must yield array locations
corresponding to the indices yielded by the <code class="docutils literal"><span class="pre">GlobalDomain</span></code> follower,
in the same order.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiReallocate(d: domain): void</code></dt>
<dd><p>When this array's domain is assigned a new value, say <code class="docutils literal"><span class="pre">newDom</span></code>,
first <code class="docutils literal"><span class="pre">dsiReallocate(newDom)</span></code> is invoked on this array.
Then, <code class="docutils literal"><span class="pre">dsiSetIndices(newDom)</span></code> is invoked on this array's <code class="docutils literal"><span class="pre">dom</span></code>.</p>
<p>Correspondingly, <code class="docutils literal"><span class="pre">dsiReallocate</span></code> needs to adjust everything
that won't be taken care of in <code class="docutils literal"><span class="pre">dsiSetIndices</span></code>.</p>
<p>NOTE: the formal's name must be exactly <code class="docutils literal"><span class="pre">d</span></code>
at present (due to compiler specifics).</p>
<p>NOTE: this method can/should be a no-op if:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">GlobalArray</span></code> stores its array elements in Chapel array(s), and</li>
<li>the domain(s) of those array(s) are updated by <code class="docutils literal"><span class="pre">dsiSetIndices</span></code>,</li>
</ul>
</div></blockquote>
<p>as in the following simplified example:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="p">:</span> <span class="nx">BaseRectangularDom</span> <span class="p">{</span>
  <span class="c1">// required</span>
  <span class="kd">param</span> <span class="nx">rank</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">idxType</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">stridable</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="c1">// for example, store indices as a single Chapel domain</span>
  <span class="kd">var</span> <span class="nx">myIndices</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span> <span class="nx">idxType</span><span class="p">,</span> <span class="nx">stridable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiSetIndices</span><span class="p">(</span><span class="nx">dom</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span><span class="nx">idxType</span><span class="p">,</span><span class="nx">stridable</span><span class="p">)):</span> <span class="nx">void</span>
<span class="p">{</span> <span class="nx">myIndices</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">;</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">GlobalArray</span> <span class="p">:</span> <span class="nx">BaseArr</span> <span class="p">{</span>
  <span class="c1">// required</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dom</span><span class="p">;</span>
  <span class="c1">// for example, store elements as a single Chapel array</span>
  <span class="kd">var</span> <span class="nx">myElements</span><span class="p">:</span> <span class="p">[</span><span class="nx">dom</span><span class="p">.</span><span class="nx">myIndices</span><span class="p">]</span> <span class="nx">eltType</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Given one instance of each class, say <code class="docutils literal"><span class="pre">gd</span></code> and <code class="docutils literal"><span class="pre">ga</span></code>,
where <code class="docutils literal"><span class="pre">ga.dom</span> <span class="pre">==</span> <span class="pre">gd</span></code>
the domain of <code class="docutils literal"><span class="pre">ga.myElements</span></code> is <code class="docutils literal"><span class="pre">gd.myIndices</span></code>.
A call <code class="docutils literal"><span class="pre">gd.dsiSetIndices(newDom)</span></code> updates <code class="docutils literal"><span class="pre">gd.myIndices</span></code>, which, in turn,
resizes <code class="docutils literal"><span class="pre">ga.myElements</span></code>, according to Chapel's array semantics.
Nothing remains to do in <code class="docutils literal"><span class="pre">dsiReallocate()</span></code>.</p>
<p>(Behind the scene, resizing of <code class="docutils literal"><span class="pre">ga.myElements</span></code> is implemented by
<code class="docutils literal"><span class="pre">dsiReallocate</span></code> of the default domain map. That's the domain map
that <code class="docutils literal"><span class="pre">myIndices</span></code> is distributed with, since <code class="docutils literal"><span class="pre">myIndices</span></code>'s type
provides no explicit domain map.)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiDisplayRepresentation(): void</code></dt>
<dd><p>A debugging method. It implements <code class="docutils literal"><span class="pre">displayRepresentation()</span></code>
on the corresponding Chapel array value.</p>
</dd></dl>

</div>
<div class="section" id="naming">
<h3><a class="toc-backref" href="#id12">Naming</a><a class="headerlink" href="#naming" title="Permalink to this headline">Â¶</a></h3>
<p>Once you have chosen the name for your domain map, say, MyMap,
we suggest naming the descriptor classes as follows:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">in this document</th>
<th class="head">in your code</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">GlobalDistribution</span></code></td>
<td><code class="docutils literal"><span class="pre">MyMapDist</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">GlobalDomain</span></code></td>
<td><code class="docutils literal"><span class="pre">MyMapDom</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">GlobalArray</span></code></td>
<td><code class="docutils literal"><span class="pre">MyMapArr</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">LocalDistribution</span></code></td>
<td><code class="docutils literal"><span class="pre">LocMyMapDist</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">LocalDomain</span></code></td>
<td><code class="docutils literal"><span class="pre">LocMyMapDom</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">LocalArray</span></code></td>
<td><code class="docutils literal"><span class="pre">LocMyMapArr</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Some domain maps in this Chapel distribution use just the domain map
name for their <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> classes, e.g. Block and Cyclic.</p>
</div>
</div>
<div class="section" id="phase-2-additional-operations">
<h2><a class="toc-backref" href="#id13">Phase 2: Additional Operations</a><a class="headerlink" href="#phase-2-additional-operations" title="Permalink to this headline">Â¶</a></h2>
<p>The operations in this phase are required by DSI.
However, if a domain map is in use by a limited set of applications,
these operations do not need to be implemented up front. Instead,
each of them could be implemented later, when the need arises.
The &quot;unresolved call&quot; compilation errors could be used
as an indication of what procedure(s) need to be defined.</p>
<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiIndexToLocale(indexx): locale</code></dt>
<dd><p>Given an index <code class="docutils literal"><span class="pre">indexx</span></code>, returns the locale that &quot;owns&quot; that index,
i.e. on which the corresponding data is located.
This is used to implement <code class="docutils literal"><span class="pre">idxToLocale()</span></code> on the <code class="docutils literal"><span class="pre">dmap</span></code> wrapper.</p>
<p>The domain map implementer is allowed to restrict the type of <code class="docutils literal"><span class="pre">indexx</span></code>
that this method accepts.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiDim(dim: int): range(idxType, BoundedRangeType.bounded, stridable)</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiDims(): rank * range(idxType, BoundedRangeType.bounded, stridable)</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiLow</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiHigh</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiStride</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiNumIndices</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiMember(indexx)</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiIndexOrder(indexx)</code></dt>
<dd><p>These methods implement the corresponding queries
(<code class="docutils literal"><span class="pre">dim</span></code>, <code class="docutils literal"><span class="pre">dims</span></code>, <code class="docutils literal"><span class="pre">low</span></code>, etc.)
of the domain value for which this <code class="docutils literal"><span class="pre">GlobalDomain</span></code> instance was created.
For example, <code class="docutils literal"><span class="pre">dsiDim(d)</span></code> returns the range describing the domain's
<code class="docutils literal"><span class="pre">d</span></code>-th dimension.</p>
<p><code class="docutils literal"><span class="pre">dsiDims()</span></code> and <code class="docutils literal"><span class="pre">dsiGetIndices()</span></code> have the same specification
and so may be implemented in terms of one another.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiBuildRectangularDom(param rank: int, type idxType, param stridable: bool, ranges: rank * range(idxType, BoundedRangeType.bounded, stridable))</code></dt>
<dd><p>This method is similar to <code class="docutils literal"><span class="pre">dsiNewRectangularDom()</span></code>, except it is used
in the cases where a new Chapel domain is created from an existing
Chapel domain (represented by <cite>this</cite>) and the index set of the desired
domain is known (it is defined by the <code class="docutils literal"><span class="pre">ranges</span></code> argument). For example,
it is invoked upon domain slicing and when applying domain operations
such as expand, exterior, interior, translate.
The <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> of the result is the same as that of <cite>this</cite>.</p>
<p>This method returns a new instance of
<code class="docutils literal"><span class="pre">GlobalDomain(rank,</span> <span class="pre">idxType,</span> <span class="pre">stridable)</span></code>
that will be the runtime representation of a Chapel domain whose index set
is initialized as defined by <code class="docutils literal"><span class="pre">ranges</span></code>. Other than that, this instance must
satisfy the same constraints as the result of <code class="docutils literal"><span class="pre">dsiNewRectangularDom()</span></code>.</p>
<p>This method can be implemented as follows,
unless a more efficient implementation is desired:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">.</span><span class="nx">dsiNewRectangularDom</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span> <span class="nx">idxType</span><span class="p">,</span> <span class="nx">stridable</span><span class="p">);</span>
<span class="nx">result</span><span class="p">.</span><span class="nx">dsiSetIndices</span><span class="p">(</span><span class="nx">ranges</span><span class="p">);</span>
<span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiSlice(sliceDef: GlobalDomain)</code></dt>
<dd><p>Returns a <code class="docutils literal"><span class="pre">GlobalArray</span></code> object representing a slice of the array
corresponding to <cite>this</cite>. Like generally in Chapel, the array elements
in the slice must be aliases of the corresponding elements of <cite>this</cite>.
The argument <code class="docutils literal"><span class="pre">sliceDef</span></code> defines the slice, i.e., which of the elements
of <cite>this</cite> are to be included in the result.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiReindex(reindexDef: GlobalDomain)</code></dt>
<dd><p>Similar to <code class="docutils literal"><span class="pre">dsiSlice</span></code>, except: The array alias represented by the
returned object is a reindexing, rather than a slice, of the array
represented by <cite>this</cite>. The argument <code class="docutils literal"><span class="pre">reindexDef</span></code> represents the
reindexing expression. The callers of dsiReindex must ensure that
the domain of this array and <code class="docutils literal"><span class="pre">reindexDef</span></code> have the same number of
dimensions and the same number of indices along each dimension.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiRankChange(reindexDef: GlobalDomain, param newRank: int, param newStridable: bool, args)</code></dt>
<dd><p>Similar to <code class="docutils literal"><span class="pre">dsiReindex</span></code>, except reindexing changes the rank.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.linksDistribution() param</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiLinksDistribution()</code></dt>
<dd><p>Typically these should not be defined.</p>
<p>If the domains mapped using <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> do NOT need to be tracked
and the <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> itself does NOT need to be reference counted,
these two methods should be defined to return <cite>false</cite>;
Also in this case <code class="docutils literal"><span class="pre">dsiMyDist()</span></code> does not need to be defined.</p>
</dd></dl>

</div>
<div class="section" id="phase-3-privatization">
<h2><a class="toc-backref" href="#id14">Phase 3: Privatization</a><a class="headerlink" href="#phase-3-privatization" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="what-is-privatization">
<h3><a class="toc-backref" href="#id15">What is privatization?</a><a class="headerlink" href="#what-is-privatization" title="Permalink to this headline">Â¶</a></h3>
<p>Privatization of an object <code class="docutils literal"><span class="pre">X</span></code> means providing a local copy of <code class="docutils literal"><span class="pre">X</span></code> on
each locale. Such a copy is called the &quot;privatized copy&quot;.
On <code class="docutils literal"><span class="pre">X.locale</span></code>, <code class="docutils literal"><span class="pre">X</span></code> itself serves as the privatized copy.
We refer to <code class="docutils literal"><span class="pre">X</span></code> as the &quot;original object&quot;.</p>
<p>Privatization aims at reducing communication between locales.
When <code class="docutils literal"><span class="pre">X</span></code> needs to be accessed (by reading its fields or invoking
its methods) from another locale, its privatized copy
on the current locale is used instead.
Therefore, communication to <code class="docutils literal"><span class="pre">X.locale</span></code> is eliminated.</p>
</div>
<div class="section" id="how-does-privatization-work-with-dsi">
<h3><a class="toc-backref" href="#id16">How does privatization work with DSI?</a><a class="headerlink" href="#how-does-privatization-work-with-dsi" title="Permalink to this headline">Â¶</a></h3>
<p>Privatization is optional in DSI. Each of the global descriptor classes
can support privatization independently of the others. A class indicates
to the Chapel implementation whether it supports privatization via
its method <code class="docutils literal"><span class="pre">dsiSupportsPrivatization()</span></code> (see below).</p>
<p>Layouts (i.e. the domain maps that do not distribute domains across locales)
can potentially benefit from privatization. However, the standard
layouts do not support it.</p>
<p>The remainder of DSI privatization requirements must be implemented
by each global descriptor class that chooses to support privatization.</p>
<p>The domain map implementation must provide methods to:</p>
<ul class="simple">
<li>create a privatized copy given the original object, and</li>
<li>update a privatized copy when some other privatized copy changes
(see &quot;reprivatization&quot; below).</li>
</ul>
<p>The Chapel implementation:</p>
<ul class="simple">
<li>invokes DSI privatization methods to create or update privatized copies, and</li>
<li>redirects original object accesses to its privatized copies.</li>
</ul>
<p>The Chapel implementation creates privatized copies (over <em>all</em> locales)
greedily as follows (if that class supports privatization):</p>
<ul class="simple">
<li>of a <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> - when it is wrapped in <code class="docutils literal"><span class="pre">new</span> <span class="pre">dmap()</span></code>
and when that wrapper is copied;</li>
<li>of a <code class="docutils literal"><span class="pre">GlobalDomain</span></code> or <code class="docutils literal"><span class="pre">GlobalArray</span></code> - when the corresponding
Chapel domain or array is created.</li>
</ul>
</div>
<div class="section" id="what-is-reprivatization">
<h3><a class="toc-backref" href="#id17">What is reprivatization?</a><a class="headerlink" href="#what-is-reprivatization" title="Permalink to this headline">Â¶</a></h3>
<p>Should any privatized copy be modified, the changes need to be
propagated to all the other privatized copies.
This propagation is called reprivatization.</p>
<p>The domain map implementation provides methods to update a privatized copy.
The Chapel implementation invokes these methods when necessary.</p>
</div>
<div class="section" id="dsi-privatization-requirements">
<h3><a class="toc-backref" href="#id18">DSI privatization requirements</a><a class="headerlink" href="#dsi-privatization-requirements" title="Permalink to this headline">Â¶</a></h3>
<p>The following requirements apply individually to each global descriptor
class that chooses to support privatization.
<code class="docutils literal"><span class="pre">Global</span></code> denotes such a class.</p>
<dl class="method">
<dt>
<code class="descname">proc Global.dsiSupportsPrivatization() param return true;</code></dt>
<dd><p>Returns <cite>true</cite> to indicate that privatization is supported.
NOTE: do not specify the return type (due to a bug in the compiler).</p>
</dd></dl>

<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Global</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
  <span class="kd">var</span> <span class="nx">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The field <code class="docutils literal"><span class="pre">pid</span></code> should be provided as shown.
It should not be accessed by the DSI implementation except
in conjunction with <code class="docutils literal"><span class="pre">chpl_getPrivatizedCopy()</span></code> as discussed later.</p>
<dl class="method">
<dt>
<code class="descname">proc Global.dsiGetPrivatizeData()</code></dt>
<dd><p>Returns the data to be used as the argument to <code class="docutils literal"><span class="pre">dsiPrivatize()</span></code>.
It can be a tuple of values or any other type, at the implementor's
discretion. See <code class="docutils literal"><span class="pre">dsiPrivatize()</span></code> for explanation.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc Global.dsiPrivatize(privatizeData): Global</code></dt>
<dd><p>Returns a privatized copy of <cite>this</cite>. The Chapel implementation
invokes this method as follows:</p>
<ul class="simple">
<li>on the locale where the privatized copy is to be located,</li>
<li><cite>this</cite> is either the original object or its privatized copy
created by <code class="docutils literal"><span class="pre">dsiPrivatize</span></code> on some other locale,</li>
<li><code class="docutils literal"><span class="pre">privatizeData</span></code> is the result of invoking dsiGetPrivatizeData()
on the original object.</li>
</ul>
<p>Typically <code class="docutils literal"><span class="pre">dsiPrivatize()</span></code> will need to copy and/or privatize
some information from the original object into the privatized copy
being created. This information could be obtained by querying <cite>this</cite>
directly. Alternatively, it could be passed from the original object
via <code class="docutils literal"><span class="pre">privatizeData</span></code>. This approach could allow the needed information
to be bundled into the original active message, rather than requiring
additional communications when accessing <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc Global.dsiGetReprivatizeData()</code></dt>
<dd><p>Similar do <code class="docutils literal"><span class="pre">dsiGetPrivatizeData()</span></code>, except the result is used
as the argument to <code class="docutils literal"><span class="pre">dsiReprivatize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc Global.dsiReprivatize(other: Global, reprivatizeData): void</code></dt>
<dd><p>Updates a privatized copy.</p>
<p><cite>this</cite> is the object to be updated as part of reprivatization.</p>
<p><code class="docutils literal"><span class="pre">other</span></code> is either the object whose modification originally
necessitated reprivatization or one of the privatized copies
that have already been updated for that modification
by <code class="docutils literal"><span class="pre">dsiReprivatize()</span></code>.</p>
<p><code class="docutils literal"><span class="pre">reprivatizeData</span></code> is the result of invoking dsiGetReprivatizeData()
on the originally-modified object.</p>
<p>Q: What modifications must <code class="docutils literal"><span class="pre">dsiReprivatize()</span></code> reflect?</p>
<p>A: Any changes that the domain map implementation may perform on
an instance of <code class="docutils literal"><span class="pre">Global</span></code> (or its privatized copy) after that instance
has been created and privatized.</p>
<p>For example, <code class="docutils literal"><span class="pre">GlobalDomain.dsiReprivatize()</span></code> must reflect any changes
that <code class="docutils literal"><span class="pre">GlobalDomain.dsiSetIndices()</span></code> may perform.</p>
</dd></dl>

</div>
<div class="section" id="tip-testing-privatization">
<h3><a class="toc-backref" href="#id19">Tip: testing privatization</a><a class="headerlink" href="#tip-testing-privatization" title="Permalink to this headline">Â¶</a></h3>
<p>In addition to the usual correctness testing, it may be useful to check
whether array access is purely local, i.e., results in no communication.
This can be done using <cite>local</cite> statements.</p>
<p>(A <cite>local</cite> statement performs runtime checks that report an error
whenever any communication occurs within the its body.)</p>
<p>Here is a simple example:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="c1">// declare an array that uses the domain map to be tested</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="o">..</span><span class="p">.;</span>

<span class="c1">// initialize it</span>
<span class="nx">A</span> <span class="o">=</span> <span class="nx">value1</span><span class="p">;</span>

<span class="k">forall</span> <span class="nx">loc</span> <span class="kd">in</span> <span class="p">(</span><span class="nx">locales</span> <span class="nx">that</span> <span class="nx">A</span> <span class="nx">is</span> <span class="nx">distributed</span> <span class="nx">over</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1">// run the check on each locale</span>
  <span class="k">on</span> <span class="nx">loc</span> <span class="p">{</span>
    <span class="c1">// value2 to be different from value1</span>
    <span class="kd">var</span> <span class="nx">valTemp</span> <span class="o">=</span> <span class="nx">value2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">idxTemp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">an</span> <span class="k">index</span> <span class="p">(</span><span class="nx">tuple</span><span class="p">)</span> <span class="nx">that</span> <span class="nx">is</span> <span class="nx">mapped</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">locale</span> <span class="s">&#39;loc&#39;</span><span class="p">);</span>
    <span class="k">local</span> <span class="p">{</span>
      <span class="c1">// Access the array.</span>
      <span class="c1">// This statement succeeds if there is no communication.</span>
      <span class="nx">valTemp</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">idxTemp</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// reference the read value</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">valTemp</span> <span class="o">==</span> <span class="nx">value1</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tip-privatized-copies-should-reference-privatized-copies">
<h3><a class="toc-backref" href="#id20">Tip: privatized copies should reference privatized copies</a><a class="headerlink" href="#tip-privatized-copies-should-reference-privatized-copies" title="Permalink to this headline">Â¶</a></h3>
<p>The global descriptor classes are required to reference each other
(e.g. <code class="docutils literal"><span class="pre">GlobalArray.dom</span></code> references <code class="docutils literal"><span class="pre">GlobalDomain</span></code>; <code class="docutils literal"><span class="pre">GlobalDomain.dist</span></code>
references <code class="docutils literal"><span class="pre">GlobalDistribution</span></code>). Therefore, if it is desired to
eliminate communication completely upon array references,
all the three global descriptor classes may have to be privatized.
When one descriptor object references another, a privatized copy of
the former needs to reference a privatized copy of the latter.</p>
<p>To obtain a privatized copy of an object, e.g. for use within
<code class="docutils literal"><span class="pre">dsiPrivatize()</span></code>, use the following procedure:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">chpl_getPrivatizedCopy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">objectType</span><span class="p">,</span> <span class="nx">objectPid</span><span class="p">:</span><span class="kt">int</span><span class="p">):</span> <span class="nx">objectType</span>
</pre></div>
</div>
</div></blockquote>
<p>Notes:</p>
<ul class="simple">
<li>The first argument is type of the object being privatized.</li>
<li>The second argument is the original object's <code class="docutils literal"><span class="pre">pid</span></code> field.</li>
<li>The procedure returns a privatized copy of the original object.</li>
<li>The procedure can be applied only to objects that have already
been privatized.<ul>
<li>A <code class="docutils literal"><span class="pre">GlobalArray</span></code> is privatized after its <code class="docutils literal"><span class="pre">GlobalDomain</span></code>, which is
privatized after its <code class="docutils literal"><span class="pre">GlobalDistribution</span></code>.</li>
<li>The <code class="docutils literal"><span class="pre">pid</span></code> field is set to a different value than <code class="docutils literal"><span class="pre">-1</span></code>
when an object is privatized.</li>
</ul>
</li>
</ul>
<p>Here is an example of using it for privatizing <code class="docutils literal"><span class="pre">GlobalDomain</span></code>,
assuming that <code class="docutils literal"><span class="pre">GlobalDistribution</span></code> also supports privatization:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiGetPrivatizeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// include the desired &#39;pid&#39;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="o">..</span><span class="p">.</span> <span class="nx">other</span> <span class="nx">data</span> <span class="nx">as</span> <span class="nx">needed</span> <span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiPrivatize</span><span class="p">(</span><span class="nx">privatizeData</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// extract the &#39;pid&#39; provided above</span>
  <span class="kd">const</span> <span class="nx">distPid</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// obtain the privatized copy of the GlobalDistribution object</span>
  <span class="kd">const</span> <span class="nx">privatizedDMap</span> <span class="o">=</span> <span class="nx">chpl_getPrivatizedCopy</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="kd">type</span><span class="p">,</span> <span class="nx">distPid</span><span class="p">);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nx">GlobalDomain</span><span class="p">(</span><span class="nx">dist</span> <span class="o">=</span> <span class="nx">privatizedDMap</span><span class="p">,</span>
                          <span class="o">..</span><span class="p">.</span> <span class="nx">other</span> <span class="nx">fields</span> <span class="nx">as</span> <span class="nx">needed</span> <span class="o">..</span><span class="p">.)</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tip-privatize-the-domains-and-arrays-used-in-the-implementation">
<h3><a class="toc-backref" href="#id21">Tip: &quot;privatize&quot; the domains and arrays used in the implementation</a><a class="headerlink" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation" title="Permalink to this headline">Â¶</a></h3>
<p>If a global descriptor class to be privatized uses domains and arrays,
those need to be &quot;privatized&quot;, too, to reduce communication. In the
case of domains and arrays mapped using the default layout,
their &quot;privatization&quot; is achieved by copying.</p>
<p>Careful consideration is needed to eliminate all communication.
For example:</p>
<ul class="simple">
<li>Copying an array preserves the source's domain - unless
the destination's domain is declared explicitly.</li>
<li>Copying a domain preserves the source's domain map - unless
the destination's type is declared explicitly.</li>
<li>If an array's domain or a domain's domain map is declared explicitly,
ensure that privatized copies of those are used.</li>
<li>There is no need to privatize the default layout.
Specifically, copying a domain declared without an explicit domain map
is sufficient to privatize that domain.</li>
<li>The same considerations are valid for reprivatization.</li>
</ul>
<p>Here is an example of &quot;privatizing&quot; domains/arrays within <code class="docutils literal"><span class="pre">GlobalDomain</span></code>.
The key insight here is that <code class="docutils literal"><span class="pre">auxArrayG</span></code>'s domain needs to be &quot;privatized&quot;.
Cf. the domains of <code class="docutils literal"><span class="pre">auxArrayED1</span></code> and <code class="docutils literal"><span class="pre">auxArrayED2</span></code> are created
implicitly for each <code class="docutils literal"><span class="pre">GlobalDomain</span></code> object and so will be local in any case.</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>

  <span class="c1">// this field is generic</span>
  <span class="kd">var</span> <span class="nx">auxArrayG</span><span class="p">;</span>

  <span class="c1">// domain is specified explicitly</span>
  <span class="kd">var</span> <span class="nx">auxArrayED1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>

  <span class="c1">// similar</span>
  <span class="kd">var</span> <span class="nx">auxDomain</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">auxArrayED2</span><span class="p">:</span> <span class="p">[</span><span class="nx">auxDomain</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiGetPrivatizeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="nx">auxArrayG</span><span class="p">,</span>
          <span class="nx">auxArrayED1</span><span class="p">,</span> <span class="nx">auxDomain</span><span class="p">,</span> <span class="nx">auxArrayED2</span><span class="p">,</span> <span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiPrivatize</span><span class="p">(</span><span class="nx">privatizeData</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// To privatize auxArrayG, we must &quot;privatize&quot; its domain first.</span>
  <span class="c1">// No need to declare privDom&#39;s type if auxArrayG uses the default layout.</span>
  <span class="kd">var</span> <span class="nx">privDom</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="k">domain</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">privArr</span><span class="p">:</span> <span class="p">[</span><span class="nx">privDom</span><span class="p">]</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">eltType</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

  <span class="c1">// If the following were used, privArr.domain would be the same</span>
  <span class="c1">// as privatizeData(2).domain, i.e., it would not be privatized.</span>
  <span class="c1">//var privArr = privatizeData(2);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nx">GlobalDomain</span><span class="p">(</span><span class="o">..</span><span class="p">.,</span> <span class="nx">auxArrayG</span> <span class="o">=</span> <span class="nx">privArr</span><span class="p">,</span>
    <span class="c1">// the other fields can be simply copied</span>
    <span class="nx">auxArrayED1</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
    <span class="nx">auxDomain</span>   <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
    <span class="nx">auxArrayED2</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>

<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extern.html" class="btn btn-neutral float-right" title="C Interoperability" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="chpl-ipe.html" class="btn btn-neutral" title="Interactive Chapel" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Cray Inc.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.13.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

</body>
</html>
