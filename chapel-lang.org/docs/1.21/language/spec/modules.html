

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Modules &mdash; Chapel Documentation 1.21</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Procedures" href="procedures.html" />
    <link rel="prev" title="Statements" href="statements.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.21
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.21";
$pagename = "language/spec/modules";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-definitions">Module Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prototype-modules">Prototype Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#files-and-implicit-modules">Files and Implicit Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nested-modules">Nested Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-of-module-contents">Access of Module Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#visibility-of-a-module">Visibility Of A Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visibility-of-a-modules-symbols">Visibility Of A Module’s Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-modules">Using Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qualified-naming-of-module-symbols">Qualified Naming of Module Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-initialization">Module Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-deinitialization">Module Deinitialization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#program-execution">Program Execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-main-function">The <em>main</em> Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-initialization-order">Module Initialization Order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-deinitialization-order">Module Deinitialization Order</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Modules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/modules.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="modules">
<span id="chapter-modules"></span><h1>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h1>
<p>Chapel supports modules to manage namespaces. A program consists of one
or more modules. Every symbol, including variables, functions, and
types, is associated with some module.</p>
<p>Module definitions are described in&nbsp;<a class="reference internal" href="#module-definitions"><span class="std std-ref">Module Definitions</span></a>.
The relation between files and modules is described
in&nbsp;<a class="reference internal" href="#implicit-modules"><span class="std std-ref">Files and Implicit Modules</span></a>. Nested modules are described
in&nbsp;<a class="reference internal" href="#nested-modules"><span class="std std-ref">Nested Modules</span></a>. The visibility of a module’s symbols
by users of the module is described
in&nbsp;<a class="reference internal" href="#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>. The execution of a program
and module initialization/deinitialization are described
in&nbsp;<a class="reference internal" href="#program-execution"><span class="std std-ref">Program Execution</span></a>.</p>
<div class="section" id="module-definitions">
<span id="id1"></span><h2>Module Definitions<a class="headerlink" href="#module-definitions" title="Permalink to this headline">¶</a></h2>
<p>A module is declared with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>module-declaration-statement:
  privacy-specifier[OPT] prototype-specifier[OPT] `module&#39; module-identifier block-statement

privacy-specifier:
  `private&#39;
  `public&#39;

prototype-specifier:
  `prototype&#39;

module-identifier:
  identifier
</pre></div>
</div>
<p>A module’s name is specified after the <code class="docutils literal notranslate"><span class="pre">module</span></code> keyword. The
<code class="docutils literal notranslate"><span class="pre">block-statement</span></code> opens the module’s scope. Symbols defined in this
block statement are defined in the module’s scope and are called
<em>module-scope symbols</em>. The visibility of a module is defined by its
<code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> &nbsp;(<a class="reference internal" href="#visibility-of-a-module"><span class="std std-ref">Visibility Of A Module</span></a>).</p>
<p>Module declaration statements are only legal as file-scope or
module-scope statements. For example, module declaration statements may
not occur within block statements, functions, classes, or records.</p>
<p>Any module declaration that is not contained within another module
creates a <em>top-level module</em>. Module declarations within other modules
create nested modules&nbsp;(<a class="reference internal" href="#nested-modules"><span class="std std-ref">Nested Modules</span></a>).</p>
</div>
<div class="section" id="prototype-modules">
<span id="id2"></span><h2>Prototype Modules<a class="headerlink" href="#prototype-modules" title="Permalink to this headline">¶</a></h2>
<p>Modules that are declared with the <code class="docutils literal notranslate"><span class="pre">prototype</span></code> keyword use relaxed
rules for error handling. These relaxed rules are
appropriate for programs in the early stages of development but are not
appropriate for libraries. In particular, within a <code class="docutils literal notranslate"><span class="pre">prototype</span></code> module
errors that are not handled will terminate the program
(see&nbsp;<a class="reference internal" href="error-handling.html#errors-prototype-mode"><span class="std std-ref">Prototype Mode</span></a>).</p>
<p>Implicit modules (<a class="reference internal" href="#implicit-modules"><span class="std std-ref">Files and Implicit Modules</span></a>) are implicitly considered
<code class="docutils literal notranslate"><span class="pre">prototype</span></code> modules as well.</p>
</div>
<div class="section" id="files-and-implicit-modules">
<span id="implicit-modules"></span><h2>Files and Implicit Modules<a class="headerlink" href="#files-and-implicit-modules" title="Permalink to this headline">¶</a></h2>
<p>Multiple modules can be defined within the same file and need not bear
any relation to the file in terms of their names.</p>
<blockquote>
<div><p><em>Example (two-modules.chpl)</em>.</p>
<p>The following file contains two explicitly named modules, MX and MY.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">MX</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;Module MX&quot;</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">MY</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;Module MY&quot;</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Module MX defines module-scope symbols x and printX, while MY defines
module-scope symbols y and printY.</p>
</div></blockquote>
<p>For any file that contains file-scope statements other than module
declarations, the file itself is treated as a module declaration. In
this case, the module is implicit. Implicit modules are always
<code class="docutils literal notranslate"><span class="pre">prototype</span></code> modules (<a class="reference internal" href="#prototype-modules"><span class="std std-ref">Prototype Modules</span></a>).
An implicit module takes its name from the base
filename. In particular, the module name is defined as the remaining
string after removing the <code class="docutils literal notranslate"><span class="pre">.chpl</span></code> suffix and any path specification
from the specified filename. If the resulting name is not a legal Chapel
identifier, it cannot be referenced in a use statement.</p>
<blockquote>
<div><p><em>Example (implicit.chpl)</em>.</p>
<p>The following file, named implicit.chpl, defines an implicitly named
module called implicit.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Module implicit defines the module-scope symbols x, y, printX, and
printY.</p>
</div></blockquote>
</div>
<div class="section" id="nested-modules">
<span id="id3"></span><h2>Nested Modules<a class="headerlink" href="#nested-modules" title="Permalink to this headline">¶</a></h2>
<p>A <em>nested module</em> (or <em>sub-module</em>) is a module that is defined within
another module, known as the outer, or parent, module.  An outer
module can refer to the names of its sub-modules directly without a
<code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code> statement.  However, a sub-module must <code class="docutils literal notranslate"><span class="pre">use</span></code>
or <code class="docutils literal notranslate"><span class="pre">import</span></code> its parent module in order to refer to its name or
symbols.</p>
<p>An inner module’s symbols can be referenced without accessing those of
its parent module by naming the inner module in a qualified manner
within the <code class="docutils literal notranslate"><span class="pre">use</span></code> statement.</p>
<blockquote>
<div><p><em>Example (nested-use.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span>  <span class="k">use</span> <span class="nx">libsci</span><span class="p">.</span><span class="nx">blas</span><span class="p">;</span>

<span class="o">..</span> <span class="nx">BLOCK</span><span class="o">-</span><span class="nx">test</span><span class="o">-</span><span class="nx">chapelpost</span>

  <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>uses a module named <code class="docutils literal notranslate"><span class="pre">blas</span></code> that is nested within a module named
<code class="docutils literal notranslate"><span class="pre">libsci</span></code>.</p>
</div></blockquote>
<p>Files with both module declarations and file-scope statements result in
nested modules.</p>
<blockquote>
<div><p><em>Example (nested.chpl)</em>.</p>
<p>The following file, named nested.chpl, defines an implicitly named
module called nested, with nested modules MX and MY.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">MX</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">MY</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nx">MX</span><span class="p">,</span> <span class="nx">MY</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="access-of-module-contents">
<span id="id4"></span><h2>Access of Module Contents<a class="headerlink" href="#access-of-module-contents" title="Permalink to this headline">¶</a></h2>
<p>A module’s contents can be accessed by code outside of that module
depending on the visibility of the module
itself&nbsp;(<a class="reference internal" href="#visibility-of-a-module"><span class="std std-ref">Visibility Of A Module</span></a>) and the visibility of
each individual symbol&nbsp;(<a class="reference internal" href="#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>). This
can be done via the use statement&nbsp;(<a class="reference internal" href="#using-modules"><span class="std std-ref">Using Modules</span></a>) or
qualified naming&nbsp;(<a class="reference internal" href="#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a>).</p>
<div class="section" id="visibility-of-a-module">
<span id="id5"></span><h3>Visibility Of A Module<a class="headerlink" href="#visibility-of-a-module" title="Permalink to this headline">¶</a></h3>
<p>A top-level module is available for use&nbsp;(<a class="reference internal" href="#using-modules"><span class="std std-ref">Using Modules</span></a>)
anywhere. The visibility of a nested module is subject to the rules
of&nbsp;<a class="reference internal" href="#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>, where the nested module is
considered a “module-scope symbol” of its outer module.</p>
</div>
<div class="section" id="visibility-of-a-modules-symbols">
<span id="visibility-of-symbols"></span><h3>Visibility Of A Module’s Symbols<a class="headerlink" href="#visibility-of-a-modules-symbols" title="Permalink to this headline">¶</a></h3>
<p>A symbol defined at module scope is <em>visible</em> from outside the module
when the <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> of its definition is <code class="docutils literal notranslate"><span class="pre">public</span></code> or is
omitted (i.e. by default). When a module-scope symbol is declared
<code class="docutils literal notranslate"><span class="pre">private</span></code>, it is not visible outside of that module. A symbol’s
visibility inside its module is controlled by normal lexical scoping and
is not affected by its <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code>. When a module’s symbol is
visible&nbsp;(<a class="reference internal" href="#visibility-of-a-module"><span class="std std-ref">Visibility Of A Module</span></a>), the visible symbols
it contains are accessible via the use
statement&nbsp;(<a class="reference internal" href="#using-modules"><span class="std std-ref">Using Modules</span></a>) or qualified
naming&nbsp;(<a class="reference internal" href="#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a>).</p>
</div>
<div class="section" id="using-modules">
<span id="id6"></span><h3>Using Modules<a class="headerlink" href="#using-modules" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">use</span></code> statement provides the primary means of accessing a module’s
symbols from outside of the module. Use statements make both the
module’s name and its public symbols available for reference within a
given scope. For top-level modules, a use statement is required before
referring to the module’s name or the symbols it contains within a given
lexical scope.</p>
<p>Use statements can also restrict or rename the set of module symbols
that are available within the scope. For further information about use
statements, see&nbsp;<a class="reference internal" href="statements.html#the-use-statement"><span class="std std-ref">The Use Statement</span></a>.</p>
</div>
<div class="section" id="qualified-naming-of-module-symbols">
<span id="explicit-naming"></span><h3>Qualified Naming of Module Symbols<a class="headerlink" href="#qualified-naming-of-module-symbols" title="Permalink to this headline">¶</a></h3>
<p>When a module’s symbol is visible—via a use statement, or lexically for
nested modules—its public symbols can be referred to via qualified
naming with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>module-access-expression:
  module-identifier-list . identifier

module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list
</pre></div>
</div>
<p>This allows two symbols that have the same name to be distinguished
based on the name of their module. Using qualified naming in a function
call restricts the set of candidate functions to those in the specified
module.</p>
<p>If code refers to symbols that are defined by multiple modules, the
compiler will issue an error. Qualified naming can be used to
disambiguate the symbols in this case.</p>
<blockquote>
<div><p><em>Example (ambiguity.chpl)</em>.</p>
<p>In the following example,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M1&#39;s x is: &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M1&#39;s y is: &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M3</span><span class="p">;</span>
  <span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M2&#39;s x is: &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">printX</span><span class="p">();</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="nx">printX</span><span class="p">();</span> <span class="c1">// This is not ambiguous</span>
    <span class="nx">printY</span><span class="p">();</span> <span class="c1">// ERROR: This is ambiguous</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M3</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M3&#39;s y is: &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to printX() is not ambiguous because M2’s definition shadows
that of M1. On the other hand, the call to printY() is ambiguous
because it is defined in both M1 and M3. This will result in a
compiler error. The call could be qualified via M1.printY() or
M3.printY() to resolve this ambiguity.</p>
</div></blockquote>
</div>
<div class="section" id="module-initialization">
<span id="id7"></span><h3>Module Initialization<a class="headerlink" href="#module-initialization" title="Permalink to this headline">¶</a></h3>
<p>Module initialization occurs at program start-up. All module-scope
statements within a module other than function and type declarations are
executed during module initialization. Modules that are not referred to,
including both top-level modules and sub-modules, will not be
initialized.</p>
<blockquote>
<div><p><em>Example (init.chpl)</em>.</p>
<p>In the code,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>       <span class="c1">// executed at module initialization</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hi!&quot;</span><span class="p">);</span>      <span class="c1">// executed at module initialization</span>
<span class="k">proc</span> <span class="nf">sayGoodbye</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Bye!&quot;</span><span class="p">);</span>   <span class="c1">// not executed at module initialization</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function foo() will be invoked and its result assigned to x. Then
“Hi!” will be printed.</p>
</div></blockquote>
<p>Module initialization order is discussed
in&nbsp;<a class="reference internal" href="#module-initialization-order"><span class="std std-ref">Module Initialization Order</span></a>.</p>
</div>
<div class="section" id="module-deinitialization">
<span id="id8"></span><h3>Module Deinitialization<a class="headerlink" href="#module-deinitialization" title="Permalink to this headline">¶</a></h3>
<p>Module deinitialization occurs at program tear-down. During module
deinitialization:</p>
<ul class="simple">
<li>If the module contains a deinitializer, which is a module-scope
function named <code class="docutils literal notranslate"><span class="pre">deinit()</span></code>, it is executed first.</li>
<li>If the module declares module-scope variables, they are deinitialized in
the reverse order of their declaration.</li>
</ul>
<p>Module deinitialization order is discussed
in&nbsp;<a class="reference internal" href="#module-deinitialization-order"><span class="std std-ref">Module Deinitialization Order</span></a>.</p>
</div>
</div>
<div class="section" id="program-execution">
<span id="id9"></span><h2>Program Execution<a class="headerlink" href="#program-execution" title="Permalink to this headline">¶</a></h2>
<p>Chapel programs start by initializing all modules and then executing the
main function&nbsp;(<a class="reference internal" href="#the-main-function"><span class="std std-ref">The main Function</span></a>).</p>
<div class="section" id="the-main-function">
<span id="id10"></span><h3>The <em>main</em> Function<a class="headerlink" href="#the-main-function" title="Permalink to this headline">¶</a></h3>
<p>The main function must be called <code class="docutils literal notranslate"><span class="pre">main</span></code> and must have zero arguments.
It can be specified with or without parentheses. In any Chapel program,
there is a single main function that defines the program’s entry point.
If a program defines multiple potential entry points, the implementation
may provide a compiler flag that disambiguates between main functions in
multiple modules.</p>
<blockquote>
<div><p><em>Implementation Notes</em>.</p>
<p>In the current Chapel compiler implementation, the <em>– –main-module</em> flag
can be used to specify the module from which the main function
definition will be used.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (main-module.chpl)</em>.</p>
<p>Because it defines two <code class="docutils literal notranslate"><span class="pre">main</span></code> functions, the following code will
yield an error unless a main module is specified on the command line.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;&#39;s main&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">main</span><span class="p">();</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;&#39;s main&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If M1 is specified as the main module, the program will output:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>M1&#39;s main
</pre></div>
</div>
<p>If M2 is specified as the main module the program will output:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>M1&#39;s main
M2&#39;s main
</pre></div>
</div>
<p>Notice that main is treated like just another function if it is not
in the main module and can be called as such.</p>
</div></blockquote>
<p>To aid in exploratory programming, a default main function is created if
the program does not contain a user-defined main function. The default
main function is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
<blockquote>
<div><p><em>Example (no-main.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;hello, world&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>is a legal and complete Chapel program. The startup code for a Chapel
program first calls the module initialization code for the main
module and then calls <code class="docutils literal notranslate"><span class="pre">main()</span></code>. This program’s initialization
function is the file-scope writeln() statement. The module
declaration is taken to be the entire file, as described
in&nbsp;<a class="reference internal" href="#implicit-modules"><span class="std std-ref">Files and Implicit Modules</span></a>.</p>
</div></blockquote>
</div>
<div class="section" id="module-initialization-order">
<span id="id11"></span><h3>Module Initialization Order<a class="headerlink" href="#module-initialization-order" title="Permalink to this headline">¶</a></h3>
<p>Module initialization is performed using the following algorithm.</p>
<p>Starting from the module that defines the main function, the modules
named in its use statements are visited depth-first and initialized in
post-order. If a use statement names a module that has already been
visited, it is not visited a second time. Thus, infinite recursion is
avoided.</p>
<p>Modules used by a given module are visited in the order in which they
appear in the program text. For nested modules, the parent module and
its uses are initialized before the nested module and its uses.</p>
<blockquote>
<div><p><em>Example (init-order.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M2</span><span class="p">.</span><span class="nx">M3</span><span class="p">;</span>
  <span class="k">use</span> <span class="nx">M2</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s initializer&quot;</span><span class="p">);</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In main&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M4</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s initializer&quot;</span><span class="p">);</span>
  <span class="k">module</span> <span class="nc">M3</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M3&#39;s initializer&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M4</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M4&#39;s initializer&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints the following</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M4&#39;s initializer
In M2&#39;s initializer
In M3&#39;s initializer
In M1&#39;s initializer
In main
</pre></div>
</div>
<p>M1, the main module, uses M2.M3 and then M2, thus M2.M3 must be
initialized. Because M2.M3 is a nested module, M4 (which is used by
M2) must be initialized first. M2 itself is initialized, followed by
M2.M3. Finally M1 is initialized, and the main function is run.</p>
</div></blockquote>
</div>
<div class="section" id="module-deinitialization-order">
<span id="id12"></span><h3>Module Deinitialization Order<a class="headerlink" href="#module-deinitialization-order" title="Permalink to this headline">¶</a></h3>
<p>Module deinitialization is performed in the reverse order of module
initialization, as specified in
<a class="reference internal" href="#module-initialization-order"><span class="std std-ref">Module Initialization Order</span></a>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="procedures.html" class="btn btn-neutral float-right" title="Procedures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="statements.html" class="btn btn-neutral float-left" title="Statements" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>