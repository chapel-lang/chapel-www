<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Generics &mdash; Chapel Documentation 2.0</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Task Parallelism and Synchronization" href="task-parallelism-and-synchronization.html" />
    <link rel="prev" title="Arrays" href="arrays.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.0
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.0";
$pagename = "language/spec/generics";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-structures">Code Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#composite-types">Composite Types</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Generics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generic-functions">Generic Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-visibility-in-generic-functions">Function Visibility in Generic Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-types">Generic Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-defined-compiler-diagnostics">User-Defined Compiler Diagnostics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-general-and-specialized-versions-of-a-function">Creating General and Specialized Versions of a Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-a-generic-stack">Example: A Generic Stack</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Chapel Language Specification</a></li>
      <li class="breadcrumb-item active">Generics</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/generics.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="generics">
<span id="chapter-generics"></span><h1>Generics<a class="headerlink" href="#generics" title="Permalink to this heading">¶</a></h1>
<p>Chapel supports generic functions and types that are parameterizable
over both types and parameters. The generic functions and types look
similar to non-generic functions and types already discussed.</p>
<section id="generic-functions">
<span id="id1"></span><h2>Generic Functions<a class="headerlink" href="#generic-functions" title="Permalink to this heading">¶</a></h2>
<p>A function is generic if any of the following conditions hold:</p>
<ul class="simple">
<li><p>Some formal argument is specified with an intent of <code class="docutils literal notranslate"><span class="pre">type</span></code> or
<code class="docutils literal notranslate"><span class="pre">param</span></code>.</p></li>
<li><p>Some formal argument has no specified type and no default value.</p></li>
<li><p>Some formal argument is specified with a queried type.</p></li>
<li><p>The type of some formal argument is a generic type, e.g., <code class="docutils literal notranslate"><span class="pre">List</span></code>.
Queries may be inlined in generic types, e.g., <code class="docutils literal notranslate"><span class="pre">List(?eltType)</span></code>.</p></li>
<li><p>The type of some formal argument is an array type where either the
element type is queried or omitted or the domain is queried or
omitted.</p></li>
</ul>
<p>These conditions are discussed in the next sections.</p>
<section id="formal-type-arguments">
<span id="id2"></span><h3>Formal Type Arguments<a class="headerlink" href="#formal-type-arguments" title="Permalink to this heading">¶</a></h3>
<p>If a formal argument is specified with intent <code class="docutils literal notranslate"><span class="pre">type</span></code>, then a type must
be passed to the function at the call site. A copy of the function is
instantiated for each unique type that is passed to this function at a
call site. The formal argument has the semantics of a type alias.</p>
<blockquote>
<div><p><em>Example (build2tuple.chpl)</em>.</p>
<p>The following code defines a function that takes two types at the
call site and returns a 2-tuple where the types of the components of
the tuple are defined by the two type arguments and the values are
specified by the types default values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">build2Tuple</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">tt</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x1</span><span class="p">:</span> <span class="nx">t</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x2</span><span class="p">:</span> <span class="nx">tt</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is instantiated with “normal” function call syntax
where the arguments are types:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t2</span> <span class="o">=</span> <span class="nx">build2Tuple</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span>
<span class="nx">t2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>A formal type argument can include a formal type (a colon followed by a
type). This pattern is sometimes useful to create generic functions
accepting type arguments that only apply to a specific group of types.</p>
<blockquote>
<div><p><em>Example (typeColonArgument.chpl)</em>.</p>
<p>Suppose that we’d like to define a function that accepts a type
argument and returns 1 represented in that type.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">getOne</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span><span class="nx">numeric</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">:</span><span class="nx">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now calls to this function will resolve to the appropriate version
based upon the argument type supplied.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">anInt8</span> <span class="o">=</span> <span class="nx">getOne</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
<span class="kd">var</span> <span class="nx">aReal</span> <span class="o">=</span> <span class="nx">getOne</span><span class="p">(</span><span class="kt">real</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="formal-parameter-arguments">
<span id="id3"></span><h3>Formal Parameter Arguments<a class="headerlink" href="#formal-parameter-arguments" title="Permalink to this heading">¶</a></h3>
<p>If a formal argument is specified with intent <code class="docutils literal notranslate"><span class="pre">param</span></code>, then a
parameter must be passed to the function at the call site. A copy of the
function is instantiated for each unique parameter that is passed to
this function at a call site. The formal argument is a parameter.</p>
<blockquote>
<div><p><em>Example (fillTuple.chpl)</em>.</p>
<p>The following code defines a function that takes an integer parameter
<code class="docutils literal notranslate"><span class="pre">p</span></code> at the call site as well as a regular actual argument of
integer type <code class="docutils literal notranslate"><span class="pre">x</span></code>. The function returns a homogeneous tuple of size
<code class="docutils literal notranslate"><span class="pre">p</span></code> where each component in the tuple has the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">fillTuple</span><span class="p">(</span><span class="kd">param</span> <span class="nx">p</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">p</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
    <span class="nx">result</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function call <code class="docutils literal notranslate"><span class="pre">fillTuple(3,</span> <span class="pre">3)</span></code> returns a 3-tuple where each
component contains the value <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</div></blockquote>
</section>
<section id="formal-arguments-without-types">
<span id="id4"></span><h3>Formal Arguments without Types<a class="headerlink" href="#formal-arguments-without-types" title="Permalink to this heading">¶</a></h3>
<p>If the type of a formal argument is omitted, and that formal is not
declared with the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent (<a class="reference internal" href="procedures.html#the-out-intent"><span class="std std-ref">The Out Intent</span></a>), the type of the
formal argument is taken to be the type of the actual argument passed to
the function at the call site. A copy of the function is instantiated for
each unique actual type.</p>
<blockquote>
<div><p><em>Example (fillTuple2.chpl)</em>.</p>
<p>The example from the previous section can be extended to be generic
on a parameter as well as the actual argument that is passed to it by
omitting the type of the formal argument <code class="docutils literal notranslate"><span class="pre">x</span></code>. Additionally the
parameter argument can allow any type be passed. The following code
defines a function that returns a homogeneous tuple of size <code class="docutils literal notranslate"><span class="pre">p</span></code>
where each component in the tuple is initialized to <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">fillTuple</span><span class="p">(</span><span class="kd">param</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">p</span><span class="o">*</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
    <span class="nx">result</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this function, the type of the tuple is taken to be the type of
the actual argument. The call <code class="docutils literal notranslate"><span class="pre">fillTuple(3,</span> <span class="pre">3.14)</span></code> returns a
3-tuple of real values <code class="docutils literal notranslate"><span class="pre">(3.14,</span> <span class="pre">3.14,</span> <span class="pre">3.14)</span></code>. The return type is
<code class="docutils literal notranslate"><span class="pre">(real,</span> <span class="pre">real,</span> <span class="pre">real)</span></code>.</p>
</div></blockquote>
</section>
<section id="formal-arguments-with-queried-types">
<span id="id5"></span><h3>Formal Arguments with Queried Types<a class="headerlink" href="#formal-arguments-with-queried-types" title="Permalink to this heading">¶</a></h3>
<p>If the type of a formal argument is specified as a queried type, the
type of the formal argument is taken to be the type of the actual
argument passed to the function at the call site. A copy of the function
is instantiated for each unique actual type. The queried type has the
semantics of a type alias.</p>
<blockquote>
<div><p><em>Example (fillTuple3.chpl)</em>.</p>
<p>The example from the previous section can be rewritten to use a
queried type for clarity:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">fillTuple</span><span class="p">(</span><span class="kd">param</span> <span class="nx">p</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">x</span><span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">p</span><span class="o">*</span><span class="nx">t</span><span class="p">;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
    <span class="nx">result</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (query.chpl)</em>.</p>
<p>Type queries can also be used to constrain the types of other
function arguments and/or the return type. In this example, the type
query on the first argument establishes type constraints on the other
arguments and also determines the return type.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">sumOfThree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">sumOfThree</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">));</span>

<span class="k">proc</span> <span class="nf">sumOfThree</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span><span class="nx">t</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span><span class="nx">t</span><span class="p">):</span><span class="nx">t</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">sum</span><span class="p">:</span> <span class="nx">t</span><span class="p">;</span>

   <span class="nx">sum</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span>
   <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>produces the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>6
12.0
</pre></div>
</div>
</div></blockquote>
</section>
<section id="formal-arguments-of-generic-type">
<span id="id6"></span><h3>Formal Arguments of Generic Type<a class="headerlink" href="#formal-arguments-of-generic-type" title="Permalink to this heading">¶</a></h3>
<p>If the type of a formal argument is a generic type, and that formal is
not declared with the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent (<a class="reference internal" href="procedures.html#the-out-intent"><span class="std std-ref">The Out Intent</span></a>), there must
exist an instantiation of that type that the actual argument can be
implicitly coerced to (<a class="reference internal" href="conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>). A copy of the
function is instantiated for each unique instantiation of the formal’s
type.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code defines a function <code class="docutils literal notranslate"><span class="pre">writeTop</span></code> that takes an
actual argument that is a generic stack
(see <a class="reference internal" href="#example-generic-stack"><span class="std std-ref">Example: A Generic Stack</span></a>) and outputs the top element
of the stack. The function is generic on the type of its argument.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">writeTop</span><span class="p">(</span><span class="nx">s</span><span class="p">:</span> <span class="nx">Stack</span><span class="p">(?))</span> <span class="p">{</span>
  <span class="nx">write</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">top</span><span class="p">.</span><span class="nx">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Types and parameters may be queried from the types of formal arguments
as well. In the example above, the formal argument’s type could also be
specified as <code class="docutils literal notranslate"><span class="pre">Stack(?t)</span></code> in which case the symbol <code class="docutils literal notranslate"><span class="pre">t</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">s.itemType</span></code>.</p>
<p>Note that generic types which have default values for all of their
generic fields, <em>e.g. range</em>, are not generic when simply specified and
require a query to mark the argument as generic. See also
<a class="reference internal" href="#marking-generic-types"><span class="std std-ref">Marking Generic Types</span></a>.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code defines a class with a type field that has a
default value. Function <code class="docutils literal notranslate"><span class="pre">f</span></code> is defined to take an argument of this
class type where the type field is instantiated to the default.
Function <code class="docutils literal notranslate"><span class="pre">g</span></code>, on the other hand, is generic on its argument because
of the use of the question mark.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">t</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// c.type is always int</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">(?))</span> <span class="p">{</span>
  <span class="c1">// c.type may not be int</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="formal-arguments-of-partially-generic-type">
<span id="id7"></span><h3>Formal Arguments of Partially Generic Type<a class="headerlink" href="#formal-arguments-of-partially-generic-type" title="Permalink to this heading">¶</a></h3>
<p>For a formal not declared with the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent (<a class="reference internal" href="procedures.html#the-out-intent"><span class="std std-ref">The Out Intent</span></a>),
the generic type for a formal argument may be specified with some
queries or generic types and some concrete types or values. Using
concrete types or values in this manner makes the argument <em>partially
concrete</em> for the purpose of function resolution.</p>
<blockquote>
<div><p><em>Example (nested-type-queries.chpl)</em>.</p>
<p>Given the code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">elementType</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">indexType</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">containerType</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">containedType</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">(</span><span class="kt">real</span><span class="p">,?</span><span class="nx">t</span><span class="p">,?</span><span class="nx">u</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">f</span></code> can only apply when the <code class="docutils literal notranslate"><span class="pre">c.elementType==real</span></code>.</p>
<p>It’s also possible to use a generic type as an argument to <code class="docutils literal notranslate"><span class="pre">C</span></code>. The
following function, <code class="docutils literal notranslate"><span class="pre">g</span></code>, can only apply when <code class="docutils literal notranslate"><span class="pre">c.containerType</span></code> is
an instance of <code class="docutils literal notranslate"><span class="pre">Container</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">(?</span><span class="nx">t</span><span class="p">,?</span><span class="nx">u</span><span class="p">,</span><span class="nx">Container</span><span class="p">(?)))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Similarly, a tuple type with query arguments forms a <em>partially
concrete</em> argument.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The function definition</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">(?</span><span class="nx">t</span><span class="p">,</span><span class="kt">real</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// body</span>
<span class="p">}</span>
</pre></div>
</div>
<p>specifies that <code class="docutils literal notranslate"><span class="pre">tuple.size</span> <span class="pre">==</span> <span class="pre">2</span> <span class="pre">&amp;&amp;</span> <span class="pre">tuple(2).type</span> <span class="pre">==</span> <span class="pre">real</span></code>.</p>
</div></blockquote>
<p>Homogeneous tuple arguments of generic type are also supported:</p>
<blockquote>
<div><p><em>Example (partially-concrete-star-tuple.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">Number</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="nx">Number</span><span class="p">(?))</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>specifies that <code class="docutils literal notranslate"><span class="pre">f</span></code> accepts a tuple with 2 elements, where each
element has the same type, and that type is instantiation of
<code class="docutils literal notranslate"><span class="pre">Number</span></code>.</p>
</div></blockquote>
<p>Note that specifying a tuple consisting entirely of queried types does
create a <em>partially concrete argument</em> because the size of the tuple is
constrained.</p>
<blockquote>
<div><p><em>Example (partially-concrete-tuple-ambiguity.chpl)</em>.</p>
<p>The following program results in an ambiguity error:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">(?,</span><span class="kt">real</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">(?,?))</span> <span class="p">{</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">(</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>since the <code class="docutils literal notranslate"><span class="pre">tuple</span></code> arguments in both versions of <code class="docutils literal notranslate"><span class="pre">f</span></code> are
<em>partially concrete</em>.</p>
</div></blockquote>
</section>
<section id="formal-arguments-of-generic-array-types">
<span id="id8"></span><h3>Formal Arguments of Generic Array Types<a class="headerlink" href="#formal-arguments-of-generic-array-types" title="Permalink to this heading">¶</a></h3>
<p>If the type of a formal argument is an array where either the domain or
the element type is queried or omitted, and the formal is not declared
with the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent (<a class="reference internal" href="procedures.html#the-out-intent"><span class="std std-ref">The Out Intent</span></a>), the type of the formal
argument is taken to be the type of the actual argument passed to the
function at the call site. If the domain is omitted, the domain of the
formal argument is taken to be the domain of the actual argument.</p>
<p>A queried domain may not be modified via the name to which it is bound
(see <a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a> for rationale).</p>
</section>
</section>
<section id="function-visibility-in-generic-functions">
<span id="id9"></span><h2>Function Visibility in Generic Functions<a class="headerlink" href="#function-visibility-in-generic-functions" title="Permalink to this heading">¶</a></h2>
<p>When resolving a function call, as defined in <a class="reference internal" href="procedures.html#function-resolution"><span class="std std-ref">Function Resolution</span></a>,
there is an additional source of visible functions when the call is
nested within a generic function. The additional source is the functions
visible from the call site that the enclosing generic function is invoked from.
This call site is referred to as the <em>point of instantiation</em>.
If there are multiple enclosing generic functions or the call is nested
within a concrete function that is, in turn, nested in generic function(s),
the point of instantiation is the call site of the innermost generic function.</p>
<p>If no candidate functions are found during the initial steps of
identifying visible and candidate functions, function resolution
continues the search for visible and candidate functions
at the point of instantiation. If still no candidates are found,
the search continues to the point of instantiation of the innermost
generic function that contains the previous point of instantiation.
Once candidate(s) are found, the search succeeds and
function resolution proceeds to selecting the most specific functions.
Otherwise the search will reach a point of instantiation that is not
within a generic function. For example, it can be at the module level or
enclosed in only concrete function(s). If no candidates have been found,
the compiler issues a “call cannot be resolved” error.</p>
<blockquote>
<div><p><em>Example (point-of-instantiation.chpl)</em>.</p>
<p>Consider the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">LibraryA</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">callWorkers</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">worker1</span><span class="p">();</span>
    <span class="nx">worker2</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">LibraryB</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">LibraryA</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">worker1</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in LibraryB&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">libFun</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callWorkers</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">Application</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">LibraryB</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">worker1</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in Application&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">worker2</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in Application&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">libFun</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When resolving the call to <code class="docutils literal notranslate"><span class="pre">worker1</span></code> in <code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code>
there are no visible functions at the scope of the call. Since
<code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code> is a generic function, resolution looks at
its point of instantiation, which is its call within <code class="docutils literal notranslate"><span class="pre">libFun()</span></code>.
There, a single candidate function for <code class="docutils literal notranslate"><span class="pre">worker1</span></code> is found, so
function resolution determines that this is the target function.</p>
<p>Since the search is complete, no further points of instantiation
are visited. Therefore <code class="docutils literal notranslate"><span class="pre">LibraryB</span></code> is assured that whenever
<code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code> looks to its callers for <code class="docutils literal notranslate"><span class="pre">worker1</span></code>,
the implementation in <code class="docutils literal notranslate"><span class="pre">LibraryB</span></code> will be used.
Other overloads, such <code class="docutils literal notranslate"><span class="pre">worker1()</span></code> in module <code class="docutils literal notranslate"><span class="pre">Application</span></code>,
will not be considered.</p>
<p>When resolving the call to <code class="docutils literal notranslate"><span class="pre">worker2</span></code> in <code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code>,
resolution again looks at its point of instantiation, namely
its call within <code class="docutils literal notranslate"><span class="pre">libFun()</span></code>. No visible functions can be found
there. Since <code class="docutils literal notranslate"><span class="pre">libFun</span></code> is also a generic function, the search
continues in turn to its point of instantiation, which is
its call in module <code class="docutils literal notranslate"><span class="pre">Application</span></code>. Since a definition of <code class="docutils literal notranslate"><span class="pre">worker2</span></code>
is visible there, it will be considered the candidate for the call
to <code class="docutils literal notranslate"><span class="pre">worker2</span></code> in <code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code>.</p>
</div></blockquote>
<p>If the generic function is only called indirectly through dynamic
dispatch, the point of instantiation is defined as the point at which
the derived type (the type of the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument) is defined
or instantiated (if the derived type is generic).</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Visible function lookup in Chapel’s generic functions is handled
differently than in C++’s template functions in that there is no
split between dependent and independent types.</p>
<p>Also, dynamic dispatch and instantiation is handled differently.
Chapel supports dynamic dispatch over methods that are generic in
some of its formal arguments.</p>
<p>Note that the Chapel lookup mechanism is still under development and
discussion. Comments or questions are appreciated.</p>
</div></blockquote>
</section>
<section id="generic-types">
<span id="id10"></span><h2>Generic Types<a class="headerlink" href="#generic-types" title="Permalink to this heading">¶</a></h2>
<p>Generic types comprise built-in generic types, generic classes, and
generic records.</p>
<section id="built-in-generic-types">
<span id="id11"></span><h3>Built-in Generic Types<a class="headerlink" href="#built-in-generic-types" title="Permalink to this heading">¶</a></h3>
<p>The types <code class="docutils literal notranslate"><span class="pre">integral</span></code>, <code class="docutils literal notranslate"><span class="pre">numeric</span></code> and <code class="docutils literal notranslate"><span class="pre">enum</span></code> are generic types that
can only be instantiated with, respectively, the signed and unsigned
integral types, all of the numeric types, and all enumerated types. The
type <code class="docutils literal notranslate"><span class="pre">enumerated</span></code> is currently available as a synonym for <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">record</span></code> can be instantiated with any record type.</p>
<p>The memory management strategies <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>,
and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> (see <a class="reference internal" href="classes.html#class-types"><span class="std std-ref">Class Types</span></a>) are also generic
types that can be instantiated with any class using that memory
management strategy. These types indicate generic nilability.</p>
<p>The types <code class="docutils literal notranslate"><span class="pre">class</span></code> and <code class="docutils literal notranslate"><span class="pre">class?</span></code>, on their own or in combination with
memory management strategies, are also generic types. They can be
instantiated as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code> can instantiate with any non-nilable class using any memory
management strategy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class?</span></code> can instantiate with any class using any memory management
strategy but will use the nilable variant of that class in an
instantiation. When used as an argument type, a value of non-nilable
class type will be implicitly converted to the nilable type on the
call. As a result, a formal of type <code class="docutils literal notranslate"><span class="pre">class?</span></code> can accept an actual
of any class type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span></code> can instantiate with any <code class="docutils literal notranslate"><span class="pre">owned</span></code> class - taking the
nilability from whatever it instantiated from.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">class</span></code> can instantiate with any non-nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code> class.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">class?</span></code> can instantiate from any nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code> class. As
with <code class="docutils literal notranslate"><span class="pre">class?</span></code>, it can also instantiate from a non-nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code>
class, in which case a implicit conversion would occur in a call.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">class?</span></code> behave similarly to
the above but with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management strategy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">class?</span></code> behave
similarly to the above but with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management strategy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">class?</span></code> behave
similarly to the above but with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> management strategy.</p></li>
</ul>
</section>
<section id="generic-classes-and-records">
<h3>Generic Classes and Records<a class="headerlink" href="#generic-classes-and-records" title="Permalink to this heading">¶</a></h3>
<p>The remainder of this section <a class="reference internal" href="#generic-types"><span class="std std-ref">Generic Types</span></a> specifies
generic class and record types that are not built-in types
(<a class="reference internal" href="#built-in-generic-types"><span class="std std-ref">Built-in Generic Types</span></a>).</p>
<p>A class or record is generic if it contains one or more generic fields.
A generic field is one of:</p>
<ul class="simple">
<li><p>a specified or unspecified type alias (that is, both <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t=int;</span></code> and
<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">u;</span></code>)</p></li>
<li><p>a parameter field, or</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field that has no type and no initialization
expression.</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field with a generic type marked with <code class="docutils literal notranslate"><span class="pre">(?)</span></code>
and no initialization expression.</p></li>
</ul>
<p>For each generic field, the class or record is parameterized over:</p>
<ul class="simple">
<li><p>the type bound to the type alias,</p></li>
<li><p>the value of the parameter field, or</p></li>
<li><p>the type of the <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field, respectively.</p></li>
</ul>
<p>Correspondingly, the class or record is instantiated with a set of types
and parameter values, one type or value per generic field.</p>
</section>
<section id="type-aliases-in-generic-types">
<span id="id12"></span><h3>Type Aliases in Generic Types<a class="headerlink" href="#type-aliases-in-generic-types" title="Permalink to this heading">¶</a></h3>
<p>If a class or record defines a type alias, the class or record is
generic over the type that is bound to that alias. Such a type alias is
accessed as if it were a field from either a class or record instance or
from the instantiated class or record type itself. Similar to a
parameter field, it cannot be assigned except in its declaration.</p>
<p>The type alias becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">type</span></code> to the
compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Generic Initializer</span></a>) for its class
or record. This makes the compiler-generated initializer generic. The
type alias also becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">type</span></code> to the type
constructor (<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). If the type alias
declaration binds it to a type, that type becomes the default for these
arguments, otherwise they have no defaults.</p>
<p>The class or record is instantiated by binding the type alias to the
actual type passed to the corresponding argument of a user-defined
(<a class="reference internal" href="#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a>) or compiler-generated
initializer or type constructor. If that argument has a default, the
actual type can be omitted, in which case the default will be used
instead.</p>
<blockquote>
<div><p><em>Example (NodeClass.chpl)</em>.</p>
<p>The following code defines a class called <code class="docutils literal notranslate"><span class="pre">Node</span></code> that implements a
linked list data structure. It is generic over the type of the
element contained in the linked list.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">next</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">eltType</span><span class="p">)?;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Node(real,</span> <span class="pre">3.14)</span></code> creates a node in the linked list
that contains the value <code class="docutils literal notranslate"><span class="pre">3.14</span></code>. The <code class="docutils literal notranslate"><span class="pre">next</span></code> field is set to nil.
The type specifier <code class="docutils literal notranslate"><span class="pre">Node</span></code> is a generic type and cannot be used to
define a variable. The type specifier <code class="docutils literal notranslate"><span class="pre">Node(real)</span></code> denotes the type
of the <code class="docutils literal notranslate"><span class="pre">Node</span></code> class instantiated over <code class="docutils literal notranslate"><span class="pre">real</span></code>. Note that the type
of the <code class="docutils literal notranslate"><span class="pre">next</span></code> field is specified as <code class="docutils literal notranslate"><span class="pre">Node(eltType)</span></code>; the type of
<code class="docutils literal notranslate"><span class="pre">next</span></code> is the same type as the type of the object that it is a
field of.</p>
</div></blockquote>
</section>
<section id="parameters-in-generic-types">
<span id="id13"></span><h3>Parameters in Generic Types<a class="headerlink" href="#parameters-in-generic-types" title="Permalink to this heading">¶</a></h3>
<p>If a class or record defines a parameter field, the class or record is
generic over the value that is bound to that field. A parameter field is
always generic, whether or not includes a default. The field can be
accessed from a class or record instance or from the instantiated class
or record type itself.</p>
<p>The parameter becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">param</span></code> to the
compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Generic Initializer</span></a>) for that class
or record. This makes the compiler-generated initializer generic. The
parameter also becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">param</span></code> to the type
constructor (<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). If the parameter
declaration has an initialization expression, that expression becomes
the default for these arguments, otherwise they have no defaults.</p>
<p>The class or record is instantiated by binding the parameter to the
actual value passed to the corresponding argument of a user-defined
(<a class="reference internal" href="#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a>) or compiler-generated
initializer or type constructor. If that argument has a default, the
actual value can be omitted, in which case the default will be used
instead.</p>
<blockquote>
<div><p><em>Example (IntegerTuple.chpl)</em>.</p>
<p>The following code defines a class called <code class="docutils literal notranslate"><span class="pre">IntegerTuple</span></code> that is
generic over an integer parameter which defines the number of
components in the class.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IntegerTuple</span> <span class="p">{</span>
  <span class="kd">param</span> <span class="nx">size</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">size</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">IntegerTuple(3)</span></code> creates an instance of the
<code class="docutils literal notranslate"><span class="pre">IntegerTuple</span></code> class that is instantiated over parameter <code class="docutils literal notranslate"><span class="pre">3</span></code>. The
field <code class="docutils literal notranslate"><span class="pre">data</span></code> becomes a 3-tuple of integers. The type of this class
instance is <code class="docutils literal notranslate"><span class="pre">IntegerTuple(3)</span></code>. The type specified by
<code class="docutils literal notranslate"><span class="pre">IntegerTuple</span></code> is a generic type.</p>
<p><em>Example (MemberWidth.chpl)</em>.</p>
<p>The following code defines a record called <code class="docutils literal notranslate"><span class="pre">R</span></code> that is generic over an
integer parameter <code class="docutils literal notranslate"><span class="pre">width</span></code> that describes the width of the integers
contained in the record’s array field <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
   <span class="kd">param</span> <span class="nx">width</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
   <span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
   <span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">(</span><span class="nx">width</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">config</span> <span class="kd">const</span> <span class="nx">big</span> <span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">big</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
   <span class="nx">writeln</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
   <span class="nx">writeln</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running this example with <code class="docutils literal notranslate"><span class="pre">-sbig=true</span></code> will print out <code class="docutils literal notranslate"><span class="pre">R(64)</span></code>, and with
<code class="docutils literal notranslate"><span class="pre">-sbig=false</span></code> or no argument it will print out <code class="docutils literal notranslate"><span class="pre">R(32)</span></code>.</p>
</div></blockquote>
</section>
<section id="fields-without-types">
<span id="id14"></span><h3>Fields without Types<a class="headerlink" href="#fields-without-types" title="Permalink to this heading">¶</a></h3>
<p>If a <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field in a class or record has no specified
type or initialization expression, the class or record is generic over
the type of that field. The field becomes an argument with default
intent to the compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Generic Initializer</span></a>). That argument
has no specified type and no default value. This makes the
compiler-generated initializer generic. The field also becomes an
argument with <code class="docutils literal notranslate"><span class="pre">type</span></code> intent and no default to the type constructor
(<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). Correspondingly, an actual value
must always be passed to the default initializer argument and an actual
type to the type constructor argument.</p>
<p>The class or record is instantiated by binding the type of the field to
the type of the value passed to the corresponding argument of a
user-defined (<a class="reference internal" href="#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a>) or
compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Generic Initializer</span></a>). When the type
constructor is invoked, the class or record is instantiated by binding
the type of the field to the actual type passed to the corresponding
argument.</p>
<p>Note that records containing fields without types or fields with generic
types (see <a class="reference internal" href="#fields-with-generic-types"><span class="std std-ref">Fields with Generic Types</span></a>) cannot be
default-initialized.</p>
<blockquote>
<div><blockquote>
<div><p><em>Example (fieldWithoutType.chpl)</em>.</p>
<p>The following code defines another class called <code class="docutils literal notranslate"><span class="pre">Node</span></code> that
implements a linked list data structure. It is generic over the type
of the element contained in the linked list. This code does not
specify the element type directly in the class as a type alias but
rather omits the type from the <code class="docutils literal notranslate"><span class="pre">data</span></code> field.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">next</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="kd">type</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A node with integer element type can be defined in the call to the
initializer. The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Node(1)</span></code> defines a node with the value
<code class="docutils literal notranslate"><span class="pre">1</span></code>. The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>defines a two-element list with nodes containing the values <code class="docutils literal notranslate"><span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">2</span></code>. The type of each object could be specified as <code class="docutils literal notranslate"><span class="pre">Node(int)</span></code>.</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="fields-with-generic-types">
<span id="id15"></span><h3>Fields with Generic Types<a class="headerlink" href="#fields-with-generic-types" title="Permalink to this heading">¶</a></h3>
<p>A field declared with a generic type is similar to a field declared
without any type (<a class="reference internal" href="#fields-without-types"><span class="std std-ref">Fields without Types</span></a>); however, the generic type
constrains the possible field types to instantiations of the generic.
The types for such fields must either be a built-in generic type (see
<a class="reference internal" href="#built-in-generic-types"><span class="std std-ref">Built-in Generic Types</span></a>) or include a <code class="docutils literal notranslate"><span class="pre">?</span></code> to mark them as generic
(see <a class="reference internal" href="#marking-generic-types"><span class="std std-ref">Marking Generic Types</span></a>).</p>
<blockquote>
<div><p><em>Example (fieldWithGenericType.chpl)</em>.</p>
<p>This code defines a generic record <code class="docutils literal notranslate"><span class="pre">queue</span></code> and then a generic record
<code class="docutils literal notranslate"><span class="pre">wrapper</span></code> that uses a field to hold a <code class="docutils literal notranslate"><span class="pre">queue</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">queue</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">record</span> <span class="nc">wrapper</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">q</span><span class="p">:</span> <span class="nx">queue</span><span class="p">(?);</span> <span class="c1">// indicates &#39;q&#39; is generic but is an instantiation</span>
                   <span class="c1">// of &#39;queue&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="the-type-constructor">
<span id="type-constructors"></span><h3>The Type Constructor<a class="headerlink" href="#the-type-constructor" title="Permalink to this heading">¶</a></h3>
<p>A type constructor is automatically created for each class or record. A
type constructor is a type function (<a class="reference internal" href="procedures.html#type-return-intent"><span class="std std-ref">The Type Return Intent</span></a>) that has
the same name as the class or record. It takes one argument per the
class’s or record’s generic field, including fields inherited from the
superclasses, if any. The formal argument has intent <code class="docutils literal notranslate"><span class="pre">type</span></code> for a type
alias field and is a parameter for a parameter field. It accepts the type
to be bound to the type alias and the value to be bound to the parameter,
respectively. For a generic <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field, the corresponding
formal argument also has intent <code class="docutils literal notranslate"><span class="pre">type</span></code>. It accepts the type of the
field, as opposed to a value as is the case for a parameter field. The
formal arguments occur in the same order as the fields are declared and
formals for <code class="docutils literal notranslate"><span class="pre">type</span></code>/<code class="docutils literal notranslate"><span class="pre">param</span></code> fields have the same names as the
corresponding fields. Unlike the compiler-generated initializer, the type
constructor only has arguments that correspond to generic fields.</p>
<p>A call to a type constructor accepts actual types and parameter values
and returns the type of the class or record that is instantiated
appropriately for each field
(<a class="reference internal" href="#type-aliases-in-generic-types"><span class="std std-ref">Type Aliases in Generic Types</span></a>,
<a class="reference internal" href="#parameters-in-generic-types"><span class="std std-ref">Parameters in Generic Types</span></a>,
<a class="reference internal" href="#fields-without-types"><span class="std std-ref">Fields without Types</span></a>).
A call to a type constructor need not include actual arguments for each
generic field if it ends with a <code class="docutils literal notranslate"><span class="pre">?</span></code> argument. This argument indicates
that the remaining arguments should remain generic. Additionally, for a
generic type <code class="docutils literal notranslate"><span class="pre">T</span></code>, in some cases it is necessary to mark the type as
generic, and that can be done by writing <code class="docutils literal notranslate"><span class="pre">T(?)</span></code>.</p>
<p>When a generic field declaration has an initialization expression or a
type alias is specified, that initializer becomes the default value for
the corresponding type constructor argument. Uninitialized fields,
including all generic <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span></code> fields, and unspecified type
aliases result in arguments with no defaults; actual types or values for
these arguments must always be provided when invoking the type
constructor.</p>
</section>
<section id="fully-defaulted-generic-types">
<span id="id16"></span><h3>Fully Defaulted Generic Types<a class="headerlink" href="#fully-defaulted-generic-types" title="Permalink to this heading">¶</a></h3>
<p>A generic record can be written that includes defaults for all <code class="docutils literal notranslate"><span class="pre">type</span></code>
and <code class="docutils literal notranslate"><span class="pre">param</span></code> fields and does not use any other generic fields. Such a
generic record type is called a <em>fully defaulted generic</em> type.</p>
<p>For a fully defaulted generic type <code class="docutils literal notranslate"><span class="pre">T</span></code>, the type expression <code class="docutils literal notranslate"><span class="pre">T</span></code>
refers to the instantiation with defaults. This allows the type to be
used in a manner similar to a concrete type. In contrast, <code class="docutils literal notranslate"><span class="pre">T(?)</span></code>
indicates the fully generic type and ignores the defaults.</p>
<blockquote>
<div><p><em>Example (fully-defaulted.chpl)</em>.</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">fullyDefaulted</span></code> below is an example of a fully-defaulted
type because the <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">param</span></code> fields have defaults. It can
be used in a manner similar to a non-generic type, and in that case,
the default values for the <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">param</span></code> fields will apply.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">fullyDefaulted</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">t</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="nx">fullyDefaulted</span><span class="p">;</span> <span class="c1">// here, &#39;fullyDefaulted&#39; uses the defaults</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// &#39;int(64)&#39;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">p</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// &#39;2&#39;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">fullyDefaulted</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// but, other instantiations are possible</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">t</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// &#39;real(64)&#39;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">p</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// &#39;0&#39;</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="marking-generic-types">
<span id="id17"></span><h3>Marking Generic Types<a class="headerlink" href="#marking-generic-types" title="Permalink to this heading">¶</a></h3>
<p>In order to make it clearer when a type expression <code class="docutils literal notranslate"><span class="pre">T</span></code> refers to a
generic type, the syntax <code class="docutils literal notranslate"><span class="pre">T(?)</span></code> can be used. This syntax will generate
an error if <code class="docutils literal notranslate"><span class="pre">T</span></code> is not a generic type. As a result, writing <code class="docutils literal notranslate"><span class="pre">T(?)</span></code>
communicates to a reader of the code that <code class="docutils literal notranslate"><span class="pre">T</span></code> is a generic type.</p>
<p>Marking is not necessary for the built-in generic types listed in
<a class="reference internal" href="#built-in-generic-types"><span class="std std-ref">Built-in Generic Types</span></a>. For fully defaulted generic types
(<a class="reference internal" href="#fully-defaulted-generic-types"><span class="std std-ref">Fully Defaulted Generic Types</span></a>), marking indicates the generic
type rather than the instantiation with the defaults.</p>
<p>Otherwise, generic types used in the following situations should be
marked with <code class="docutils literal notranslate"><span class="pre">(?)</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>fields declared with generic type (see <a class="reference internal" href="#fields-with-generic-types"><span class="std std-ref">Fields with Generic Types</span></a>)</p></li>
<li><p>variables declared with generic type (see
<a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">Variable Declarations</span></a>)</p></li>
<li><p>formal argument type expressions  (see
<a class="reference internal" href="#formal-arguments-of-generic-type"><span class="std std-ref">Formal Arguments of Generic Type</span></a>)</p></li>
<li><p>declared return or yield types (see <a class="reference internal" href="procedures.html#return-types"><span class="std std-ref">Return Types</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> expressions (see <a class="reference internal" href="classes.html#inheritance"><span class="std std-ref">Inheritance</span></a>)</p></li>
<li><p>generic types passed to a <cite>type</cite> formal argument (see
<a class="reference internal" href="#formal-type-arguments"><span class="std std-ref">Formal Type Arguments</span></a>)</p></li>
</ul>
</div></blockquote>
</section>
<section id="generic-methods">
<span id="id18"></span><h3>Generic Methods<a class="headerlink" href="#generic-methods" title="Permalink to this heading">¶</a></h3>
<p>All methods bound to generic classes or records, including initializers,
are generic over the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument. This is in addition to
being generic over any other argument that is generic.</p>
</section>
<section id="the-compiler-generated-generic-initializer">
<span id="generic-compiler-generated-initializers"></span><h3>The Compiler-Generated Generic Initializer<a class="headerlink" href="#the-compiler-generated-generic-initializer" title="Permalink to this heading">¶</a></h3>
<p>If no user-defined initializers are supplied for a given generic class,
the compiler generates one in a manner similar to that for
concrete classes (<a class="reference internal" href="classes.html#the-compiler-generated-initializer"><span class="std std-ref">The Compiler-Generated Initializer</span></a>).
However, the compiler-generated initializer for a generic class or
record (<a class="reference internal" href="classes.html#the-compiler-generated-initializer"><span class="std std-ref">The Compiler-Generated Initializer</span></a>) is generic
over each argument that corresponds to a generic field, as specified
above.</p>
<p>The argument has intent <code class="docutils literal notranslate"><span class="pre">type</span></code> for a type alias field and has intent
<code class="docutils literal notranslate"><span class="pre">param</span></code> for a parameter field. It accepts the type to be bound to the
type alias and the value to be bound to the parameter, respectively.
This is the same as for the type constructor. For a generic <code class="docutils literal notranslate"><span class="pre">var</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span></code> field, the corresponding formal argument has the default
intent and accepts the value for the field to be initialized with. The
type of the field is inferred automatically to be the type of the
initialization value.</p>
<p>The default values for the generic arguments of the compiler-generated
initializer are the same as for the type constructor
(<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). For example, the arguments
corresponding to the generic <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span></code> fields, if any, never
have defaults, so the corresponding actual values must always be
provided.</p>
</section>
<section id="user-defined-initializers">
<span id="generic-user-initializers"></span><h3>User-Defined Initializers<a class="headerlink" href="#user-defined-initializers" title="Permalink to this heading">¶</a></h3>
<p>If a generic field of a class or record does not have a default value or
type alias, each user-defined initializer for that class must explicitly
initialize that field. In the event that the initializer is called using
an already instantiated type as the receiver, the class or record
instance created by the initializer must have that same instantiated
type.</p>
<blockquote>
<div><p><em>Example (initializersForGenericFields.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyGenericClass</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">t1</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">p1</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">c1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">v1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x1</span><span class="p">:</span> <span class="nx">t1</span><span class="p">;</span> <span class="c1">// this field is not generic</span>

  <span class="kd">type</span> <span class="nx">t5</span> <span class="o">=</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">p5</span> <span class="o">=</span> <span class="s">&quot;a string&quot;</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">c5</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">v5</span> <span class="o">=</span> <span class="mi">555</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x5</span><span class="p">:</span> <span class="nx">t5</span><span class="p">;</span> <span class="c1">// this field is not generic</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">t1</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">p1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t1</span> <span class="o">=</span> <span class="nx">t1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">v1</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
    <span class="c1">// compiler inserts initialization for remaining fields</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t5</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">p5</span><span class="p">,</span> <span class="nx">c5</span><span class="p">,</span> <span class="nx">v5</span><span class="p">,</span> <span class="nx">x5</span><span class="p">,</span>
            <span class="kd">type</span> <span class="nx">t1</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">c1</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">x1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t1</span> <span class="o">=</span> <span class="nx">t1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">v1</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x1</span> <span class="o">=</span> <span class="nx">x1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t5</span> <span class="o">=</span> <span class="nx">t5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p5</span> <span class="o">=</span> <span class="nx">p5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c5</span> <span class="o">=</span> <span class="nx">c5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">v5</span> <span class="o">=</span> <span class="nx">v5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x5</span> <span class="o">=</span> <span class="nx">x5</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// class MyGenericClass</span>

<span class="kd">var</span> <span class="nx">g1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyGenericClass</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">g2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyGenericClass</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="s">&quot;this is g2&quot;</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mi">333</span><span class="p">,</span> <span class="mi">3333</span><span class="p">,</span>
                            <span class="kt">real</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">222</span><span class="p">,</span> <span class="mf">222.2</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
</pre></div>
</div>
<p>The initializers are required to initialize fields <code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">p1</span></code>,
<code class="docutils literal notranslate"><span class="pre">c1</span></code>, and <code class="docutils literal notranslate"><span class="pre">v1</span></code>. Otherwise, field initializations may be omitted
according to previously-described initializer semantics.</p>
</div></blockquote>
</section>
</section>
<section id="user-defined-compiler-diagnostics">
<span id="user-defined-compiler-errors"></span><h2>User-Defined Compiler Diagnostics<a class="headerlink" href="#user-defined-compiler-diagnostics" title="Permalink to this heading">¶</a></h2>
<p>The special compiler diagnostic function calls <code class="docutils literal notranslate"><span class="pre">compilerError</span></code> and
<code class="docutils literal notranslate"><span class="pre">compilerWarning</span></code> generate compiler diagnostic of the indicated
severity if the function containing these calls may be called when the
program is executed and the function call is not eliminated by parameter
folding.</p>
<p>The compiler diagnostic is defined by the actual arguments which must be
string parameters. The diagnostic points to the spot in the Chapel
program from which the function containing the call is called.
Compilation halts if a <code class="docutils literal notranslate"><span class="pre">compilerError</span></code> is encountered whereas it will
continue after encountering a <code class="docutils literal notranslate"><span class="pre">compilerWarning</span></code>.</p>
<blockquote>
<div><p><em>Example (compilerDiagnostics.chpl)</em>.</p>
<p>The following code shows an example of using user-defined compiler
diagnostics to generate warnings and errors:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="k">then</span>
    <span class="nx">compilerError</span><span class="p">(</span><span class="s">&quot;foo() called with non-matching types: &quot;</span><span class="p">,</span>
                  <span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">,</span> <span class="s">&quot; != &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In 2-argument foo...&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">compilerWarning</span><span class="p">(</span><span class="s">&quot;1-argument version of foo called with type: &quot;</span><span class="p">,</span>
                  <span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In generic foo!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first routine generates a compiler error whenever the compiler
encounters a call to it where the two arguments have different types.
It prints out an error message indicating the types of the arguments.
The second routine generates a compiler warning whenever the compiler
encounters a call to it.</p>
<p>Thus, if the program foo.chpl contained the following calls:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="nx">foo</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="linenos">2</span><span class="nx">foo</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span>
<span class="linenos">3</span><span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="linenos">4</span><span class="nx">foo</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
<span class="linenos">5</span><span class="nx">foo</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="s">&quot;bye&quot;</span><span class="p">);</span>
<span class="linenos">6</span><span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>
<span class="linenos">7</span><span class="nx">foo</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>
</pre></div>
</div>
<p>compiling the program would generate output like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>foo.chpl:1:<span class="w"> </span>warning:<span class="w"> </span><span class="m">1</span>-argument<span class="w"> </span>version<span class="w"> </span>of<span class="w"> </span>foo<span class="w"> </span>called<span class="w"> </span>with<span class="w"> </span>type:<span class="w"> </span>real<span class="o">(</span><span class="m">64</span><span class="o">)</span>
foo.chpl:2:<span class="w"> </span>warning:<span class="w"> </span><span class="m">1</span>-argument<span class="w"> </span>version<span class="w"> </span>of<span class="w"> </span>foo<span class="w"> </span>called<span class="w"> </span>with<span class="w"> </span>type:<span class="w"> </span>string
foo.chpl:6:<span class="w"> </span>error:<span class="w"> </span>foo<span class="o">()</span><span class="w"> </span>called<span class="w"> </span>with<span class="w"> </span>non-matching<span class="w"> </span>types:<span class="w"> </span>int<span class="o">(</span><span class="m">64</span><span class="o">)</span><span class="w"> </span>!<span class="o">=</span><span class="w"> </span>real<span class="o">(</span><span class="m">64</span><span class="o">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="creating-general-and-specialized-versions-of-a-function">
<span id="id19"></span><h2>Creating General and Specialized Versions of a Function<a class="headerlink" href="#creating-general-and-specialized-versions-of-a-function" title="Permalink to this heading">¶</a></h2>
<p>The Chapel language facility supports three mechanisms for using generic
functions along with concrete functions. These mechanisms allow users to
create a general generic implementation and also a special
implementation for specific concrete types.</p>
<p>The first mechanism applies to functions. According to the function
resolution rules described in <a class="reference internal" href="procedures.html#function-resolution"><span class="std std-ref">Function Resolution</span></a>, if there is no
implicit conversion involved, functions accepting concrete arguments are
selected in preference to those with a totally generic argument. So,
creating a second version of a generic function that declares a concrete
type will cause the concrete function to be used when the call site
matches its type:</p>
<blockquote>
<div><p><em>Example (specializeGenericFunction.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in generic foo(x)&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in specific foo(x:int)&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myReal</span><span class="p">:</span><span class="kt">real</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">myReal</span><span class="p">);</span> <span class="c1">// outputs &quot;in generic foo(x)&quot;</span>
<span class="kd">var</span> <span class="nx">myInt</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">myInt</span><span class="p">);</span>  <span class="c1">// outputs &quot;in specific foo(x:int)&quot;</span>
<span class="kd">var</span> <span class="nx">myInt8</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">myInt8</span><span class="p">);</span> <span class="c1">// outputs &quot;in generic foo(x)&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p>This program will run the generic foo function if the argument is a
real, but it runs the specific version for int if the argument is an
int.</p>
<p>The second mechanism applies when working with methods on generic types.
When declaring a secondary method, the receiver type can be a
parenthesized expression. In that case, the compiler will evaluate the
parenthesized expression at compile time in order to find the concrete
receiver type. Then, the resolution rules described above will cause the
concrete method to be selected when applicable. For example:</p>
<blockquote>
<div><p><em>Example (specializeGenericMethod.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">MyNode</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">field</span><span class="p">;</span>  <span class="c1">// since no type is specified here, MyNode is a generic type</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">MyNode.foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in generic MyNode.foo()&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="p">(</span><span class="nx">MyNode</span><span class="p">(</span><span class="kt">int</span><span class="p">)).</span><span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in specific MyNode(int).foo()&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myRealNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyNode</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="nx">myRealNode</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// outputs &quot;in generic MyNode.foo()&quot;</span>
<span class="kd">var</span> <span class="nx">myIntNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">myIntNode</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// outputs &quot;in specific MyNode(int).foo()&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p>The third mechanism is to use a where clause. Where clauses limit a
generic method to particular cases. Unlike the previous two cases, a
where clause can be used to declare special implementation of a function
that works with some set of types - in other words, the special
implementation can still be a generic function. See also
<a class="reference internal" href="procedures.html#where-clauses"><span class="std std-ref">Where Clauses</span></a>.</p>
</section>
<section id="example-a-generic-stack">
<span id="example-generic-stack"></span><h2>Example: A Generic Stack<a class="headerlink" href="#example-a-generic-stack" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><em>Example (genericStack.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNode</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">itemType</span><span class="p">;</span>              <span class="c1">// type of item</span>
  <span class="kd">var</span> <span class="nx">item</span><span class="p">:</span> <span class="nx">itemType</span><span class="p">;</span>         <span class="c1">// item in node</span>
  <span class="kd">var</span> <span class="nx">next</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">MyNode</span><span class="p">(</span><span class="nx">itemType</span><span class="p">)?;</span> <span class="c1">// reference to next node (same type)</span>
<span class="p">}</span>

<span class="k">record</span> <span class="nc">Stack</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">itemType</span><span class="p">;</span>             <span class="c1">// type of items</span>
  <span class="kd">var</span> <span class="nx">top</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">MyNode</span><span class="p">(</span><span class="nx">itemType</span><span class="p">)?;</span> <span class="c1">// top node on stack linked list</span>

  <span class="k">proc</span> <span class="nf">ref</span> <span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">itemType</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">top</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">MyNode</span><span class="p">(</span><span class="nx">itemType</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">top</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">ref</span> <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">isEmpty</span> <span class="k">then</span>
      <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;attempt to pop an item off an empty stack&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">oldTop</span> <span class="o">=</span> <span class="nx">top</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">oldItem</span> <span class="o">=</span> <span class="nx">top</span><span class="o">!</span><span class="p">.</span><span class="nx">item</span><span class="p">;</span>
    <span class="nx">top</span> <span class="o">=</span> <span class="nx">top</span><span class="o">!</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="k">delete</span> <span class="nx">oldTop</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">oldItem</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">isEmpty</span> <span class="k">do</span> <span class="k">return</span> <span class="nx">top</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="arrays.html" class="btn btn-neutral float-left" title="Arrays" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="task-parallelism-and-synchronization.html" class="btn btn-neutral float-right" title="Task Parallelism and Synchronization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>