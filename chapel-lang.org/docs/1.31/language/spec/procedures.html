<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Procedures &mdash; Chapel Documentation 1.31</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Iterators" href="iterators.html" />
    <link rel="prev" title="Modules" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.31
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.31";
$pagename = "language/spec/procedures";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#code-structures">Code Structures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Procedures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-calls">Function Calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#procedure-definitions">Procedure Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-without-parentheses">Functions without Parentheses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments">Formal Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#argument-intents">Argument Intents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variable-number-of-arguments">Variable Number of Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return-intents">Return Intents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-bodies">Function Bodies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return-types">Return Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#where-clauses">Where Clauses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nested-functions">Nested Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-and-operator-overloading">Function and Operator Overloading</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-resolution">Function Resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l3"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
      <li>Procedures</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/procedures.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="procedures">
<span id="chapter-procedures"></span><h1>Procedures<a class="headerlink" href="#procedures" title="Permalink to this headline">¶</a></h1>
<p>A <em>function</em> is a code abstraction that can be invoked by a call
expression. Throughout this specification the term “function” is used in
this programming-languages sense, rather than in the mathematical sense.
A function has zero or more <em>formal arguments</em>, or simply <em>formals</em>.
Upon a function call each formal is associated with the corresponding
<em>actual argument</em>, or simply <em>actual</em>. Actual arguments are provided as
part of the call expression, or at the <em>call site</em>. Direct and
indirect recursion is supported.</p>
<p>A function can be a <em>procedure</em>, which completes and returns to the call
site exactly once, returning no result, a single result, or multiple
results aggregated in a tuple. A function can also be an iterator, which
can generate, or <em>yield</em>, multiple results (in sequence and/or in
parallel). A function (either a procedure or an iterator) can be a
<em>method</em> if it is bound to a type (often a class). An <em>operator</em> in this
chapter is a procedure with a special name, which can be invoked using
infix notation, i.e., via a unary or binary expression. This chapter
defines procedures, but most of its contents apply to iterators and
methods as well.</p>
<p>Functions are presented as follows:</p>
<ul class="simple">
<li><p>procedures (this chapter)</p></li>
<li><p>operators <a class="reference internal" href="#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>,
<a class="reference internal" href="expressions.html#binary-expressions"><span class="std std-ref">Operator Expressions</span></a></p></li>
<li><p>iterators <a class="reference internal" href="iterators.html#chapter-iterators"><span class="std std-ref">Iterators</span></a></p></li>
<li><p>methods (when bound to a class) <a class="reference internal" href="classes.html#class-methods"><span class="std std-ref">Class Methods</span></a></p></li>
<li><p>function calls <a class="reference internal" href="#function-calls"><span class="std std-ref">Function Calls</span></a></p></li>
<li><p>various aspects of defining a procedure
<a class="reference internal" href="#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>–<a class="reference internal" href="#nested-functions"><span class="std std-ref">Nested Functions</span></a></p></li>
<li><p>calling external functions from Chapel
<a class="reference internal" href="interoperability.html#calling-external-functions"><span class="std std-ref">Calling External Functions</span></a></p></li>
<li><p>calling Chapel functions from external
functions <a class="reference internal" href="interoperability.html#calling-chapel-functions"><span class="std std-ref">Calling Chapel Functions</span></a></p></li>
<li><p>determining the function to invoke for a given call site: function
and operator overloading <a class="reference internal" href="#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>,
function resolution <a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a></p></li>
</ul>
<div class="section" id="function-calls">
<span id="id1"></span><h2>Function Calls<a class="headerlink" href="#function-calls" title="Permalink to this headline">¶</a></h2>
<p>The syntax to call a non-method function is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>call-expression:
  lvalue-expression ( named-expression-list )
  lvalue-expression [ named-expression-list ]
  parenthesesless-function-identifier

named-expression-list:
  named-expression
  named-expression , named-expression-list

named-expression:
  expression
  identifier = expression

parenthesesless-function-identifier:
  identifier
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">call-expression</span></code> is resolved to a particular function according to
the algorithm for function resolution described
in <a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a>.</p>
<p>Functions can be called using either parentheses or brackets.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>This provides an opportunity to blur the distinction between an array
access and a function call and thereby exploit a possible space/time
tradeoff.</p>
</div></blockquote>
<p>Functions that are defined without parentheses must be called without
parentheses. Functions without parentheses are discussed
in <a class="reference internal" href="#functions-without-parentheses"><span class="std std-ref">Functions without Parentheses</span></a>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">named-expression</span></code> is an expression that may be optionally named. It
provides an actual argument to the function being called. The optional
<code class="docutils literal notranslate"><span class="pre">identifier</span></code> refers to a named formal argument described
in <a class="reference internal" href="#named-arguments"><span class="std std-ref">Named Arguments</span></a>.</p>
<p>Calls to methods are defined in
Section <a class="reference internal" href="classes.html#class-method-calls"><span class="std std-ref">Class Method Calls</span></a>.</p>
</div>
<div class="section" id="procedure-definitions">
<span id="function-definitions"></span><h2>Procedure Definitions<a class="headerlink" href="#procedure-definitions" title="Permalink to this headline">¶</a></h2>
<p>Procedures are defined with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>procedure-declaration-statement:
  privacy-specifier[OPT] procedure-kind[OPT] &#39;proc&#39; identifier argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] function-body
  privacy-specifier[OPT] procedure-kind[OPT] &#39;operator&#39; operator-name argument-list return-intent[OPT] return-type[OPT] where-clause[OPT] function-body

procedure-kind:
  &#39;inline&#39;
  &#39;export&#39;
  &#39;extern&#39;
  &#39;override&#39;

operator-name: one of
  &#39;align&#39; &#39;by&#39;
  + - * / % ** : ! == != &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; &amp; | ^ ~
  = += -= *= /= %= **= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &lt;=&gt; #

argument-list:
  ( formals[OPT] )

formals:
  formal
  formal , formals

formal:
  formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression

formal-type:
  : type-expression

default-expression:
  = expression

variable-argument-expression:
  ... expression
  ...

formal-intent:
  &#39;const&#39;
  &#39;const in&#39;
  &#39;const ref&#39;
  &#39;in&#39;
  &#39;out&#39;
  &#39;inout&#39;
  &#39;ref&#39;
  &#39;param&#39;
  &#39;type&#39;

return-intent:
  &#39;const ref&#39;
  &#39;ref&#39;
  &#39;param&#39;
  &#39;type&#39;

return-type:
  : type-expression

where-clause:
  &#39;where&#39; expression

function-body:
  &#39;do&#39; statement
  block-statement
</pre></div>
</div>
<p>Functions do not require parentheses if they have no arguments. Such
functions are described in <a class="reference internal" href="#functions-without-parentheses"><span class="std std-ref">Functions without Parentheses</span></a>.</p>
<p>Formal arguments can be grouped together using a tuple notation as
described in <a class="reference internal" href="tuples.html#formal-argument-declarations-in-a-tuple"><span class="std std-ref">Splitting a Tuple into Multiple Formal Arguments in a Function Call</span></a>.</p>
<p>Default expressions allow for the omission of actual arguments at the
call site, resulting in the implicit passing of a default value. Default
values are discussed in <a class="reference internal" href="#default-values"><span class="std std-ref">Default Values</span></a>.</p>
<p>The intents <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>,
<code class="docutils literal notranslate"><span class="pre">inout</span></code> and <code class="docutils literal notranslate"><span class="pre">ref</span></code> are discussed in <a class="reference internal" href="#argument-intents"><span class="std std-ref">Argument Intents</span></a>.
The intents <code class="docutils literal notranslate"><span class="pre">param</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span></code> make a function generic and are
discussed in <a class="reference internal" href="generics.html#generic-functions"><span class="std std-ref">Generic Functions</span></a>. If the formal argument’s
type is omitted, generic, or prefixed with a question mark, the function
is also generic and is discussed in <a class="reference internal" href="generics.html#generic-functions"><span class="std std-ref">Generic Functions</span></a>.</p>
<p>Functions can take a variable number of arguments. Such functions are
discussed in <a class="reference internal" href="#variable-length-argument-lists"><span class="std std-ref">Variable Number of Arguments</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> can be used to indicate how the value is returned
from a function. <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> is described further in
<a class="reference internal" href="#return-intent"><span class="std std-ref">Return Intents</span></a>.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Parameter and type procedures are supported. Parameter and type
iterators are currently not supported.</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">return-type</span></code> is optional and is discussed
in <a class="reference internal" href="#return-types"><span class="std std-ref">Return Types</span></a>. A type function may not specify a return
type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">where-clause</span></code> is optional and is discussed
in <a class="reference internal" href="#where-clauses"><span class="std std-ref">Where Clauses</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">function-body</span></code> defines the function’s behavior and is defined
in <a class="reference internal" href="#the-function-body"><span class="std std-ref">Function Bodies</span></a>.  Function bodies may contain return
statements (see <a class="reference internal" href="#the-return-statement"><span class="std std-ref">The Return Statement</span></a>).</p>
<p>Function and operator overloading is supported in Chapel and is
discussed in <a class="reference internal" href="#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>. Operator overloading
is supported on the operators listed above (see <code class="docutils literal notranslate"><span class="pre">operator-name</span></code>).</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> keywords indicate the visibility of
module level procedures to outside modules. By default, procedures are
publicly visible. More details on visibility can be found in
 <a class="reference internal" href="modules.html#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>.</p>
<p>The linkage specifier <code class="docutils literal notranslate"><span class="pre">inline</span></code> indicates that the function body must
be inlined at every call site.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>A Chapel compiler is permitted to inline any function if it
determines there is likely to be a performance benefit to do so.
Hence an error must be reported if the compiler is unable to inline a
procedure with this specifier. One example of a preventable inlining
error is to define a sequence of inlined calls that includes a cycle
back to an inlined procedure.</p>
</div></blockquote>
<p>See the chapter on interoperability
(<a class="reference internal" href="interoperability.html#chapter-interoperability"><span class="std std-ref">Interoperability</span></a>) for details on exported
and imported functions.</p>
</div>
<div class="section" id="functions-without-parentheses">
<span id="id2"></span><h2>Functions without Parentheses<a class="headerlink" href="#functions-without-parentheses" title="Permalink to this headline">¶</a></h2>
<p>Functions do not require parentheses if they have empty argument lists.
Functions declared without parentheses around empty argument lists must
be called without parentheses.</p>
<blockquote>
<div><p><em>Example (function-no-parens.chpl)</em>.</p>
<p>Given the definitions</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In foo&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In bar&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>the procedure <code class="docutils literal notranslate"><span class="pre">foo</span></code> can be called by writing <code class="docutils literal notranslate"><span class="pre">foo</span></code> and the
procedure <code class="docutils literal notranslate"><span class="pre">bar</span></code> can be called by writing <code class="docutils literal notranslate"><span class="pre">bar()</span></code>. It is an error
to use parentheses when calling <code class="docutils literal notranslate"><span class="pre">foo</span></code> or omit them when calling
<code class="docutils literal notranslate"><span class="pre">bar</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="formal-arguments">
<span id="id3"></span><h2>Formal Arguments<a class="headerlink" href="#formal-arguments" title="Permalink to this headline">¶</a></h2>
<p>A formal argument’s intent (<a class="reference internal" href="#argument-intents"><span class="std std-ref">Argument Intents</span></a>) specifies
how the actual argument is passed to the function. If no intent is
specified, the default intent (<a class="reference internal" href="#the-default-intent"><span class="std std-ref">The Default Intent</span></a>) is
applied, resulting in type-dependent behavior.</p>
<div class="section" id="named-arguments">
<span id="id4"></span><h3>Named Arguments<a class="headerlink" href="#named-arguments" title="Permalink to this headline">¶</a></h3>
<p>A formal argument can be named at the call site to explicitly map an
actual argument to a formal argument.</p>
<blockquote>
<div><p><em>Example (named-args.chpl)</em>.</p>
<p>Running the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="o">=</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nx">x</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>will produce the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>2
3
2
3
</pre></div>
</div>
<p>named argument passing is used to map the actual arguments to the
formal arguments. The two function calls are equivalent.</p>
</div></blockquote>
<p>Named arguments are sometimes necessary to disambiguate calls or ignore
arguments with default values. For a function that has many arguments,
it is sometimes good practice to name the arguments at the call site for
compiler-checked documentation.</p>
</div>
<div class="section" id="default-values">
<span id="id5"></span><h3>Default Values<a class="headerlink" href="#default-values" title="Permalink to this headline">¶</a></h3>
<p>Default values can be specified for a formal argument by appending the
assignment operator and a default expression to the declaration of the
formal argument. If the actual argument is omitted from the function
call, the default expression is evaluated when the function call is made
and the evaluated result is passed to the formal argument as if it were
passed from the call site. While the default expression is evaluated at
the time of the function call, it is resolved in the scope of the
definition of the called function, immediately before the called function
is resolved. As a result, a default value expression can refer to
previous formal arguments.</p>
<p>When a default value is provided for a formal argument without a type,
the argument type will be inferred to match the type of the default
value.  This inference is similar to the type inference for variable
declarations (see <a class="reference internal" href="variables.html#local-type-inference"><span class="std std-ref">Local Type Inference</span></a>). However, there is one
difference: when the call provides a corresponding actual argument, and
the actual argument is of a type that includes a runtime component (see
<a class="reference internal" href="types.html#types-with-runtime-components"><span class="std std-ref">Types with Runtime Components</span></a>), the runtime component of the
formal argument’s type will come from the actual argument, rather than
from the default value expression.</p>
<blockquote>
<div><p><em>Example (default-values.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>writes out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>5
7
7
7
5
5
</pre></div>
</div>
<p>Default values are specified for the formal arguments <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code>. The three calls to <code class="docutils literal notranslate"><span class="pre">foo</span></code> are equivalent to the following
three calls where the actual arguments are explicit: <code class="docutils literal notranslate"><span class="pre">foo(5,</span> <span class="pre">7)</span></code>,
<code class="docutils literal notranslate"><span class="pre">foo(7,</span> <span class="pre">7)</span></code>, and <code class="docutils literal notranslate"><span class="pre">foo(5,</span> <span class="pre">5)</span></code>. The example <code class="docutils literal notranslate"><span class="pre">foo(y=5)</span></code> shows how
to use a named argument for <code class="docutils literal notranslate"><span class="pre">y</span></code> in order to use the default value
for <code class="docutils literal notranslate"><span class="pre">x</span></code> in the case when <code class="docutils literal notranslate"><span class="pre">x</span></code> appears earlier than <code class="docutils literal notranslate"><span class="pre">y</span></code> in the
formal argument list.</p>
<p><em>Example (default-array-runtime-type.chpl)</em>.</p>
<p>This example shows that the runtime type of the default expression
does not impact the runtime type of the formal argument in the case
that an actual argument was provided.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">};</span>
<span class="k">proc</span> <span class="nf">createArrayOverD</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">A</span><span class="p">:[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">bar</span><span class="p">(</span><span class="nx">arg</span> <span class="o">=</span> <span class="nx">createArrayOverD</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="k">domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">();</span> <span class="c1">// arg uses the default, so outputs {1..4}</span>

<span class="kd">var</span> <span class="nx">B</span><span class="p">:[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="nx">bar</span><span class="p">(</span><span class="nx">B</span><span class="p">);</span> <span class="c1">// arg refers to B and so has the runtime type from B</span>
        <span class="c1">// so outputs {0..2}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="argument-intents">
<span id="id6"></span><h2>Argument Intents<a class="headerlink" href="#argument-intents" title="Permalink to this headline">¶</a></h2>
<p>Argument intents specify how an actual argument is passed to a function
where it is represented by the corresponding formal argument.</p>
<p>Argument intents are categorized as being either <em>concrete</em> or
<em>abstract</em>. Concrete intents are those in which the semantics of the
intent keyword are independent of the argument’s type. Abstract intents
are those in which the keyword (or lack thereof) expresses a general
intention that will ultimately be implemented via one of the concrete
intents. The specific choice of concrete intent depends on the
argument’s type and may be implementation-defined. Abstract intents are
provided to support productivity and code reuse.</p>
<div class="section" id="concrete-intents">
<span id="id7"></span><h3>Concrete Intents<a class="headerlink" href="#concrete-intents" title="Permalink to this headline">¶</a></h3>
<p>The concrete intents are <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>, <code class="docutils literal notranslate"><span class="pre">ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>.</p>
<div class="section" id="the-in-intent">
<span id="id8"></span><h4>The In Intent<a class="headerlink" href="#the-in-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">in</span></code> is specified as the intent, the formal argument represents a
variable that is copy-initialized from the value of the actual argument,
see <a class="reference internal" href="variables.html#copy-and-move-initialization"><span class="std std-ref">Copy and Move Initialization</span></a>.</p>
<p>For example, for integer arguments, the formal argument will store a copy
of the actual argument.</p>
<p>An implicit conversion for a function call occurs from the actual
argument to the type of the formal.</p>
<p>The formal can be modified within the function, but such changes are
local to the function and not reflected back to the call site.</p>
</div>
<div class="section" id="the-out-intent">
<span id="id9"></span><h4>The Out Intent<a class="headerlink" href="#the-out-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">out</span></code> intent on a formal argument supports return-like behavior.
As such, the type of an <code class="docutils literal notranslate"><span class="pre">out</span></code> formal is not considered when determining
candidate functions or choosing the best candidate (see
<a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a>).</p>
<p>When a function with the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent returns, the actual argument is
set to the formal argument using assignment or possibly initialized
from the formal argument according to <a class="reference internal" href="variables.html#split-initialization"><span class="std std-ref">Split Initialization</span></a>.</p>
<p>Within the function body, an <code class="docutils literal notranslate"><span class="pre">out</span></code> formal argument is initialized
according <a class="reference internal" href="variables.html#split-initialization"><span class="std std-ref">Split Initialization</span></a>. It will start with its default
value if one is supplied and can use the default value for the declared
type if no initialization point is found. The formal argument can be
modified within the function.</p>
<p>Note that the way that type inference works with generic <code class="docutils literal notranslate"><span class="pre">out</span></code> formal
arguments is very different from other formal arguments. In particular,
the type of a generic <code class="docutils literal notranslate"><span class="pre">out</span></code> formal argument is inferred from the
function body rather than from the call site.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the type of an <code class="docutils literal notranslate"><span class="pre">out</span></code> argument needs to be inferred based upon the
call site, there are currently two approaches available:</p>
<blockquote>
<div><ul class="simple">
<li><p>use a separate <code class="docutils literal notranslate"><span class="pre">type</span></code> argument to pass the type</p></li>
<li><p>use the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent instead of the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent</p></li>
</ul>
</div></blockquote>
<p>There is proposal that including a type query (e.g.  <code class="docutils literal notranslate"><span class="pre">?t</span></code> in an
<code class="docutils literal notranslate"><span class="pre">out</span></code> argument will cause the type to be inferred based upon the
call site. However this is not yet implemented, at the time of this
writing.</p>
</div>
</div>
<div class="section" id="the-inout-intent">
<span id="id10"></span><h4>The Inout Intent<a class="headerlink" href="#the-inout-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">inout</span></code> is specified as the intent, the actual argument is
copy-initialized into the formal argument, the called function body is
run, and then the actual argument is set to the formal argument with
assignment. As a result the behavior of the <code class="docutils literal notranslate"><span class="pre">inout</span></code> intent is a
combination of the <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">out</span></code> intents.</p>
<p><code class="docutils literal notranslate"><span class="pre">inout</span></code> intent formals behave the same as <code class="docutils literal notranslate"><span class="pre">in</span></code> formals for the
purposes of determining candidate functions and choosing the best
candidate (see <a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a>).</p>
<p>The actual argument must be a valid lvalue. The formal argument can be
modified within the function.</p>
</div>
<div class="section" id="the-ref-intent">
<span id="id11"></span><h4>The Ref Intent<a class="headerlink" href="#the-ref-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">ref</span></code> is specified as the intent, the actual argument is passed
by reference. Any reads of, or modifications to, the formal argument are
performed directly on the corresponding actual argument at the call
site. The actual argument must be a valid lvalue. The type of the actual
argument must be the same as the type of the formal.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent differs from the <code class="docutils literal notranslate"><span class="pre">inout</span></code> intent in that the
<code class="docutils literal notranslate"><span class="pre">inout</span></code> intent requires copying from/to the actual argument on the way
in/out of the function, while <code class="docutils literal notranslate"><span class="pre">ref</span></code> allows direct access to the actual
argument through the formal argument without copies. Note that
concurrent modifications to the <code class="docutils literal notranslate"><span class="pre">ref</span></code> actual argument by other tasks
may be visible within the function, subject to the memory consistency
model.</p>
</div>
<div class="section" id="the-const-in-intent">
<span id="id12"></span><h4>The Const In Intent<a class="headerlink" href="#the-const-in-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> intent is identical to the <code class="docutils literal notranslate"><span class="pre">in</span></code> intent, except that
modifications to the formal argument are prohibited within the function.</p>
</div>
<div class="section" id="the-const-ref-intent">
<span id="id13"></span><h4>The Const Ref Intent<a class="headerlink" href="#the-const-ref-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent is identical to the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent, except that
modifications to the formal argument are prohibited within the dynamic
scope of the function. Note that the same or concurrent tasks may modify the
actual argument while the function is executing and that these modifications
may be visible to reads of the formal argument within the function’s
dynamic scope (subject to the memory consistency model).</p>
</div>
<div class="section" id="summary-of-concrete-intents">
<span id="id14"></span><h4>Summary of Concrete Intents<a class="headerlink" href="#summary-of-concrete-intents" title="Permalink to this headline">¶</a></h4>
<p>The following table summarizes the differences between the concrete
intents:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 13%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">in</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">out</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">inout</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">ref</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>initializes formal from actual?</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>sets actual from formal?</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>refers to actual argument?</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>formal can be read?</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>formal can be modified?</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>local changes affect the actual?</p></td>
<td><p>no</p></td>
<td><p>on return</p></td>
<td><p>on return</p></td>
<td><p>immediately</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="abstract-intents">
<span id="id15"></span><h3>Abstract Intents<a class="headerlink" href="#abstract-intents" title="Permalink to this headline">¶</a></h3>
<p>The abstract intents are <code class="docutils literal notranslate"><span class="pre">const</span></code> and the <em>default intent</em> (when no
intent is specified).</p>
<div class="section" id="the-const-intent">
<span id="id16"></span><h4>The Const Intent<a class="headerlink" href="#the-const-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span></code> intent specifies that the function will not and cannot
modify the formal argument within its dynamic scope. Whether <code class="docutils literal notranslate"><span class="pre">const</span></code>
is interpreted as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent depends on the
argument type.  Generally, small values, such as scalar types, will be
passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>; while larger values, such as domains and
arrays, will be passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent. The
<a class="reference internal" href="#abstract-intents-table"><span class="std std-ref">Abstract Intents Table</span></a> below lists the meaning of the <code class="docutils literal notranslate"><span class="pre">const</span></code>
intent for each type.</p>
</div>
<div class="section" id="the-default-intent">
<span id="id17"></span><h4>The Default Intent<a class="headerlink" href="#the-default-intent" title="Permalink to this headline">¶</a></h4>
<p>When no intent is specified for a formal argument, the <em>default
intent</em> is applied.  It is designed to take the most natural/least
surprising action for the argument, based on its type.  In practice,
this is <code class="docutils literal notranslate"><span class="pre">const</span></code> for most types (as defined by
<a class="reference internal" href="#the-const-intent"><span class="std std-ref">The Const Intent</span></a>) to avoid surprises for programmers coming
from languages where everything is passed by <code class="docutils literal notranslate"><span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent
by default.  Exceptions are made for types where modification is
considered part of their nature, such as types used for synchronization
(like <code class="docutils literal notranslate"><span class="pre">atomic</span></code>) and arrays.</p>
<p>Default argument passing for tuples applies the default
argument passing strategy to each tuple component as if it
was passed as a separate argument. See <a class="reference internal" href="tuples.html#tuple-argument-intents"><span class="std std-ref">Tuple Argument Intents</span></a>.</p>
<p>The <a class="reference internal" href="#abstract-intents-table"><span class="std std-ref">Abstract Intents Table</span></a> that follows defines the default
intent for each type.</p>
</div>
<div class="section" id="abstract-intents-table">
<span id="id18"></span><h4>Abstract Intents Table<a class="headerlink" href="#abstract-intents-table" title="Permalink to this headline">¶</a></h4>
<p>The following table summarizes what these abstract intents mean for each
type:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 18%" />
<col style="width: 22%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">const</span></code> intent
meaning</p></th>
<th class="head"><p>Default intent meaning</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>scalar types</p>
<p>(<code class="docutils literal notranslate"><span class="pre">bool</span></code>,
<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>,
<code class="docutils literal notranslate"><span class="pre">real</span></code>, <code class="docutils literal notranslate"><span class="pre">imag</span></code>,
<code class="docutils literal notranslate"><span class="pre">complex</span></code>)</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>string-like types</p>
<p>(<code class="docutils literal notranslate"><span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes</span></code>)</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ranges</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>domains / domain maps</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>arrays</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ref</span></code> / <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p>see <a class="reference internal" href="#default-intent-for-arrays-and-record-this"><span class="std std-ref">Default Intent for Arrays and Record ’this’</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>records</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p>see <a class="reference internal" href="#default-intent-for-arrays-and-record-this"><span class="std std-ref">Default Intent for Arrays and Record ’this’</span></a></p></td>
</tr>
<tr class="row-even"><td><p>auto-managed classes
(<code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p>see <a class="reference internal" href="#default-intent-for-owned-and-shared"><span class="std std-ref">Default Intent for ’owned’ and ’shared’</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>non-managed classes</p>
<p>(<code class="docutils literal notranslate"><span class="pre">borrowed</span></code>,
<code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>)</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>tuples</p></td>
<td><p>per-element</p></td>
<td><p>per-element</p></td>
<td><p>see <a class="reference internal" href="tuples.html#tuple-argument-intents"><span class="std std-ref">Tuple Argument Intents</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>unions</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>synchronization types
(<code class="docutils literal notranslate"><span class="pre">atomic</span></code>,
<code class="docutils literal notranslate"><span class="pre">sync</span></code>, <code class="docutils literal notranslate"><span class="pre">single</span></code>)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ref</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="default-intent-for-arrays-and-record-this">
<span id="id19"></span><h4>Default Intent for Arrays and Record ’this’<a class="headerlink" href="#default-intent-for-arrays-and-record-this" title="Permalink to this headline">¶</a></h4>
<p>The default intent for arrays and for a <code class="docutils literal notranslate"><span class="pre">this</span></code> argument of record
type (see <a class="reference internal" href="methods.html#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>) is <code class="docutils literal notranslate"><span class="pre">ref</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>. It is <code class="docutils literal notranslate"><span class="pre">ref</span></code> if the formal argument is modified inside
the function, otherwise it is <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>. Note that neither of these
cause an array or record to be copied by default. The choice between
<code class="docutils literal notranslate"><span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> is similar to and interacts with return intent
overloads (see <a class="reference internal" href="#return-intent-overloads"><span class="std std-ref">Return Intent Overloads</span></a>).</p>
</div>
<div class="section" id="default-intent-for-owned-and-shared">
<span id="id20"></span><h4>Default Intent for ’owned’ and ’shared’<a class="headerlink" href="#default-intent-for-owned-and-shared" title="Permalink to this headline">¶</a></h4>
<p>The default intent for <code class="docutils literal notranslate"><span class="pre">owned</span></code> and <code class="docutils literal notranslate"><span class="pre">shared</span></code> arguments is
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>. Arguments can use the <code class="docutils literal notranslate"><span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> intents to
transfer or share ownership if those arguments apply to <code class="docutils literal notranslate"><span class="pre">owned</span></code> or
<code class="docutils literal notranslate"><span class="pre">shared</span></code> types.</p>
<blockquote>
<div><p><em>Example (owned-any-intent.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">defaultGeneric</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">own</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">SomeClass</span><span class="p">();</span>
<span class="nx">defaultGeneric</span><span class="p">(</span><span class="nx">own</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">own</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="variable-number-of-arguments">
<span id="variable-length-argument-lists"></span><h2>Variable Number of Arguments<a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this headline">¶</a></h2>
<p>Functions can be defined to take a variable number of arguments where
those arguments can have any intent or can be types. A variable number
of parameters is not supported. This allows the call site to pass a
different number of actual arguments. There must be at least one actual
argument.</p>
<p>If the variable argument expression contains an identifier prepended by
a question mark, the number of actual arguments can vary, and the
identifier will be bound to an integer parameter value indicating the
number of arguments at a given call site. If the variable argument
expression contains an expression without a question mark, that
expression must evaluate to an integer parameter value requiring the
call site to pass that number of arguments to the function.</p>
<p>Within the function, the formal argument that is marked with a
variable argument expression is a tuple of the actual arguments.  If
the actual arguments all have the same type, the formal will be a
homogeneous tuple, otherwise it will be a heterogeneous tuple.</p>
<blockquote>
<div><p><em>Example (varargs.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">mywriteln</span><span class="p">(</span><span class="nx">xs</span> <span class="o">..</span><span class="p">.?</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">x</span> <span class="kd">in</span> <span class="nx">xs</span> <span class="k">do</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>defines a generic procedure called <code class="docutils literal notranslate"><span class="pre">mywriteln</span></code> that takes a
variable number of arguments of any type and then writes them out
on separate lines.  The type of <code class="docutils literal notranslate"><span class="pre">xs</span></code> can also be constrained in
the formal argument list to require that the actuals all have the
same type.  For example <code class="docutils literal notranslate"><span class="pre">xs:</span> <span class="pre">string...?k</span></code> would accept a variable
number of string arguments.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (varargs-with-type.chpl)</em>.</p>
<p>Either or both the number of variable arguments and their types can
be specified. For example, a basic procedure to sum the values of
three integers can be written as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="o">..</span><span class="mf">.3</span><span class="p">)</span> <span class="k">do</span> <span class="k">return</span> <span class="nx">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Specifying the type is useful if it is important that each argument
have the same type. Specifying the number is useful in, for example,
defining a method on a class that is instantiated over a rank
parameter.</p>
<p><em>Example (varargs-returns-tuples.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">tuple</span><span class="p">(</span><span class="nx">x</span> <span class="o">..</span><span class="p">.)</span> <span class="k">do</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
<p>defines a generic procedure that is equivalent to building a tuple.
Therefore the expressions <code class="docutils literal notranslate"><span class="pre">tuple(1,</span> <span class="pre">2)</span></code> and <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> are
equivalent, as are the expressions <code class="docutils literal notranslate"><span class="pre">tuple(1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="return-intents">
<span id="return-intent"></span><h2>Return Intents<a class="headerlink" href="#return-intents" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> determines how the value is returned from a
function and in what contexts that function is allowed to be used.
The rules for returning tuples are specified in <a class="reference internal" href="tuples.html#tuple-return-behavior"><span class="std std-ref">Tuple Return Behavior</span></a>.</p>
<div class="section" id="the-default-return-intent">
<span id="default-return-intent"></span><h3>The Default Return Intent<a class="headerlink" href="#the-default-return-intent" title="Permalink to this headline">¶</a></h3>
<p>When no <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> is specified explicitly, the function returns
a value that cannot be used as an lvalue. This value is obtained
by copy-initialization from the returned expression,
see <a class="reference internal" href="variables.html#copy-and-move-initialization"><span class="std std-ref">Copy and Move Initialization</span></a>.</p>
</div>
<div class="section" id="the-ref-return-intent">
<span id="ref-return-intent"></span><h3>The Ref Return Intent<a class="headerlink" href="#the-ref-return-intent" title="Permalink to this headline">¶</a></h3>
<p>When using a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent, the function call is an lvalue
(specifically, a call expression for a procedure and an iterator
variable for an iterator).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent is specified by following the argument list
with the <code class="docutils literal notranslate"><span class="pre">ref</span></code> keyword. The function must return an lvalue that
exists outside of the function’s scope.</p>
<blockquote>
<div><p><em>Example (ref-return-intent.chpl)</em>.</p>
<p>The following code defines a procedure that can be interpreted as a
simple two-element array where the elements are actually module level
variables:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">A</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;array access out of bounds&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Calls to this procedure can be assigned to in order to write to the
“elements” of the array as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>It can be called as an expression to access the “elements” as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>This code outputs the number <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="the-const-ref-return-intent">
<span id="const-ref-return-intent"></span><h3>The Const Ref Return Intent<a class="headerlink" href="#the-const-ref-return-intent" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent is also available. It is a restricted
form of the <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent. Calls to functions marked with the
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent are not lvalue expressions.</p>
</div>
<div class="section" id="return-intent-overloads">
<span id="id21"></span><h3>Return Intent Overloads<a class="headerlink" href="#return-intent-overloads" title="Permalink to this headline">¶</a></h3>
<p>In some situations, it is useful to choose the function called based
upon how the returned value is used. In particular, suppose that there
are two functions that have the same formal arguments and differ only in
their return intent. One might expect such a situation to result in an
error indicating that it is ambiguous which function is called. However,
the Chapel language includes a special rule for determining which
function to call when the candidate functions are otherwise ambiguous
except for their return intent. This rule enables data structures such
as sparse arrays.</p>
<p>See <a class="reference internal" href="#choosing-return-intent-overload"><span class="std std-ref">Choosing Return Intent Overloads Based on Calling Context</span></a> for a detailed
description of how return intent overloads are chosen based upon calling
context.</p>
<blockquote>
<div><p><em>Example (ref-return-intent-pair.chpl)</em>.</p>
<p>Return intent overload can be used to ensure, for example, that the
second element in the pseudo-array is only assigned a value if the
first argument is positive. The following is an example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">doA</span><span class="p">(</span><span class="kd">param</span> <span class="nx">setter</span><span class="p">,</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;array access out of bounds&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="nx">setter</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;cannot assign value to A(1) if A(0) &lt;= 0&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">A</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">doA</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">A</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">doA</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="the-param-return-intent">
<span id="param-return-intent"></span><h3>The Param Return Intent<a class="headerlink" href="#the-param-return-intent" title="Permalink to this headline">¶</a></h3>
<p>A <em>parameter function</em>, or a <em>param function</em>, is a function that
returns a parameter expression. It is specified by following the
function’s argument list by the keyword <code class="docutils literal notranslate"><span class="pre">param</span></code>. It is often, but not
necessarily, generic.</p>
<p>It is a compile-time error if a parameter function does not return a
parameter expression. The result of a parameter function is computed
during compilation and substituted for the call expression.</p>
<blockquote>
<div><p><em>Example (param-functions.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">sumOfSquares</span><span class="p">(</span><span class="kd">param</span> <span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">param</span> <span class="k">do</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">b</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">sumOfSquares</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sumOfSquares</span></code> is a parameter procedure that takes two parameters
as arguments. Calls to this procedure can be used in places where a
parameter expression is required. In this example, the call is used
in the declaration of a homogeneous tuple and so is required to be a
parameter.</p>
</div></blockquote>
<p>Parameter functions may not contain control flow that is not resolved at
compile-time. This includes loops other than the parameter for
loop <a class="reference internal" href="statements.html#parameter-for-loops"><span class="std std-ref">Parameter For Loops</span></a> and conditionals with a
conditional expressions that is not a parameter.</p>
</div>
<div class="section" id="the-type-return-intent">
<span id="type-return-intent"></span><h3>The Type Return Intent<a class="headerlink" href="#the-type-return-intent" title="Permalink to this headline">¶</a></h3>
<p>A <em>type function</em> is a function that returns a type, not a value. It is
specified by following the function’s argument list by the keyword
<code class="docutils literal notranslate"><span class="pre">type</span></code>, without the subsequent return type. It is often, but not
necessarily, generic.</p>
<p>It is a compile-time error if a type function does not return a type.
The result of a type function is computed during compilation.</p>
<p>As with parameter functions, type functions may not contain control flow
that is not resolved at compile-time. This includes loops other than the
parameter for loop <a class="reference internal" href="statements.html#parameter-for-loops"><span class="std std-ref">Parameter For Loops</span></a> and conditionals
with a conditional expression that is not a parameter.</p>
<blockquote>
<div><p><em>Example (type-functions.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">myType</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="kd">type</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">numBits</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">32</span> <span class="k">then</span> <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">myType</span></code> is a type procedure that takes a single argument <code class="docutils literal notranslate"><span class="pre">x</span></code> and
returns <code class="docutils literal notranslate"><span class="pre">int(32)</span></code> if the number of bits used to represent <code class="docutils literal notranslate"><span class="pre">x</span></code> is
less than or equal to 32, otherwise it returns <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>.
<code class="docutils literal notranslate"><span class="pre">numBits</span></code> is a param procedure defined in the standard Types
module.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="function-bodies">
<span id="the-function-body"></span><h2>Function Bodies<a class="headerlink" href="#function-bodies" title="Permalink to this headline">¶</a></h2>
<p>The body of a procedure or iterator is made up of one or more
statements that are executed when a call to the function is made.
Function bodies can always be specified using a compound or _block_
statement (<a class="reference internal" href="statements.html#blocks"><span class="std std-ref">Blocks</span></a>), set off by curly brackets.  When a
function’s body is just a single statement, the <cite>do</cite> keyword can be
used as a shorthand for defining the body instead, similar to other
forms of control flow.</p>
<div class="section" id="the-return-statement">
<span id="id22"></span><h3>The Return Statement<a class="headerlink" href="#the-return-statement" title="Permalink to this headline">¶</a></h3>
<p>The return statement can only appear in a function body. It causes
control to exit that function, returning it to the point at which that
function was called.</p>
<p>A procedure can return a value by executing a return statement that
includes an expression. If it does, that expression’s value becomes the
value of the invoking call expression.</p>
<p>A return statement in a procedure of a <code class="docutils literal notranslate"><span class="pre">void</span></code> return type
(<a class="reference internal" href="#return-types"><span class="std std-ref">Return Types</span></a>) or in an iterator must not include an
expression.  A return statement in a procedure of a non-<code class="docutils literal notranslate"><span class="pre">void</span></code>
return type must include an expression.  For procedures with <code class="docutils literal notranslate"><span class="pre">ref</span></code>
or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent, the expression must have storage
associated with it that will outlive the procedure itself.</p>
<p>The statements following a return statement in the same block
are ignored by the compiler because they cannot be executed.</p>
<p>The syntax of the return statement is given by</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>return-statement:
  &#39;return&#39; expression[OPT] ;
</pre></div>
</div>
<blockquote>
<div><p><em>Example (return.chpl)</em>.</p>
<p>The following code defines a procedure that returns the sum of three
integers:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">i1</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">i2</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">i3</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">return</span> <span class="nx">i1</span> <span class="o">+</span> <span class="nx">i2</span> <span class="o">+</span> <span class="nx">i3</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="return-types">
<span id="id23"></span><h2>Return Types<a class="headerlink" href="#return-types" title="Permalink to this headline">¶</a></h2>
<p>Every procedure has a return type. The return type is either specified
explicitly via <code class="docutils literal notranslate"><span class="pre">return-type</span></code> in the procedure declaration, or is
inferred implicitly.</p>
<div class="section" id="explicit-return-types">
<span id="id24"></span><h3>Explicit Return Types<a class="headerlink" href="#explicit-return-types" title="Permalink to this headline">¶</a></h3>
<p>If a return type is specified and is not <code class="docutils literal notranslate"><span class="pre">void</span></code>, each return statement
of the procedure must include an expression. For a non-<code class="docutils literal notranslate"><span class="pre">ref</span></code> return
intent, an implicit conversion occurs from each return expression to the
specified return type. For a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return
intent (<a class="reference internal" href="#ref-return-intent"><span class="std std-ref">The Ref Return Intent</span></a>), the return type must match
the type returned in all of the return statements exactly, when checked
after generic instantiation and parameter folding (if applicable).</p>
</div>
<div class="section" id="implicit-return-types">
<span id="id25"></span><h3>Implicit Return Types<a class="headerlink" href="#implicit-return-types" title="Permalink to this headline">¶</a></h3>
<p>If a return type is not specified, it is inferred from the return
statements. It is illegal for a procedure to have a return statement
with an expression and a return statement without an expression. For
procedures without any return statements, or when none of the return
statements include an expression, the return type is <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>Otherwise, the types of the expressions in all of the procedure’s return
statements are considered. If a function has a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent
(<a class="reference internal" href="#ref-return-intent"><span class="std std-ref">The Ref Return Intent</span></a>), they all must be the same exact
type, which becomes the inferred return type. Otherwise, there must
exist exactly one type such that an implicit conversion is allowed
between every other type and that type, and that type becomes the
inferred return type. If the above requirements are not satisfied, it is
an error.</p>
</div>
</div>
<div class="section" id="where-clauses">
<span id="id26"></span><h2>Where Clauses<a class="headerlink" href="#where-clauses" title="Permalink to this headline">¶</a></h2>
<p>The list of function candidates can be constrained by <em>where clauses</em>. A
where clause is specified in the definition of a
function (<a class="reference internal" href="#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>). The expression in the
where clause must be a boolean parameter expression that evaluates to
either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>. If it evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the function
is rejected and thus is not a possible candidate for function
resolution.</p>
<blockquote>
<div><p><em>Example (whereClause.chpl)</em>.</p>
<p>Given two overloaded function definitions</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="k">where</span> <span class="nx">x</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="kt">int</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="k">where</span> <span class="nx">x</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="kt">real</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;real&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>the call foo(3) resolves to the first definition because the where
clause on the second function evaluates to false.</p>
</div></blockquote>
</div>
<div class="section" id="nested-functions">
<span id="id27"></span><h2>Nested Functions<a class="headerlink" href="#nested-functions" title="Permalink to this headline">¶</a></h2>
<p>A function defined in another function is called a nested function.
Nesting of functions may be done to arbitrary degrees, i.e., a function
can be nested in a nested function.</p>
<p>Nested functions are only visible to function calls within the lexical
scope in which they are defined.</p>
<p>Nested functions may refer to variables defined in the function(s) in
which they are nested.</p>
</div>
<div class="section" id="function-and-operator-overloading">
<span id="function-overloading"></span><h2>Function and Operator Overloading<a class="headerlink" href="#function-and-operator-overloading" title="Permalink to this headline">¶</a></h2>
<p>Functions that have the same name but different argument lists are
called overloaded functions. Function calls to overloaded functions are
resolved according to the function resolution algorithm
in <a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a>.</p>
<p>To define an overloaded operator, use the <code class="docutils literal notranslate"><span class="pre">operator</span></code> keyword to define a
function with the same name as the operator.  The operators that may be
overloaded are listed in the following table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>arity</p></th>
<th class="head"><p>operators</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>unary</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code> <code class="docutils literal notranslate"><span class="pre">-</span></code> <code class="docutils literal notranslate"><span class="pre">!</span></code> <code class="docutils literal notranslate"><span class="pre">~</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>binary</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code> <code class="docutils literal notranslate"><span class="pre">-</span></code> <code class="docutils literal notranslate"><span class="pre">*</span></code> <code class="docutils literal notranslate"><span class="pre">/</span></code> <code class="docutils literal notranslate"><span class="pre">%</span></code> <code class="docutils literal notranslate"><span class="pre">**</span></code> <code class="docutils literal notranslate"><span class="pre">:</span></code></p></td>
</tr>
<tr class="row-even"><td><p>binary</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>binary</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> <code class="docutils literal notranslate"><span class="pre">|</span></code> <code class="docutils literal notranslate"><span class="pre">^</span></code> <code class="docutils literal notranslate"><span class="pre">#</span></code> <code class="docutils literal notranslate"><span class="pre">align</span></code> <code class="docutils literal notranslate"><span class="pre">by</span></code></p></td>
</tr>
<tr class="row-even"><td><p>binary</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code> <code class="docutils literal notranslate"><span class="pre">+=</span></code> <code class="docutils literal notranslate"><span class="pre">-=</span></code> <code class="docutils literal notranslate"><span class="pre">*=</span></code> <code class="docutils literal notranslate"><span class="pre">/=</span></code> <code class="docutils literal notranslate"><span class="pre">%=</span></code> <code class="docutils literal notranslate"><span class="pre">**=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>binary</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;=</span></code> <code class="docutils literal notranslate"><span class="pre">|=</span></code> <code class="docutils literal notranslate"><span class="pre">^=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code></p></td>
</tr>
</tbody>
</table>
<p>The arity and precedence of the operator must be maintained when it is
overloaded. Operator resolution follows the same algorithm as function
resolution.</p>
<p>Assignment overloads are not supported for class types.</p>
</div>
<div class="section" id="function-resolution">
<span id="id28"></span><h2>Function Resolution<a class="headerlink" href="#function-resolution" title="Permalink to this headline">¶</a></h2>
<p><em>Function resolution</em> is the algorithm that determines which
<em>target function</em> to invoke for a given call expression.
Function resolution is defined as follows.</p>
<ul class="simple">
<li><p>Identify the set of visible functions for the function call. A
<em>visible function</em> is any function that satisfies the criteria
in <a class="reference internal" href="#determining-visible-functions"><span class="std std-ref">Determining Visible Functions</span></a>. If no visible
function can be found, the compiler will issue an error stating that
the call cannot be resolved.</p></li>
<li><p>From the set of visible functions for the function call, determine
the set of candidate functions for the function call. A <em>candidate
function</em> is any function that satisfies the criteria
in <a class="reference internal" href="#determining-candidate-functions"><span class="std std-ref">Determining Candidate Functions</span></a>. If no candidate
function can be found and the call is within a generic function,
its point of instantiation(s) are visited searching for candidates
as defined in <a class="reference internal" href="generics.html#function-visibility-in-generic-functions"><span class="std std-ref">Function Visibility in Generic Functions</span></a>.
If still no candidate functions are found,
the compiler will issue an error stating that
the call cannot be resolved. If exactly one candidate function is
found, this is determined to be the target function.</p></li>
<li><p>From the set of candidate functions, determine the set of most
specific functions as described in
 <a class="reference internal" href="#determining-most-specific-functions"><span class="std std-ref">Determining Most Specific Functions</span></a>. In most cases, if the set
of most specific functions contains more than one element, it will
result in an ambiguity error. However, there can be several if they
differ only in return intent.</p></li>
<li><p>From the set of most specific functions, the compiler determines a
best function for each return intent as described in
 <a class="reference internal" href="#determining-best-functions"><span class="std std-ref">Determining Best Functions</span></a>. If there is more than
one best function for a given return intent, the compiler will issue
an error stating that the call is ambiguous. Otherwise, it will choose
the target function from these best functions based on the calling
context as described in <a class="reference internal" href="#choosing-return-intent-overload"><span class="std std-ref">Choosing Return Intent Overloads Based on Calling Context</span></a>.</p></li>
</ul>
<div class="section" id="notation">
<h3>Notation<a class="headerlink" href="#notation" title="Permalink to this headline">¶</a></h3>
<p>This section uses the following notation:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(X\)</span> is a function under consideration</p></li>
<li><p>An actual argument under consideration is <span class="math notranslate nohighlight">\(A_i\)</span> of type
<span class="math notranslate nohighlight">\(T(A_i)\)</span></p></li>
<li><p>The formal argument in function <span class="math notranslate nohighlight">\(X\)</span> that will receive <span class="math notranslate nohighlight">\(A_i\)</span>
is <span class="math notranslate nohighlight">\(X_i\)</span> and it has type <span class="math notranslate nohighlight">\(T(X_i)\)</span>. When <span class="math notranslate nohighlight">\(X\)</span> is a
generic function, <span class="math notranslate nohighlight">\(X_i\)</span> refers to the possibly generic argument
and <span class="math notranslate nohighlight">\(T(X_i)\)</span> refers to the instantiated type.</p></li>
<li><p>When needed in the exposition, <span class="math notranslate nohighlight">\(Y\)</span> is another function under
consideration, where <span class="math notranslate nohighlight">\(A_i\)</span> is passed to the formal <span class="math notranslate nohighlight">\(Y_i\)</span> of
type <span class="math notranslate nohighlight">\(T(Y_i)\)</span>.</p></li>
</ul>
</div>
<div class="section" id="determining-visible-functions">
<span id="id29"></span><h3>Determining Visible Functions<a class="headerlink" href="#determining-visible-functions" title="Permalink to this headline">¶</a></h3>
<p>Given a function call, a function <span class="math notranslate nohighlight">\(X\)</span> is determined to be a
<em>visible function</em> if its name is the same as the name of the
function call and one of the following conditions is met:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(X\)</span> is defined in the same scope as the
function call or in a lexical outer scope of the function call, or</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> is <code class="docutils literal notranslate"><span class="pre">public</span></code> and is declared in a module that is used from
the same scope as the function call or from its lexical outer scope,
see also <a class="reference internal" href="modules.html#using-modules"><span class="std std-ref">Using Modules</span></a>, or</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> is <code class="docutils literal notranslate"><span class="pre">public</span></code> and is declared in a module that is imported from
the same scope as the function call or from its lexical outer scope,
and the call qualifies the function name with the module name,
see also <a class="reference internal" href="modules.html#importing-modules"><span class="std std-ref">Importing Modules</span></a>.</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> is a method and it is defined in the same module that defines
the receiver type.</p></li>
</ul>
</div>
<div class="section" id="determining-candidate-functions">
<span id="id30"></span><h3>Determining Candidate Functions<a class="headerlink" href="#determining-candidate-functions" title="Permalink to this headline">¶</a></h3>
<p>Given a function call, a function is determined to be a <em>candidate
function</em> if there is a <em>valid mapping</em> from the function call to the
function where each actual argument is mapped to a formal argument with
a <em>legal argument mapping</em>.</p>
<div class="section" id="valid-mapping">
<span id="id31"></span><h4>Valid Mapping<a class="headerlink" href="#valid-mapping" title="Permalink to this headline">¶</a></h4>
<p>The following algorithm determines a valid mapping from a function call
to a function if one exists:</p>
<ul class="simple">
<li><p>Each actual argument that is passed by name is matched to the formal
argument with that name. If there is no formal argument with that
name, there is no valid mapping.</p></li>
<li><p>The remaining actual arguments are mapped in order to the remaining
formal arguments in order. If there are more actual arguments then
formal arguments, there is no valid mapping. If any formal argument
that is not mapped to by an actual argument does not have a default
value, there is no valid mapping.</p></li>
<li><p>The valid mapping is the mapping of actual arguments to formal
arguments plus default values to formal arguments that are not mapped
to by actual arguments.</p></li>
</ul>
</div>
<div class="section" id="legal-argument-mapping">
<span id="id32"></span><h4>Legal Argument Mapping<a class="headerlink" href="#legal-argument-mapping" title="Permalink to this headline">¶</a></h4>
<p>An actual argument <span class="math notranslate nohighlight">\(A_i\)</span> of type <span class="math notranslate nohighlight">\(T(A_i)\)</span> can be legally mapped to
a formal argument <span class="math notranslate nohighlight">\(X_i\)</span> according to the following rules.</p>
<p>First, if <span class="math notranslate nohighlight">\(A_i\)</span> is a <code class="docutils literal notranslate"><span class="pre">type</span></code> but <span class="math notranslate nohighlight">\(X_i\)</span> does not use the
<code class="docutils literal notranslate"><span class="pre">type</span></code> intent, then it is not a legal argument mapping.</p>
<p>Then, if <span class="math notranslate nohighlight">\(X_i\)</span> is a generic argument:</p>
<blockquote>
<div><ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses <code class="docutils literal notranslate"><span class="pre">param</span></code> intent, then <span class="math notranslate nohighlight">\(A_i\)</span> must also be a
<code class="docutils literal notranslate"><span class="pre">param</span></code></p></li>
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses <code class="docutils literal notranslate"><span class="pre">type</span></code> intent, then <span class="math notranslate nohighlight">\(A_i\)</span> must also be a
<code class="docutils literal notranslate"><span class="pre">type</span></code></p></li>
<li><p>there must exist an instantiation <span class="math notranslate nohighlight">\(T(X_i)\)</span> of the generic declared
type of <span class="math notranslate nohighlight">\(X_i\)</span>, if any, that is compatible with the type
<span class="math notranslate nohighlight">\(T(A_i)\)</span> according to the rules below.</p></li>
</ul>
</div></blockquote>
<p>Next, the type <span class="math notranslate nohighlight">\(T(X_i)\)</span> - which is either the declared type of the
formal argument <span class="math notranslate nohighlight">\(X_i\)</span> if it is concrete or the instantiated type if
<span class="math notranslate nohighlight">\(X_i\)</span> is generic - must be compatible with the type <span class="math notranslate nohighlight">\(T(A_i)\)</span>
according to the concrete intent of <span class="math notranslate nohighlight">\(X_i\)</span>:</p>
<blockquote>
<div><ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent, then <span class="math notranslate nohighlight">\(T(A_i)\)</span>
must be the same type as <span class="math notranslate nohighlight">\(T(X_i)\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent, then <span class="math notranslate nohighlight">\(T(A_i)\)</span> and
<span class="math notranslate nohighlight">\(T(X_i)\)</span> must be the same type or a subtype of <span class="math notranslate nohighlight">\(T(X_i)\)</span> (see
<a class="reference internal" href="conversions.html#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>)</p></li>
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses <code class="docutils literal notranslate"><span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">inout</span></code> intent, then <span class="math notranslate nohighlight">\(T(A_i)\)</span>
must be the same type, a subtype of, or implicitly convertible to
<span class="math notranslate nohighlight">\(T(X_i)\)</span>.</p></li>
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses  the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent, it is always a legal
argument mapping regardless of the type of the actual and formal.
In the event that setting <span class="math notranslate nohighlight">\(T(A_i)\)</span> from <span class="math notranslate nohighlight">\(X_i\)</span> is not
possible then a compilation error will be emitted if this function
is chosen as the best candidate.</p></li>
<li><p>if <span class="math notranslate nohighlight">\(X_i\)</span> uses the <code class="docutils literal notranslate"><span class="pre">type</span></code> intent, then <span class="math notranslate nohighlight">\(T(A_i)\)</span>
must be the same type or a subtype of <span class="math notranslate nohighlight">\(T(X_i)\)</span> (see
<a class="reference internal" href="conversions.html#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>).</p></li>
</ul>
</div></blockquote>
<p>Finally, if the above compatibility cannot be established, the mapping is
checked for promotion. If <span class="math notranslate nohighlight">\(T(A_i)\)</span> is scalar promotable to <span class="math notranslate nohighlight">\(T(X_i)\)</span>
(see <a class="reference internal" href="data-parallelism.html#promotion"><span class="std std-ref">Promotion</span></a>), then the above rules are checked with the element
type, index type, or yielded type.  For example, if <span class="math notranslate nohighlight">\(T(A_i)\)</span> is an
array of <code class="docutils literal notranslate"><span class="pre">int</span></code> and <span class="math notranslate nohighlight">\(T(X_i)\)</span> is <code class="docutils literal notranslate"><span class="pre">int</span></code>, then promotion occurs and
the above rules will be checked with <span class="math notranslate nohighlight">\(T(A_i)\)</span> == <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</div>
</div>
<div class="section" id="determining-most-specific-functions">
<span id="determining-more-specific-functions"></span><span id="id33"></span><h3>Determining Most Specific Functions<a class="headerlink" href="#determining-most-specific-functions" title="Permalink to this headline">¶</a></h3>
<p>Given a set of candidate functions, the following steps are applied to
remove candidates from the set. After the process completes, the
remaining candidates in the set are the most specific functions.</p>
<ol class="arabic simple">
<li><p>If any candidate is more visible (or shadows) another candidate,
discard all candidates that are less visible than (or shadowed by)
another candidate.</p></li>
<li><p>If at least one candidate requires promotion and at least one
candidate does not use promotion, discard all candidates that use
promotion.</p></li>
<li><p>Discard any function that has a less specific argument mapping than
any other function. See <a class="reference internal" href="#more-specific-argument-mappings"><span class="std std-ref">More Specific Argument Mappings</span></a> below
for details on the more specific argument mapping relation.</p></li>
<li><p>Discard any candidates that have more formals that require implicit
conversion than other candidates. For this step, implicit conversions
between <code class="docutils literal notranslate"><span class="pre">real(w)</span></code>, <code class="docutils literal notranslate"><span class="pre">imag(w)</span></code>, and <code class="docutils literal notranslate"><span class="pre">complex(2*w)</span></code> are not
considered.</p></li>
<li><p>Discard any candidates that have more formals that require a negative
<code class="docutils literal notranslate"><span class="pre">param</span></code> value is converted to an unsigned integral type of any width
(i.e. a <code class="docutils literal notranslate"><span class="pre">uint(?w)</span></code>).</p></li>
<li><p>Discard any candidates that have more formals that require <code class="docutils literal notranslate"><span class="pre">param</span></code>
narrowing conversions than another candidate. A <code class="docutils literal notranslate"><span class="pre">param</span></code> narrowing
conversion is when a <code class="docutils literal notranslate"><span class="pre">param</span></code> value is implicitly converted to a type
that would not normally be allowed. For example, an <code class="docutils literal notranslate"><span class="pre">int</span></code> value
cannot normally implicitly convert to an <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> value. However,
the <code class="docutils literal notranslate"><span class="pre">param</span></code> value <code class="docutils literal notranslate"><span class="pre">1</span></code>, which is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, can implicitly convert to
<code class="docutils literal notranslate"><span class="pre">int(8)</span></code> because the value is known to fit. See also
<a class="reference internal" href="conversions.html#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>.</p></li>
</ol>
<p>Note that <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses are also considered but that happens in a
later step. See <a class="reference internal" href="#determining-best-functions"><span class="std std-ref">Determining Best Functions</span></a>.</p>
<div class="section" id="more-specific-argument-mappings">
<span id="id34"></span><h4>More Specific Argument Mappings<a class="headerlink" href="#more-specific-argument-mappings" title="Permalink to this headline">¶</a></h4>
<p>Given candidate functions <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> with formal arguments
<span class="math notranslate nohighlight">\(X_1\)</span> <span class="math notranslate nohighlight">\(X_2\)</span> … and <span class="math notranslate nohighlight">\(Y_1\)</span> <span class="math notranslate nohighlight">\(Y_2\)</span> … that
correspond to actual arguments <span class="math notranslate nohighlight">\(A_1\)</span> <span class="math notranslate nohighlight">\(A_2\)</span> …, which
candidate function is more specific is determined in two steps. First,
the non-param actual arguments and their corresponding formal arguments
are considered. Then, any param actual arguments and their corresponding
formal arguments are considered.</p>
<p>Within each of those steps, the candidate function <span class="math notranslate nohighlight">\(X\)</span> has a more
specific argument mapping if:</p>
<ul class="simple">
<li><p>for each argument <span class="math notranslate nohighlight">\(i\)</span> considered, the argument mapping from
<span class="math notranslate nohighlight">\(A_i\)</span> to <span class="math notranslate nohighlight">\(Y_i\)</span> is not better than the argument mapping for
the argument <span class="math notranslate nohighlight">\(A_i\)</span> to <span class="math notranslate nohighlight">\(X_i\)</span>, and</p></li>
<li><p>for at least one argument <span class="math notranslate nohighlight">\(j\)</span> considered, the argument mapping
from <span class="math notranslate nohighlight">\(A_j\)</span> to <span class="math notranslate nohighlight">\(X_j\)</span> is better than the argument mapping
from <span class="math notranslate nohighlight">\(A_j\)</span> to <span class="math notranslate nohighlight">\(Y_j\)</span>.</p></li>
</ul>
</div>
<div class="section" id="better-argument-mapping">
<span id="id35"></span><h4>Better Argument Mapping<a class="headerlink" href="#better-argument-mapping" title="Permalink to this headline">¶</a></h4>
<p>Given an actual argument <span class="math notranslate nohighlight">\(A_i\)</span> and the corresponding formal
arguments <span class="math notranslate nohighlight">\(X_i\)</span> and <span class="math notranslate nohighlight">\(Y_i\)</span> (in the functions <span class="math notranslate nohighlight">\(X\)</span> and
<span class="math notranslate nohighlight">\(Y\)</span> being considered), the following rules are applied in order to
determine whether <span class="math notranslate nohighlight">\(X_i\)</span> or <span class="math notranslate nohighlight">\(Y_i\)</span> is a better argument
mapping:</p>
<ol class="arabic simple">
<li><p>If one of the formals requires promotion and the other does not, the
formal not requiring promotion is better</p></li>
<li><p>If both of the formals have the same type after instantiation and one
of the formals is less generic than the other formal, the less-generic
formal is better</p></li>
<li><p>If one of the formals is <code class="docutils literal notranslate"><span class="pre">param</span></code> and the other is not, the <code class="docutils literal notranslate"><span class="pre">param</span></code>
formal is better</p></li>
<li><p>If one of the formals requires a param narrowing conversion and the
other is not, the one not requiring such narrowing is better</p></li>
<li><p>If the actual and both formals are numeric types and one formals is a
preferred numeric conversion target, that formal is better</p></li>
<li><p>If one of the formals matches the actual type exactly and the other
does not, the matching formal is better</p></li>
<li><p>If the actual’s scalar type for promotion matches one of the formals
but not the other, the matching formal is better</p></li>
<li><p>If an implicit conversion is possible from the type of one formal to
the other, but not vice versa, then the formal that can be converted
from is better. (I.e. if the type of <span class="math notranslate nohighlight">\(X_i\)</span> can implicitly
convert to the type of <span class="math notranslate nohighlight">\(Y_i\)</span>, then <span class="math notranslate nohighlight">\(X_i\)</span> is better).
Similarly, if the type of one formal can be instantiated to produce
the type of another formal, the type of the more-instantiated formal
is better.</p></li>
</ol>
</div>
<div class="section" id="preferred-numeric-conversion-target">
<span id="id36"></span><h4>Preferred Numeric Conversion Target<a class="headerlink" href="#preferred-numeric-conversion-target" title="Permalink to this headline">¶</a></h4>
<p>To compute if a formal is a preferred numeric conversion target, apply
the following rules in order:</p>
<ol class="arabic simple">
<li><p>Classify the actual and formals by numeric kind. If one formal has the
same kind as the actual but the other does not, the formal with the
same kind is better. Each of the following bullets represents a
different numeric kind for this rule:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int(?w)</span></code> or <code class="docutils literal notranslate"><span class="pre">uint(?w)</span></code>, that is, a signed or unsigned integral
type of any width</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">real(?w)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">imag(?w)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">complex(?w)</span></code></p></li>
<li><p>all other types</p></li>
</ul>
</li>
<li><p>Classify the actual and formals by numeric width. If one formal has
the same numeric width as the actual but the other does not, the
formal with the same width is better. Each of the following bullets
represents a different numeric width for this rule:</p>
<ul class="simple">
<li><p>All numeric types that match the default width.  This includes
<code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">real</span></code>, <code class="docutils literal notranslate"><span class="pre">imag</span></code>, and <code class="docutils literal notranslate"><span class="pre">complex</span></code>
as well as their more specific names <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>, <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code>,
<code class="docutils literal notranslate"><span class="pre">real(64)</span></code>, <code class="docutils literal notranslate"><span class="pre">imag(64)</span></code>, <code class="docutils literal notranslate"><span class="pre">complex(128)</span></code></p></li>
<li><p>All numeric types with 32-bit width: <code class="docutils literal notranslate"><span class="pre">int(32)</span></code>, <code class="docutils literal notranslate"><span class="pre">uint(32)</span></code>,
<code class="docutils literal notranslate"><span class="pre">real(32)</span></code>, <code class="docutils literal notranslate"><span class="pre">imag(32)</span></code>, <code class="docutils literal notranslate"><span class="pre">complex(64)</span></code>. <code class="docutils literal notranslate"><span class="pre">complex(64)</span></code> is in
this category because the real element width is 32 bits.</p></li>
<li><p>All numeric types with 16-bit width: <code class="docutils literal notranslate"><span class="pre">int(16)</span></code>, <code class="docutils literal notranslate"><span class="pre">uint(16)</span></code></p></li>
<li><p>All numeric types with 8-bit width: <code class="docutils literal notranslate"><span class="pre">int(8)</span></code>, <code class="docutils literal notranslate"><span class="pre">uint(8)</span></code></p></li>
</ul>
</li>
</ol>
</div>
</div>
<div class="section" id="determining-best-functions">
<span id="id37"></span><h3>Determining Best Functions<a class="headerlink" href="#determining-best-functions" title="Permalink to this headline">¶</a></h3>
<p>Given the set of most specific functions for a given return intent, only
the following function(s) are selected as best functions:</p>
<ul class="simple">
<li><p>all functions, if none of them contain a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause;</p></li>
<li><p>only those functions that have a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, otherwise.</p></li>
</ul>
</div>
<div class="section" id="choosing-return-intent-overloads-based-on-calling-context">
<span id="choosing-return-intent-overload"></span><h3>Choosing Return Intent Overloads Based on Calling Context<a class="headerlink" href="#choosing-return-intent-overloads-based-on-calling-context" title="Permalink to this headline">¶</a></h3>
<p>See also <a class="reference internal" href="#return-intent-overloads"><span class="std std-ref">Return Intent Overloads</span></a>.</p>
<p>The compiler can choose between overloads differing in return intent
when:</p>
<ul class="simple">
<li><p>there are zero or one best functions for each of <code class="docutils literal notranslate"><span class="pre">ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, or the default (blank) return intent</p></li>
<li><p>at least two of the above return intents have a best function.</p></li>
</ul>
<p>In that case, the compiler is able to choose between <code class="docutils literal notranslate"><span class="pre">ref</span></code> return,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return, and value return functions based upon the context
of the call. The compiler chooses between these return intent overloads
as follows:</p>
<p>If present, a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return version will be chosen when:</p>
<ul class="simple">
<li><p>the call appears on the left-hand side of a variable initialization
or assignment statement</p></li>
<li><p>the call is passed to another function as a formal argument with
<code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>, or <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent</p></li>
<li><p>the call is captured into a <code class="docutils literal notranslate"><span class="pre">ref</span></code> variable</p></li>
<li><p>the call is returned from a function with <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent</p></li>
</ul>
<p>Otherwise, the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return or value return version will be
chosen. If only one of these is in the set of most specific functions,
it will be chosen. If both are present in the set, the choice will be
made as follows:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> version will be chosen when:</p>
<ul class="simple">
<li><p>the call is passed to another function as a formal argument with
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent</p></li>
<li><p>the call is captured into a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> variable</p></li>
<li><p>the call is returned from a function with <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent</p></li>
</ul>
<p>Otherwise, the value version will be chosen.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="iterators.html" class="btn btn-neutral float-right" title="Iterators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>