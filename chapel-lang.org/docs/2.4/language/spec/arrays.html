<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arrays &mdash; Chapel Documentation 2.4</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=70f659a1" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=4d935f96"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Generics" href="generics.html" />
    <link rel="prev" title="Domains" href="domains.html" />
   
  

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>2.4
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "2.4";
$pagename = "language/spec/arrays";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-structures">Code Structures</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#composite-types">Composite Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="strings.html">Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="bytes.html">Bytes</a></li>
<li class="toctree-l3"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l3"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parallel-safety-with-respect-to-arrays">Parallel Safety with respect to Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-types">Array Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-values">Array Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-indexing">Array Indexing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iteration-over-arrays">Iteration over Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-assignment">Array Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-comparison">Array Comparison</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-slicing">Array Slicing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#count-operator">Count Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#swap-operator">Swap operator <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-arguments-to-functions">Array Arguments to Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#returning-arrays-from-functions">Returning Arrays from Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparse-arrays">Sparse Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#association-of-arrays-to-domains">Association of Arrays to Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-operations-on-associative-arrays">Set Operations on Associative Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#predefined-routines-on-arrays">Predefined Routines on Arrays</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Chapel Language Specification</a></li>
      <li class="breadcrumb-item active">Arrays</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/arrays.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="arrays">
<span id="chapter-arrays"></span><span id="index-0"></span><h1>Arrays<a class="headerlink" href="#arrays" title="Link to this heading">¶</a></h1>
<p>An <em>array</em> is a map from a domain’s indices to a collection of variables
of homogeneous type. Since Chapel domains support a rich variety of
index sets, Chapel arrays are also richer than the traditional linear or
rectilinear array types in conventional languages. Like domains, arrays
may be distributed across multiple locales without explicitly
partitioning them using Chapel’s <a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">distributions</span></a>.</p>
<section id="parallel-safety-with-respect-to-arrays">
<h2>Parallel Safety with respect to Arrays<a class="headerlink" href="#parallel-safety-with-respect-to-arrays" title="Link to this heading">¶</a></h2>
<p>Users must take care when applying operations to arrays and domains
concurrently from distinct tasks. For more information see
<a class="reference internal" href="domains.html#domain-and-array-parallel-safety"><span class="std std-ref">the Parallel Safety section for domains</span></a>.</p>
</section>
<section id="array-types">
<span id="index-1"></span><span id="id1"></span><h2>Array Types<a class="headerlink" href="#array-types" title="Link to this heading">¶</a></h2>
<p>An array type is specified by the identity of the domain that it is
declared over and the element type of the array. Array types are given
by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>array-type:
  [ domain-expression[OPT] ] type-expression[OPT]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">domain-expression</span></code> may specify a domain that the array can be
declared over. If the <code class="docutils literal notranslate"><span class="pre">domain-expression</span></code> is a rectangular domain
literal, the curly braces around the literal may be omitted.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">domain-expression</span></code> and <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> are optional, but
can currently only be omitted when the array type is specified as
one of: a formal type expression, a procedure return type, or an
iterator yield type.</p>
<blockquote>
<div><p><em>Example (decls.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is declared to be an arithmetic array over rectangular domain
<code class="docutils literal notranslate"><span class="pre">D</span></code> with elements of type <code class="docutils literal notranslate"><span class="pre">real</span></code>. As a result, it represents a
2-dimensional <span class="math notranslate nohighlight">\(10 \times 10\)</span> real floating point variables
indexed using the indices
<span class="math notranslate nohighlight">\((1, 1), (1, 2), \ldots, (1, 10), (2, 1), \ldots, (10, 10)\)</span>.</p>
</div></blockquote>
<p>An array’s element type can be referred to using the member symbol
<code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
<blockquote>
<div><p><em>Example (eltType.chpl)</em>.</p>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">x</span></code> is declared to be of type <code class="docutils literal notranslate"><span class="pre">real</span></code>
since that is the element type of array <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">eltType</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="array-values">
<span id="index-2"></span><span id="id2"></span><h2>Array Values<a class="headerlink" href="#array-values" title="Link to this heading">¶</a></h2>
<p>An array’s value is the collection of its elements’ values. Assignments
between array variables are performed by value as described
in <a class="reference internal" href="#array-assignment"><span class="std std-ref">Array Assignment</span></a>.</p>
<p>When an array is stored in a <code class="docutils literal notranslate"><span class="pre">const</span></code> variable, the array elements are
immutable. Undefined behavior will result if the domain is modified (see
<a class="reference internal" href="#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>) since that would necessarily
add or remove elements.</p>
<p>Array literal values can be either rectangular or associative,
corresponding to the underlying domain which defines its indices.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>array-literal:
  rectangular-array-literal
  associative-array-literal
</pre></div>
</div>
<section id="rectangular-array-literals">
<span id="index-3"></span><span id="id3"></span><h3>Rectangular Array Literals<a class="headerlink" href="#rectangular-array-literals" title="Link to this heading">¶</a></h3>
<p>Rectangular array literals are specified by enclosing a
comma-separated list of expressions in square brackets, where each
expression represents an array element’s value. A trailing comma is
permitted after the final array element. For a literal with <cite>n</cite>
expressions, an anonymous domain literal <code class="docutils literal notranslate"><span class="pre">{0..&lt;n}</span></code> is generated to
represent the array’s indices. If the value expressions are all of
the same type, that type will be used as the array’s element type.  If
they are not, the array’s element type is computed using the same type
unification logic that is used when inferring the return type of a
procedure with an implicit return type (see
<a class="reference internal" href="procedures.html#implicit-return-types"><span class="std std-ref">Implicit Return Types</span></a>).</p>
<p>A multi-dimensional rectangular array literal is specified using
comma-separated values in the innermost dimension and semicolons to separate
outer dimensions. An array literal of rank <code class="docutils literal notranslate"><span class="pre">n</span></code> uses <code class="docutils literal notranslate"><span class="pre">n-1</span></code> consecutive
semicolons to separate the outermost dimension. For example, a 3D array literal
will use commas to separate the elements in a row, a semicolon to mark the end
of each row, and two consecutive semicolons to indicate the end of a plane of
values.  Only rectilinear multi-dimensional literals are supported, where the
number of elements in each dimension must be the same. A single trailing
semicolon is permitted after the final row and a trailing comma is permitted
after the final element in each row.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>rectangular-array-literal:
  [ rectangular-array-literal-inner ]
  [ rectangular-array-literal-inner ; ]

rectangular-array-literal-inner:
  array-row
  array-row semicolon-list rectangular-array-literal-inner

array-row:
  expression-list
  expression-list ,

semicolon-list:
 ;
 semicolon-list ;
</pre></div>
</div>
<blockquote>
<div><p><em>Example (adecl-literal.chpl)</em>.</p>
<p>The following example declares a 5 element rectangular array literal
containing strings, then subsequently prints each string element to
the console.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">];</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>Provide syntax which allows users to specify the domain for a
rectangular array literal.</p>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (decl-with-anon-domain.chpl)</em>.</p>
<p>The following example declares a 2-element array <code class="docutils literal notranslate"><span class="pre">A</span></code> containing
3-element arrays of real numbers. <code class="docutils literal notranslate"><span class="pre">A</span></code> is initialized using array
literals.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span> <span class="kt">real</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]];</span>
</pre></div>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (adecl-2x2x3-literal.chpl)</em>.</p>
<p>The following example declares a 2x2x3-element rectangular array literal
containing integers, then subsequently prints each integer element to
the console.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">;</span>
         <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">;</span>
         <span class="p">;</span>
         <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
         <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">];</span>

<span class="k">for</span> <span class="nx">idx</span> <span class="kd">in</span> <span class="nx">A</span><span class="p">.</span><span class="k">domain</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">[</span><span class="nx">idx</span><span class="p">]);</span>
</pre></div>
</div>
</div></blockquote>
<p id="index-4">A rectangular array’s default value is an array in which each element
is initialized to the default value of the element type.</p>
</section>
<section id="associative-array-literals">
<span id="index-5"></span><span id="id4"></span><h3>Associative Array Literals<a class="headerlink" href="#associative-array-literals" title="Link to this heading">¶</a></h3>
<p>Associative array values are specified by enclosing a comma separated
list of index-to-value bindings within square brackets. It is expected
that the indices in the listing match in type and, likewise, the types
of values in the listing also match. A trailing comma is allowed.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>associative-array-literal:
  [ associative-expr-list ]
  [ associative-expr-list , ]

associative-expr-list:
  index-expr =&gt; value-expr
  index-expr =&gt; value-expr, associative-expr-list

index-expr:
  expression

value-expr:
  expression
</pre></div>
</div>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Currently it is not possible to use other associative domains as
values within an associative array literal.</p>
<p><em>Example (adecl-assocLiteral.chpl)</em>.</p>
<p>The following example declares a 5-element associative array literal
which maps integers to their corresponding string representation. The
indices and their corresponding values are then printed.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">=&gt;</span> <span class="s">&quot;ten&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="mi">16</span> <span class="o">=&gt;</span> <span class="s">&quot;sixteen&quot;</span><span class="p">];</span>

<span class="k">for</span> <span class="nx">da</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span> <span class="nx">A</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">da</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="runtime-representation-of-array-values">
<span id="array-runtime-representation"></span><span id="index-6"></span><h3>Runtime Representation of Array Values<a class="headerlink" href="#runtime-representation-of-array-values" title="Link to this heading">¶</a></h3>
<p>The runtime representation of an array in memory is controlled by its
domain’s distribution. Through this mechanism, users can reason about and
control the runtime representation of an array’s elements. See
<a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">Distributions</span></a> for more details.</p>
</section>
</section>
<section id="array-indexing">
<span id="index-7"></span><span id="id5"></span><h2>Array Indexing<a class="headerlink" href="#array-indexing" title="Link to this heading">¶</a></h2>
<p>Arrays can be indexed using index values from the domain over which they
are declared. Array indexing is expressed using either parentheses or
square brackets. This results in a reference to the element that
corresponds to the index value.</p>
<blockquote>
<div><p><em>Example (array-indexing.chpl)</em>.</p>
<p>Given:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>the first two elements of A can be assigned the value 1.2 and 3.4
respectively using the assignment:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
<span class="nx">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.4</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>Except for associative arrays, if an array is indexed using an index
that is not part of its domain’s index set, the reference is considered
out-of-bounds and a runtime error will occur, halting the program.</p>
<section id="rectangular-array-indexing">
<span id="index-8"></span><span id="id6"></span><h3>Rectangular Array Indexing<a class="headerlink" href="#rectangular-array-indexing" title="Link to this heading">¶</a></h3>
<p>Since the indices for multidimensional rectangular domains are tuples,
for convenience, rectangular arrays can be indexed using the list of
integer values that make up the tuple index. This is semantically
equivalent to creating a tuple value out of the integer values and using
that tuple value to index the array. For symmetry, 1-dimensional
rectangular arrays can be accessed using 1-tuple indices even though
their index type is an integral value. This is semantically equivalent
to de-tupling the integral value from the 1-tuple and using it to index
the array.</p>
<blockquote>
<div><p><em>Example (array-indexing-2.chpl)</em>.</p>
<p>Given:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">ij</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>the elements of array A can be indexed using any of the following
idioms:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">(</span><span class="nx">ij</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>
<span class="nx">A</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
<span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.3</span><span class="p">;</span>
<span class="nx">A</span><span class="p">[</span><span class="nx">ij</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">;</span>
<span class="nx">A</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.4</span><span class="p">;</span>
<span class="nx">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (index-using-var-arg-tuple.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">A</span><span class="p">:</span> <span class="p">[],</span> <span class="nx">is</span><span class="o">..</span><span class="p">.)</span> <span class="k">do</span>
  <span class="k">return</span> <span class="nx">A</span><span class="p">(</span><span class="nx">is</span><span class="p">);</span>
</pre></div>
</div>
<p>defines a function that takes an array as the first argument and a
variable-length argument list. It then indexes into the array using
the tuple that captures the actual arguments. This function works
even for one-dimensional arrays because one-dimensional arrays can be
indexed into by 1-tuples.</p>
</div></blockquote>
</section>
<section id="associative-array-indexing">
<span id="index-9"></span><span id="id7"></span><h3>Associative Array Indexing<a class="headerlink" href="#associative-array-indexing" title="Link to this heading">¶</a></h3>
<p>Indices can be added to associative arrays through the array’s domain.</p>
<blockquote>
<div><p><em>Example (assoc-add-index.chpl)</em>.</p>
<p>Given:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">parSafe</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>the array A initially contains no elements. We can change that by
adding indices to the domain D:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">D</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span>
<span class="nx">D</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The array A can now be indexed with indices “a” and “b”:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">A</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="iteration-over-arrays">
<span id="index-10"></span><span id="id8"></span><h2>Iteration over Arrays<a class="headerlink" href="#iteration-over-arrays" title="Link to this heading">¶</a></h2>
<p>All arrays support iteration via standard <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">forall</span></code> and
<code class="docutils literal notranslate"><span class="pre">coforall</span></code> loops. These loops iterate over all of the array elements
as described by its domain. A loop of the form:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">for</span><span class="o">|</span><span class="k">forall</span><span class="o">|</span><span class="k">coforall</span><span class="p">]</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">A</span> <span class="k">do</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">a</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
<p>is semantically equivalent to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">for</span><span class="o">|</span><span class="k">forall</span><span class="o">|</span><span class="k">coforall</span><span class="p">]</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">A</span><span class="p">.</span><span class="k">domain</span> <span class="k">do</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
<p>The iterator variable for an array iteration is a reference to the array
element type.</p>
</section>
<section id="array-assignment">
<span id="index-11"></span><span id="id9"></span><h2>Array Assignment<a class="headerlink" href="#array-assignment" title="Link to this heading">¶</a></h2>
<p>Array assignment is by value. Arrays can be assigned arrays, ranges,
domains, iterators, or tuples as long as the two expressions are
compatible in terms of number of dimensions and shape.</p>
<blockquote>
<div><p><em>Example (assign.chpl)</em>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> is an array variable and <code class="docutils literal notranslate"><span class="pre">B</span></code> is an expression of array,
range, domain, or tuple type, or an iterator, then the assignment</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="o">=</span> <span class="nx">B</span><span class="p">;</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span><span class="nx">B</span><span class="p">)]</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
</pre></div>
</div>
<p>If the zippered iteration is illegal, then the assignment is illegal.
This means, for example, that a range cannot be assigned to a
multidimensional rectangular array because the two expressions don’t
match in shape and can’t be zipped together. Notice that the
assignment is implemented using parallelism when possible, and
serially otherwise.</p>
</div></blockquote>
<p>Arrays can be assigned tuples of values of their element type if the
tuple contains the same number of elements as the array. For
multidimensional arrays, the tuple must be a nested tuple such that the
nesting depth is equal to the rank of the array and the shape of this
nested tuple must match the shape of the array. The values are assigned
element-wise.</p>
<p>Arrays can also be assigned single values of their element type. In this
case, each element in the array is assigned this value.</p>
<blockquote>
<div><p><em>Example (assign-2.chpl)</em>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">e</span></code> is an expression of the element type of the array or a type
that can be implicitly converted to the element type of the array,
then the assignment</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">A</span> <span class="k">do</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="array-comparison">
<h2>Array Comparison<a class="headerlink" href="#array-comparison" title="Link to this heading">¶</a></h2>
<p>With arrays, the equality operator (i.e. ==) is promoted, so the result is an
array of booleans.  To get a single result use the <code class="docutils literal notranslate"><span class="pre">equals</span></code> method instead.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">arr1</span> <span class="o">==</span> <span class="nx">arr2</span> <span class="c1">// compare each element resulting in an array of booleans</span>
<span class="nx">arr1</span> <span class="o">!=</span> <span class="nx">arr2</span> <span class="c1">// compare each element resulting in an array of booleans</span>
<span class="nx">arr1</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">arr2</span><span class="p">)</span> <span class="c1">// compare entire arrays resulting in a single boolean</span>
</pre></div>
</div>
</section>
<section id="array-slicing">
<span id="index-12"></span><span id="id10"></span><h2>Array Slicing<a class="headerlink" href="#array-slicing" title="Link to this heading">¶</a></h2>
<p>An array can be sliced using a domain that has the same type as the
domain over which it was declared. The result of an array slice is an
alias to the subset of the array elements from the original array
corresponding to the slicing domain’s index set.</p>
<blockquote>
<div><p><em>Example (slicing.chpl)</em>.</p>
<p>Given the definitions</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">OuterD</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="o">..</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">InnerD</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">:</span> <span class="p">[</span><span class="nx">OuterD</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>the assignment given by</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">[</span><span class="nx">InnerD</span><span class="p">]</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="nx">InnerD</span><span class="p">];</span>
</pre></div>
</div>
<p>assigns the elements in the interior of <code class="docutils literal notranslate"><span class="pre">B</span></code> to the elements in the
interior of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</div></blockquote>
<section id="rectangular-array-slicing">
<span id="index-13"></span><span id="id11"></span><h3>Rectangular Array Slicing<a class="headerlink" href="#rectangular-array-slicing" title="Link to this heading">¶</a></h3>
<p>A rectangular array can be sliced by any rectangular domain that is a
subdomain of the array’s defining domain. If the subdomain relationship
is not met, an out-of-bounds error will occur. The result is a subarray
whose indices are those of the slicing domain and whose elements are an
alias of the original array’s.</p>
<p>Rectangular arrays also support slicing by ranges directly. If each
dimension is indexed by a range, this is equivalent to slicing the array
by the rectangular domain defined by those ranges. These range-based
slices may also be expressed using partially unbounded or completely
unbounded ranges. This is equivalent to slicing the array’s defining
domain by the specified ranges to create a subdomain as described
in <a class="reference internal" href="#array-slicing"><span class="std std-ref">Array Slicing</span></a> and then using that subdomain to slice
the array.</p>
</section>
<section id="rectangular-array-slicing-with-a-rank-change">
<span id="rectangular-array-slicing-with-rank-change"></span><span id="index-14"></span><h3>Rectangular Array Slicing with a Rank Change<a class="headerlink" href="#rectangular-array-slicing-with-a-rank-change" title="Link to this heading">¶</a></h3>
<p>For multidimensional rectangular arrays, slicing with a rank change is
supported by substituting integral values within a dimension’s range for
an actual range. The resulting array will have a rank less than the
rectangular array’s rank and equal to the number of ranges that are
passed in to take the slice.</p>
<blockquote>
<div><p><em>Example (array-decl.chpl)</em>.</p>
<p>Given an array</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>the slice <code class="docutils literal notranslate"><span class="pre">A[1..n,</span> <span class="pre">1]</span></code> is a one-dimensional array whose elements
are the first column of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</div></blockquote>
</section>
</section>
<section id="count-operator">
<span id="count-operator-arrays"></span><span id="index-15"></span><h2>Count Operator<a class="headerlink" href="#count-operator" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> operator can be applied to dense rectangular arrays with a
tuple argument whose size matches the rank of the array (or optionally
an integer in the case of a 1D array). The operator is equivalent to
applying the <code class="docutils literal notranslate"><span class="pre">#</span></code> operator to the array’s domain and using the result
to slice the array as described in Section <a class="reference internal" href="#rectangular-array-slicing"><span class="std std-ref">Rectangular Array Slicing</span></a>.</p>
</section>
<section id="swap-operator">
<span id="array-swap-operator"></span><span id="index-16"></span><h2>Swap operator <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code><a class="headerlink" href="#swap-operator" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code> operator can be used to swap the contents of two arrays
with the same shape.</p>
</section>
<section id="array-arguments-to-functions">
<span id="index-17"></span><span id="id12"></span><h2>Array Arguments to Functions<a class="headerlink" href="#array-arguments-to-functions" title="Link to this heading">¶</a></h2>
<p>By default, arrays are passed to functions by <code class="docutils literal notranslate"><span class="pre">const</span></code>, see <a class="reference internal" href="procedures.html#the-default-intent"><span class="std std-ref">The Default Intent</span></a>.
Using the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent allows modification of the array without creating a copy.
The <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>, and <code class="docutils literal notranslate"><span class="pre">out</span></code> intent can create copies of arrays.</p>
<p>When a formal argument has array type, the element type of the array can
be omitted and/or the domain of the array can be queried or omitted. In
such cases, the argument is generic and is discussed
in <a class="reference internal" href="generics.html#formal-arguments-of-generic-array-types"><span class="std std-ref">Formal Arguments of Generic Array Types</span></a>.</p>
<p>If a formal array argument specifies a domain as part of its type
signature, the domain of the actual argument must represent the same
index set. If the formal array’s domain was declared using an explicit
distribution, the actual array’s domain must use an equivalent distribution.</p>
<section id="array-promotion-of-scalar-functions">
<span id="index-18"></span><span id="id13"></span><h3>Array Promotion of Scalar Functions<a class="headerlink" href="#array-promotion-of-scalar-functions" title="Link to this heading">¶</a></h3>
<p>Arrays may be passed to a scalar function argument whose type matches
the array’s element type. This results in a promotion of the scalar
function as defined in <a class="reference internal" href="data-parallelism.html#promotion"><span class="std std-ref">Promotion</span></a>.</p>
<blockquote>
<div><p><em>Example (whole-array-ops.chpl)</em>.</p>
<p>Whole array operations is a special case of array promotion of scalar
functions. In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="o">=</span> <span class="nx">B</span> <span class="o">+</span> <span class="nx">C</span><span class="p">;</span>
</pre></div>
</div>
<p>if <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, and <code class="docutils literal notranslate"><span class="pre">C</span></code> are arrays, this code assigns each element
in <code class="docutils literal notranslate"><span class="pre">A</span></code> the element-wise sum of the elements in <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
</div></blockquote>
</section>
</section>
<section id="returning-arrays-from-functions">
<span id="index-19"></span><span id="id14"></span><h2>Returning Arrays from Functions<a class="headerlink" href="#returning-arrays-from-functions" title="Link to this heading">¶</a></h2>
<p>Arrays return by value by default. The <code class="docutils literal notranslate"><span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return
intents can be used to return a reference to an array.</p>
<p>Similarly to array arguments, the element type and/or domain of an array
return type can be omitted.</p>
</section>
<section id="sparse-arrays">
<span id="index-20"></span><span id="id15"></span><h2>Sparse Arrays<a class="headerlink" href="#sparse-arrays" title="Link to this heading">¶</a></h2>
<p>Sparse arrays in Chapel are those whose domain is sparse. A sparse array
differs from other array types in that it stores a single value
corresponding to multiple indices. This value is commonly referred to as
the <em>zero value</em>, but we refer to it as the <em>implicitly replicated
value</em> or <em>IRV</em> since it can take on any value of the array’s element
type in practice including non-zero numeric values, a class reference, a
record or tuple value, etc.</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Sparse domains and arrays are currently unstable.
Their functionality is likely to change in the future.</p>
</div>
</div></blockquote>
<p>An array declared over a sparse domain can be indexed using any of the
indices in the sparse domain’s parent domain. If it is read using an
index that is not part of the sparse domain’s index set, the IRV value
is returned. Otherwise, the array element corresponding to the index is
returned.</p>
<p>Sparse arrays can only be written at locations corresponding to indices
in their domain’s index set. In general, writing to other locations
corresponding to the IRV value will result in a runtime error.</p>
<p>By default a sparse array’s IRV is defined as the default value for the
array’s element type. The IRV can be set to any value of the array’s
element type by assigning to a pseudo-field named <code class="docutils literal notranslate"><span class="pre">IRV</span></code> in the array.</p>
<blockquote>
<div><p><em>Example (sparse-error.chpl)</em>.</p>
<p>The following code example declares a sparse array, <code class="docutils literal notranslate"><span class="pre">SpsA</span></code> using
the sparse domain <code class="docutils literal notranslate"><span class="pre">SpsD</span></code> (For this example, assume that
<code class="docutils literal notranslate"><span class="pre">n</span></code><span class="math notranslate nohighlight">\(&gt;\)</span>1). Line 2 assigns two indices to <code class="docutils literal notranslate"><span class="pre">SpsD</span></code>’s
index set and then lines 3–4 store the values 1.1 and 9.9 to the
corresponding values of <code class="docutils literal notranslate"><span class="pre">SpsA</span></code>. The IRV of <code class="docutils literal notranslate"><span class="pre">SpsA</span></code> will initially
be 0.0 since its element type is <code class="docutils literal notranslate"><span class="pre">real</span></code>. However, the fifth line
sets the IRV to be the value 5.5, causing <code class="docutils literal notranslate"><span class="pre">SpsA</span></code> to represent the
value 1.1 in its low corner, 9.9 in its high corner, and 5.5
everywhere else. The final statement is an error since it attempts to
assign to <code class="docutils literal notranslate"><span class="pre">SpsA</span></code> at an index not described by its domain, <code class="docutils literal notranslate"><span class="pre">SpsD</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">SpsD</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">SpsA</span><span class="p">:</span> <span class="p">[</span><span class="nx">SpsD</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
<span class="nx">SpsD</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">));</span>
<span class="nx">SpsA</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>
<span class="nx">SpsA</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span> <span class="o">=</span> <span class="mf">9.9</span><span class="p">;</span>
<span class="nx">SpsA</span><span class="p">.</span><span class="nx">IRV</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
<span class="nx">SpsA</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="c1">// ERROR!</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="association-of-arrays-to-domains">
<span id="index-21"></span><span id="id16"></span><h2>Association of Arrays to Domains<a class="headerlink" href="#association-of-arrays-to-domains" title="Link to this heading">¶</a></h2>
<p>When an array is declared, it is linked during execution to the domain
identity over which it was declared. This linkage is invariant for the
array’s lifetime and cannot be changed.</p>
<p>When indices are added or removed from a domain, the change impacts the
arrays declared over this particular domain. In the case of adding an
index, an element is added to the array and initialized to the IRV for
sparse arrays, and to the default value for the element type for dense
arrays. In the case of removing an index, the element in the array is
removed.</p>
<p>When a domain is reassigned a new value, its arrays are also impacted.
Values that correspond to indices in the intersection of the old and new
domain are preserved in the arrays. Values that could only be indexed by
the old domain are lost. Values that can only be indexed by the new
domain have elements added to the new array, initialized to the IRV for
sparse arrays, and to the element type’s default value for other array
types.</p>
<p>For performance reasons, there is an expectation that a method will be
added to domains to allow non-preserving assignment, <em>i.e.</em>, all values
in the arrays associated with the assigned domain will be lost. Today
this can be achieved by assigning the array’s domain an empty index set
(causing all array elements to be deallocated) and then re-assigning the
new index set to the domain.</p>
<p>An array’s domain can only be modified directly, via the domain’s name
or an alias created by passing it to a function via default intent. In
particular, the domain may not be modified via the array’s <code class="docutils literal notranslate"><span class="pre">.domain</span></code>
method, nor by using the domain query syntax on a function’s formal
array
argument (<a class="reference internal" href="generics.html#formal-arguments-of-generic-array-types"><span class="std std-ref">Formal Arguments of Generic Array Types</span></a>).</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>When multiple arrays are declared using a single domain, modifying
the domain affects all of the arrays. Allowing an array’s domain to
be queried and then modified suggests that the change should only
affect that array. By requiring the domain to be modified directly,
the user is encouraged to think in terms of the domain distinctly
from a particular array.</p>
<p>In addition, this choice has the beneficial effect that arrays
declared via an anonymous domain have a constant domain. Constant
domains are considered a common case and have potential compilation
benefits such as eliminating bounds checks. Therefore making this
convenient syntax support a common, optimizable case seems prudent.</p>
</div></blockquote>
</section>
<section id="set-operations-on-associative-arrays">
<h2>Set Operations on Associative Arrays<a class="headerlink" href="#set-operations-on-associative-arrays" title="Link to this heading">¶</a></h2>
<p>Associative arrays (and domains) support a number of operators for
set manipulations.  The supported set operators are:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>+ , |</p></td>
<td><p>Union</p></td>
</tr>
<tr class="row-even"><td><p>&amp;</p></td>
<td><p>Intersection</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>Difference</p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>Symmetric Difference</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Consider the following code where <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are associative arrays:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">A</span> <span class="nx">op</span> <span class="nx">B</span><span class="p">;</span>
</pre></div>
</div>
<p>The result <code class="docutils literal notranslate"><span class="pre">C</span></code> is a new associative array backed by a new associative
domain. The domains of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not modified by <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
<p>There are also <code class="docutils literal notranslate"><span class="pre">op=</span></code> variants that store the result into the first operand.</p>
<p>Consider the following code where <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are associative arrays:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="nx">op</span><span class="o">=</span> <span class="nx">B</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> must not share its domain with another array, otherwise the program
will halt with an error message.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">+=</span></code> and <code class="docutils literal notranslate"><span class="pre">|=</span></code> operators, the value from <code class="docutils literal notranslate"><span class="pre">B</span></code> will overwrite
the existing value in <code class="docutils literal notranslate"><span class="pre">A</span></code> when indices overlap.</p>
</section>
<section id="predefined-routines-on-arrays">
<span id="predefined-functions-and-methods-on-arrays"></span><span id="index-22"></span><h2>Predefined Routines on Arrays<a class="headerlink" href="#predefined-routines-on-arrays" title="Link to this heading">¶</a></h2>
<dl class="chpl type">
<dt class="sig sig-object chpl" id="ChapelArray.array">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">array</span></span><em class="property"> <span class="pre">:</span> <span class="pre">writeSerializable,</span> <span class="pre">readDeserializable</span></em><a class="headerlink" href="#ChapelArray.array" title="Link to this definition">¶</a></dt>
<dd><p>The array type</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.eltType">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">eltType</span></span><span class="w"> </span><em class="property"> <span class="pre">type</span></em><a class="headerlink" href="#ChapelArray.eltType" title="Link to this definition">¶</a></dt>
<dd><p>The type of elements contained in the array</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.idxType">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">idxType</span></span><span class="w"> </span><em class="property"> <span class="pre">type</span></em><a class="headerlink" href="#ChapelArray.idxType" title="Link to this definition">¶</a></dt>
<dd><p>The type used to represent the array’s indices.  For a
multidimensional array, this is the per-dimension type used.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.fullIdxType">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">fullIdxType</span></span><span class="w"> </span><em class="property"> <span class="pre">type</span></em><a class="headerlink" href="#ChapelArray.fullIdxType" title="Link to this definition">¶</a></dt>
<dd><p>The type used to represent the array’s indices.  For a
1-dimensional or associative array, this will be the same as
<a class="reference internal" href="#ChapelArray.idxType" title="ChapelArray.idxType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">idxType</span></code></a> above.  For a multidimensional array, it will be
<a class="reference internal" href="#ChapelArray.rank" title="ChapelArray.rank"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">rank</span></code></a> * <a class="reference internal" href="#ChapelArray.idxType" title="ChapelArray.idxType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">idxType</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.rank">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">rank</span></span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.rank" title="Link to this definition">¶</a></dt>
<dd><p>The number of dimensions in the array</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.strides">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">strides</span></span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.strides" title="Link to this definition">¶</a></dt>
<dd><p>The strides value of the underlying domain</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.indices">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">indices</span></span><em class="property">&#160; <span class="pre">where</span> <span class="pre">!this.isSparse()</span> <span class="pre">&amp;&amp;</span> <span class="pre">!this.isAssociative()</span></em><a class="headerlink" href="#ChapelArray.indices" title="Link to this definition">¶</a></dt>
<dd><p>Return a dense rectangular array’s indices as a default domain.</p>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">indices</span></span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isSparse()</span> <span class="pre">||</span> <span class="pre">this.isAssociative()</span></em></dt>
<dd><p>Yield an irregular array’s indices.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.dims">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">dims</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.dims" title="Link to this definition">¶</a></dt>
<dd><p>Return a tuple of ranges describing the bounds of a rectangular domain.
For a sparse domain, return the bounds of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.dim">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.dim" title="Link to this definition">¶</a></dt>
<dd><p>Return a range representing the boundary of this
domain in a particular dimension.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.tryCopy">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">tryCopy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">throws</span></em><a class="headerlink" href="#ChapelArray.tryCopy" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>tryCopy() is subject to change in the future.</p>
</div>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="ChapelArray.these">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">these</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">ref</span></em><a class="headerlink" href="#ChapelArray.these" title="Link to this definition">¶</a></dt>
<dd><p>Yield the array elements</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.size">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">size</span></span><em class="property"> <span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#ChapelArray.size" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of elements in the array</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.sizeAs">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">sizeAs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">integral</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">t</span></em><a class="headerlink" href="#ChapelArray.sizeAs" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of elements in the array as the specified type.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.reindex">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">reindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">newDomain:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.domain.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">newDomain.isRectangular()</span></em><a class="headerlink" href="#ChapelArray.reindex" title="Link to this definition">¶</a></dt>
<dd><p>Return an array view over a new domain. The new domain must be
of the same rank and size as the original array’s domain.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="o">..</span><span class="mi">15</span><span class="p">};</span>
<span class="kd">ref</span> <span class="nx">reA</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">reindex</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
<span class="nx">reA</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// updates A[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">reindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">newDims</span> <span class="pre">...</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.domain.isRectangular()</span></em></dt>
<dd><p>Return an array view over a new domain defined implicitly
by one or more <cite>newDims</cite>, which must be ranges. The new domain must be
of the same rank and size as the original array’s domain.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="o">..</span><span class="mi">6</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">ref</span> <span class="nx">reA</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">reindex</span><span class="p">(</span><span class="mi">13</span><span class="o">..</span><span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="o">..</span><span class="mi">16</span><span class="p">);</span>
<span class="nx">reA</span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// updates A[3,5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.IRV">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">IRV</span></span><em class="property">&#160; <span class="pre">where</span> <span class="pre">!this.isSparse()</span></em><a class="headerlink" href="#ChapelArray.IRV" title="Link to this definition">¶</a></dt>
<dd><p>Return the Implicitly Represented Value for sparse arrays</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.targetLocales">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">targetLocales</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">const</span> <span class="pre">ref</span></em><a class="headerlink" href="#ChapelArray.targetLocales" title="Link to this definition">¶</a></dt>
<dd><p>Return an array of locales over which this array has been distributed.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.hasSingleLocalSubdomain">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasSingleLocalSubdomain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.hasSingleLocalSubdomain" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘hasSingleLocalSubdomain’ on arrays is unstable and may change in the future</p>
</div>
<p>Return true if the local subdomain can be represented as a single
domain. Otherwise return false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.localSubdomain">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">localSubdomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">loc:</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">here</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.localSubdomain" title="Link to this definition">¶</a></dt>
<dd><p>Return the subdomain that is local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>loc</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">locale</span></code></span> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="ChapelArray.localSubdomains">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">localSubdomains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">loc:</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">here</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.localSubdomains" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘localSubdomains’ on arrays is unstable and may change in the future</p>
</div>
<p>Yield the subdomains that are local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>loc</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">locale</span></code></span> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.isEmpty">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isEmpty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#ChapelArray.isEmpty" title="Link to this definition">¶</a></dt>
<dd><p>Return true if the array has no elements</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.last">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">last</span></span><a class="headerlink" href="#ChapelArray.last" title="Link to this definition">¶</a></dt>
<dd><p>Return the last element in the array. The array must be a
rectangular 1-D array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.first">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">first</span></span><a class="headerlink" href="#ChapelArray.first" title="Link to this definition">¶</a></dt>
<dd><p>Return the first element in the array. The array must be a
rectangular 1-D array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.find">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">val:</span> <span class="pre">eltType</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">idx:</span> <span class="pre">fullIdxType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#ChapelArray.find" title="Link to this definition">¶</a></dt>
<dd><p>Search an array for <code class="docutils literal notranslate"><span class="pre">val</span></code>, returning whether or not it is
found.  If the value is found, the index storing it is returned
in <code class="docutils literal notranslate"><span class="pre">idx</span></code>.  If multiple copies of it are found, the
lexicographically earliest index will be returned.  If it is not
found, the resulting value of <code class="docutils literal notranslate"><span class="pre">idx</span></code> is unspecified.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">val:</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">fullIdxType</span></em></dt>
<dd><p>Search a rectangular array with integral indices for <code class="docutils literal notranslate"><span class="pre">val</span></code>,
returning the index where it is found.  If the array contains
multiple copies of <code class="docutils literal notranslate"><span class="pre">val</span></code>, the lexicographically earliest index
will be returned.  If <code class="docutils literal notranslate"><span class="pre">val</span></code> is not found,
<code class="docutils literal notranslate"><span class="pre">domain.lowBound-1</span></code> will be returned instead.</p>
<p>Note that for arrays with <code class="docutils literal notranslate"><span class="pre">idxType=int(?w)</span></code> (signed <code class="docutils literal notranslate"><span class="pre">int</span></code>
indices), if the low bound in a dimension is <code class="docutils literal notranslate"><span class="pre">min(int(w))</span></code>,
the result will not be well-defined.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.count">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">val:</span> <span class="pre">this.eltType</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#ChapelArray.count" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal notranslate"><span class="pre">val</span></code> occurs in the array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.shape">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"> <span class="pre">:</span> <span class="pre">rank*int</span></em><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isRectangular()</span> <span class="pre">||</span> <span class="pre">this.isSparse()</span></em><a class="headerlink" href="#ChapelArray.shape" title="Link to this definition">¶</a></dt>
<dd><p>Return a tuple of integers describing the size of each dimension.
For a sparse array, returns the shape of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.isRectangular">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isRectangular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.isRectangular" title="Link to this definition">¶</a></dt>
<dd><p>Return true if the argument <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with a rectangular
domain.  Otherwise return false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.isIrregular">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isIrregular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.isIrregular" title="Link to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with an irregular domain; e.g. not
rectangular. Otherwise return false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.isAssociative">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isAssociative</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.isAssociative" title="Link to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with an associative domain. Otherwise
return false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.isSparse">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isSparse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><em class="property"> <span class="pre">param</span></em><a class="headerlink" href="#ChapelArray.isSparse" title="Link to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with a sparse domain. Otherwise
return false.</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelArray.array.equals">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">array.</span></span><span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">that:</span> <span class="pre">array</span></em><span class="sig-paren">)</span><em class="property"> <span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#ChapelArray.array.equals" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>the ‘Array.equals()’ method is unstable</p>
</div>
<p>Return true if all this array is the same size and shape
as argument <code class="docutils literal notranslate"><span class="pre">that</span></code> and all elements of this array are
equal to the corresponding element in <code class="docutils literal notranslate"><span class="pre">that</span></code>. Otherwise
return false.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ChapelArray.:">
<em class="property"><span class="pre">operator</span> </em><span class="sig-name descname"><span class="pre">:</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg:</span> <span class="pre">[]</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.:" title="Link to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>casting an array to an array type is unstable due to being a new feature — please share any feedback you might have</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ChapelArray.reshape">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A:</span> <span class="pre">[]</span></em>, <em class="sig-param"><span class="pre">D:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.reshape" title="Link to this definition">¶</a></dt>
<dd><p>Return a copy of the array <code class="docutils literal notranslate"><span class="pre">A</span></code> containing the same values but
in the shape of the domain <code class="docutils literal notranslate"><span class="pre">D</span></code>. The number of indices in the
domain must equal the number of elements in the array. The
elements of <code class="docutils literal notranslate"><span class="pre">A</span></code> are copied into the new array using the
default iteration orders over <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="ChapelArray.localizeConstDomains">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">localizeConstDomains</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">true</span></em><a class="headerlink" href="#ChapelArray.localizeConstDomains" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="ChapelArray.debugLocalizedConstDomains">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">debugLocalizedConstDomains</span></span><span class="w"> </span><em class="property"> <span class="pre">=</span> <span class="pre">false</span></em><a class="headerlink" href="#ChapelArray.debugLocalizedConstDomains" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="domains.html" class="btn btn-neutral float-left" title="Domains" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="generics.html" class="btn btn-neutral float-right" title="Generics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>