

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Domain Map Standard Interface &mdash; Chapel Documentation 1.12 1.12.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  

  
    <link rel="top" title="Chapel Documentation 1.12 1.12.0 documentation" href="../index.html"/>
        <link rel="up" title="Technical Notes" href="index.html"/>
        <link rel="next" title="C Interoperability" href="extern.html"/>
        <link rel="prev" title="Documenting Chapel" href="chpldoc.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> Chapel Documentation</a>
        
        
<?php   // Variables given by sphinx 
   $chplTitle = "1.12";   $pagename = "./technotes/dsi";   include "../versionButton.php";   ?>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/README.html">Quickstart Instructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/README.html#quick-start-instructions">Quick Start Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/README.html#what-s-next">What&#8217;s next?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/prereqs.html">Chapel Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/chplenv.html">Setting up Your Environment for Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/building.html">Building Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/compiling.html">Compiling Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/executing.html">Executing Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/multilocale.html">Multilocale Chapel Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/launcher.html">Chapel Launchers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/tasks.html">Chapel Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/debugging.html">Debugging Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usingchapel/bugs.html">Reporting Chapel Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../platforms/cray.html">Using Chapel on Cray Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/cygwin.html">Using Chapel on Cygwin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/ibm.html">Using Chapel on IBM Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/knc.html">Using Chapel on Intel Xeon Phi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/macosx.html">Using Chapel on Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/marenostrum.html">Using Chapel on MareNostrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/sgi.html">Using Chapel on SGI Altix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/builtins.html">Built-in Types and Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/Atomics.html">Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelArray.html">Domain and Array Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelComplex_forDocs.html">Complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelIO.html">IO Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelIteratorSupport.html">Vectorizing Iterator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelLocale.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelRange.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelSyncvar.html">Synchronization Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelTuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/UtilMisc_forDocs.html">Misc Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standardlibrary.html">Standard Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/distributions.html">Distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/layouts.html">Layouts</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="allocators.html">Chapel&#8217;s Use of Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="atomics.html">Runtime Support for Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="auxIO.html">Auxiliary I/O Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="chpl-ipe.html">Interactive Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="chpldoc.html">Documenting Chapel</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Domain Map Standard Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="extern.html">C Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="firstClassFns.html">First-class Functions in Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="libraries.html">Exporting Chapel as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="llvm.html">LLVM Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="local.html">The &#8216;local&#8217; Statement</a></li>
<li class="toctree-l2"><a class="reference internal" href="localeModels.html">Locale Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="main.html">Support for main() Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_search.html">Module Search Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="reduceIntents.html">Reduce Intents</a></li>
<li class="toctree-l2"><a class="reference internal" href="sets.html">Associative Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="subquery.html">Querying a Local Subdomain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tools/chplvis/index.html">chplvis</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Chapel Documentation 1.12</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Technical Notes</a> &raquo;</li>
      
    <li>Domain Map Standard Interface</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/technotes/dsi.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="domain-map-standard-interface">
<span id="readme-dsi"></span><h1><a class="toc-backref" href="#id1">Domain Map Standard Interface</a><a class="headerlink" href="#domain-map-standard-interface" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#domain-map-standard-interface" id="id1">Domain Map Standard Interface</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a><ul>
<li><a class="reference internal" href="#status-of-this-document" id="id3">Status of this document</a></li>
<li><a class="reference internal" href="#additional-resources" id="id4">Additional Resources</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview" id="id5">Overview</a></li>
<li><a class="reference internal" href="#phase-1-the-essentials" id="id6">Phase 1: The Essentials</a><ul>
<li><a class="reference internal" href="#class-globaldistribution" id="id7">class <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt></a></li>
<li><a class="reference internal" href="#class-globaldomain" id="id8">class <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt></a><ul>
<li><a class="reference internal" href="#a-subdomain-description" id="id9">A. Subdomain Description</a></li>
<li><a class="reference internal" href="#b-follower-yield-order" id="id10">B. Follower Yield Order</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-globalarray" id="id11">class <tt class="docutils literal"><span class="pre">GlobalArray</span></tt></a></li>
<li><a class="reference internal" href="#naming" id="id12">Naming</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phase-2-additional-operations" id="id13">Phase 2: Additional Operations</a></li>
<li><a class="reference internal" href="#phase-3-privatization" id="id14">Phase 3: Privatization</a><ul>
<li><a class="reference internal" href="#what-is-privatization" id="id15">What is privatization?</a></li>
<li><a class="reference internal" href="#how-does-privatization-work-with-dsi" id="id16">How does privatization work with DSI?</a></li>
<li><a class="reference internal" href="#what-is-reprivatization" id="id17">What is reprivatization?</a></li>
<li><a class="reference internal" href="#dsi-privatization-requirements" id="id18">DSI privatization requirements</a></li>
<li><a class="reference internal" href="#tip-testing-privatization" id="id19">Tip: testing privatization</a></li>
<li><a class="reference internal" href="#tip-privatized-copies-should-reference-privatized-copies" id="id20">Tip: privatized copies should reference privatized copies</a></li>
<li><a class="reference internal" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation" id="id21">Tip: &#8220;privatize&#8221; the domains and arrays used in the implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document defines <strong>DSI</strong> &#8211; the Domain map Standard Interface.
It is the interface that a domain map must implement.
This interface is currently in place and is implemented by the standard
domain maps provided with this Chapel distribution.</p>
<p>The specification is split into &#8220;phases&#8221;. The intention is to suggest
an implementation order. The requirements of first phase are relied
upon by the more essential operations on domains and arrays. Later
phases support additional functionality and/or improved performance.
The phasing is approximate and is not required.</p>
<div class="section" id="status-of-this-document">
<h3><a class="toc-backref" href="#id3">Status of this document</a><a class="headerlink" href="#status-of-this-document" title="Permalink to this headline">¶</a></h3>
<p>This document, as well as the DSI interface itself, are work in progress.
We solicit feedback on both.</p>
<p>The following aspects are not documented yet:</p>
<ul class="simple">
<li>a summary of the six descriptor classes</li>
<li>the requirements for a domain map to support
associative, opaque, or sparse domains;</li>
<li>the significance of dsiClone();</li>
<li>the &#8220;local descriptor&#8221; classes;</li>
<li>some required methods.</li>
</ul>
</div>
<div class="section" id="additional-resources">
<h3><a class="toc-backref" href="#id4">Additional Resources</a><a class="headerlink" href="#additional-resources" title="Permalink to this headline">¶</a></h3>
<p>Implementations of the standard domain maps may be consulted as
examples.  They are available in:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>$CHPL_HOME/modules/dists
$CHPL_HOME/modules/layouts
</pre></div>
</div>
</div></blockquote>
<p>In addition, the following publication provide more background
information on domain maps in general.</p>
<ul>
<li><p class="first">&#8220;User-Defined Distributions and Layouts in Chapel: Philosophy and
Framework.&#8221; Bradford L. Chamberlain, Steven J. Deitz, David
Iten, Sung-Eun Choi. 2nd USENIX Workshop on Hot Topics in
Parallelism, June 2010.</p>
<blockquote>
<div><p>The high level motivation and overview of DSI.</p>
<p><a class="reference external" href="https://chapel-lang.org/publications/hotpar10-final.pdf">https://chapel-lang.org/publications/hotpar10-final.pdf</a></p>
</div></blockquote>
</li>
<li><p class="first">&#8220;Authoring User-Defined Domain Maps in Chapel.&#8221;  Bradford
L. Chamberlain, Sung-Eun Choi, Steven J. Deitz, David Iten, Vassily
Litvinov. CUG 2011, May 2011.</p>
<blockquote>
<div><p>A follow-on paper that outlines how to write a domain map.</p>
<p><a class="reference external" href="https://chapel-lang.org/publications/cug11-final.pdf">https://chapel-lang.org/publications/cug11-final.pdf</a></p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id5">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>A domain map must provide three (or more) &#8220;global descriptor&#8221; classes.
Here they are called <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt>, <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>,
and <tt class="docutils literal"><span class="pre">GlobalArray</span></tt>.
Their required fields and methods, as well as suggested naming,
are specified below.</p>
<p>A domain map is allowed to contain/provide features, data structures
and functionality (internally to facilitate implementation and/or
externally for users&#8217; benefit) beyond the DSI requirements.
For example, a distribution (i.e. a domain map that distributes data across
multiple locales) will typically define &#8220;local descriptor&#8221; classes as well.</p>
</div>
<div class="section" id="phase-1-the-essentials">
<h2><a class="toc-backref" href="#id6">Phase 1: The Essentials</a><a class="headerlink" href="#phase-1-the-essentials" title="Permalink to this headline">¶</a></h2>
<div class="section" id="class-globaldistribution">
<h3><a class="toc-backref" href="#id7">class <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt></a><a class="headerlink" href="#class-globaldistribution" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This class is visible to the users of the domain map: the <tt class="docutils literal"><span class="pre">dmap</span></tt> wrapper
in Chapel&#8217;s <cite>dmapped</cite> clauses wraps instances of this class.
This class must be a subclass of <tt class="docutils literal"><span class="pre">BaseDist</span></tt>.</div></blockquote>
<dl class="method">
<dt>
<tt class="descname">proc GlobalDistribution.GlobalDistribution() // or with arguments</tt></dt>
<dd><p>Constructor(s)  These are not regulated by DSI - their specifics are
at the domain map implementor&#8217;s discretion.</p>
<p>We suggest providing constructor(s) that accept, as an argument,
an array of locales over which to distribute, with <tt class="docutils literal"><span class="pre">Locales</span></tt>
as the default value.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDistribution.dsiClone(): GlobalDistribution</tt></dt>
<dd><p>Returns a duplicate of <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDistribution.dsiDisplayRepresentation(): void</tt></dt>
<dd><p>A debugging method. It implements displayRepresentation()
on the dmap wrapper.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDistribution.dsiEqualDMaps(that: /*some other GlobalDistribution*/): bool</tt></dt>
<dd><p>Return whether or not the two domain maps are &#8220;equal&#8221; (specify the
same distribution).  This is invoked when <tt class="docutils literal"><span class="pre">==</span></tt> is appled to two
domain maps.</p>
</dd></dl>

</div>
<div class="section" id="class-globaldomain">
<h3><a class="toc-backref" href="#id8">class <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt></a><a class="headerlink" href="#class-globaldomain" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>An instance of this class is created whenever a <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt>-mapped
Chapel domain is created (e.g. when a domain variable is declared).
There is a one-to-one correspondence at run time between a
(conceptual) Chapel domain value and an instance of <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>.
For presentation simplicity, <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>&#8216;s properties refer to
the properties of the corresponding Chapel domain value, when
clear from the context.</p>
<p>Depending on the domain kind, this class is returned by the following
method on <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt>
and must be a subclass of the following class:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="42%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">domain kind</th>
<th class="head">creating method</th>
<th class="head">required superclass</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rectangular</td>
<td><tt class="docutils literal"><span class="pre">dsiNewRectangularDom</span></tt></td>
<td><tt class="docutils literal"><span class="pre">BaseRectangularDom</span></tt></td>
</tr>
<tr class="row-odd"><td>associative</td>
<td><tt class="docutils literal"><span class="pre">dsiNewAssociativeDom</span></tt></td>
<td><tt class="docutils literal"><span class="pre">BaseAssociativeDom</span></tt></td>
</tr>
<tr class="row-even"><td>opaque</td>
<td><tt class="docutils literal"><span class="pre">dsiNewOpaqueDom</span></tt></td>
<td><tt class="docutils literal"><span class="pre">BaseOpaqueDom</span></tt></td>
</tr>
<tr class="row-odd"><td>sparse</td>
<td><tt class="docutils literal"><span class="pre">dsiNewSparseDom</span></tt></td>
<td><tt class="docutils literal"><span class="pre">BaseSparseDom</span></tt></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>It is legal for these methods to return instances of different classes
in different circumstances. (For example, due to the absence of multiple
inheritance, different domain kinds require different classes.)</p>
<p>The DSI requirements apply to each of those classes.
<tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> is used in this document to refer to each such class.</p>
<p>The DSI requirements depend on the domain kind that is supported.
The following requirements apply when supporting rectangular domains.</p>
</div></blockquote>
<dl class="class">
<dt id="GlobalDomain">
<em class="property">class </em><tt class="descname">GlobalDomain</tt><a class="headerlink" href="#GlobalDomain" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-chapel"><div class="highlight"><pre><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="kd">param</span> <span class="nx">rank</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">idxType</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">stridable</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The fields <tt class="docutils literal"><span class="pre">rank</span></tt>, <tt class="docutils literal"><span class="pre">idxType</span></tt>, <tt class="docutils literal"><span class="pre">stridable</span></tt> are the attributes
of the corresponding Chapel domain. (They could be replaced with
parenthesesless functions of the same names and param/type intents.)</p>
<p>The field <tt class="docutils literal"><span class="pre">dist</span></tt> must contain a reference
to the <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> object
that created this <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>. It is used when creating the (runtime)
type for this domain, which contains the domain&#8217;s domain map.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiMyDist() return dist;</tt></dt>
<dd><p>Returns this domain&#8217;s domain map. This procedure should be provided as shown.
(Exception: see <tt class="docutils literal"><span class="pre">dsiLinksDistribution()</span></tt>.)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDistribution.dsiNewRectangularDom(param rank: int, type idxType, param stridable: bool) : GlobalDomain(rank, idxType, stridable)</tt></dt>
<dd><p>This method is invoked when the Chapel program is creating an uninitialized
domain value of the type domain(rank, idxType, stridable)
mapped using the domain map <cite>this</cite>.</p>
<p>This method returns a new <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> instance that will correspond to
that Chapel domain value, i.e., be that value&#8217;s runtime representation.
The field <tt class="docutils literal"><span class="pre">dist</span></tt> of the returned <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> must point to <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiGetIndices(): rank * range(idxType, BoundedRangeType.bounded, stridable)</tt></dt>
<dd><p>Returns a tuple of ranges describing the dimensions of this domain.</p>
<p><tt class="docutils literal"><span class="pre">dsiDims()</span></tt> and <tt class="docutils literal"><span class="pre">dsiGetIndices()</span></tt> have the same specification
and so may be implemented in terms of one another.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiSetIndices(dom: domain(rank, idxType, stridable)): void</tt></dt>
<dd><p>Updates the internal representation of <cite>this</cite>
to match the index set of <tt class="docutils literal"><span class="pre">dom</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">dsiSetIndices</span></tt> and <tt class="docutils literal"><span class="pre">dsiGetIndices</span></tt> are used to assign a domain value to
a domain variable (or any domain l-value).
Note: the arrays associated with this domain will be updated
outside these method.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiSetIndices(ranges: rank * range(idxType)): void</tt></dt>
<dd><p>The same as the other <tt class="docutils literal"><span class="pre">dsiSetIndices</span></tt>. Could be implemented like this:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="p">{</span> <span class="nx">dsiSetIndices</span><span class="p">([(</span><span class="o">..</span><span class="p">.</span><span class="nx">rangesArg</span><span class="p">)]);</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>It is used to initialize the index set of the object returned by
<tt class="docutils literal"><span class="pre">dsiNewRectangularDom()</span></tt> to the index set of the corresponding Chapel
domain value.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalDomain.these()</tt></dt>
<dd><p>The serial iterator over the indices of this domain.
Yields values of the type <tt class="docutils literal"><span class="pre">idxType</span></tt> if <tt class="docutils literal"><span class="pre">rank==1</span></tt>,
otherwise <tt class="docutils literal"><span class="pre">rank*idxType</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalDomain.these(param tag) where tag == iterKind.leader</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalDomain.these(param tag, followThis) where tag == iterKind.follower</tt></dt>
<dd><p>The &#8220;leader&#8221; and &#8220;follower&#8221; iterators (defined below). They are
invoked implicitly to implement parallel (&#8220;forall&#8221;) loops over this domain.
Currently the serial iterator must also be defined for &#8220;forall&#8221; loops to work.</p>
<p>The presentation below is tailored to the use of leader/follower iterators
in domain maps. For a more general discussion, see:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>$CHPL_HOME/examples/primers/leaderfollower.chpl
</pre></div>
</div>
</div></blockquote>
<p>The job of the leader iterator is to:</p>
<blockquote>
<div><ul class="simple">
<li>subdivide the given domain into subdomains,</li>
<li>introduce parallelism between these subdomains, and</li>
<li>place computations for each subdomain on the desired locale,
as appropriate for this domain map.</li>
</ul>
</div></blockquote>
<p>The leader iterator must yield, for each subdomain it chooses,
a description of that subdomain, created as defined below.
Parallelism and placement are achieved, for example, by placing the
yield statements within parallel loops and <cite>on</cite> statements.
The leader is invoked (implicitly) once per parallel loop or expression
over the corresponding domain.</p>
<p>The job of the follower iterator is simply to iterate sequentially
over a subdomain whose description is yielded by the leader iterator,
yielding all indices in that subdomain.
Each time the leader yields a description, the follower is invoked
(implicitly) with that description passed to its <tt class="docutils literal"><span class="pre">followThis</span></tt> argument.
(The argument name must be exactly &#8220;followThis&#8221;.)</p>
<p>For a zippered loop, only the leader for the first of the zippered
items is invoked. Each time that leader yields a description,
all followers are invoked in a zippered manner, with that description
passed to their <tt class="docutils literal"><span class="pre">followThis</span></tt> arguments.</p>
<p>In general, it is up to the implementer of the leaders/followers
whether and how to support their interoperability in this situation.
That is, whether and how the description from the leader of one
zippered item is handled by the follower of another item.
For example, one could support zippering of similar items
and generate a compile-time or run-time error when the items
are not &#8220;similar&#8221;.</p>
<p>DSI requires interoperability between domain maps only
for <em>rectangular</em> domains, by prescribing:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>how the leader builds the description of a subdomain, and</li>
<li>in what order the follower yields the indices of that subdomain.</li>
</ol>
</div></blockquote>
</dd></dl>

<div class="section" id="a-subdomain-description">
<h4><a class="toc-backref" href="#id9">A. Subdomain Description</a><a class="headerlink" href="#a-subdomain-description" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>Let <tt class="docutils literal"><span class="pre">Dwhole</span></tt> be the Chapel domain corresponding to this <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>.</p>
<p>Let <tt class="docutils literal"><span class="pre">Dsub</span></tt> be a subdomain chosen by the leader iterator.</p>
<p>Let <tt class="docutils literal"><span class="pre">DD</span></tt> be the number of dimensions in Dwhole and Dsub.</p>
<p>The description of <tt class="docutils literal"><span class="pre">Dsub</span></tt> is its &#8220;densification&#8221; w.r.t. <tt class="docutils literal"><span class="pre">Dwhole</span></tt>:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>// densification of a domain is a tuple of densifications
// of ranges for each dimension
densify(Dsub, Dwhole) =
  ( densify(Dsub.dim(1), Dwhole.dim(1)),
    ...,
    densify(Dsub.dim(DD), Dwhole.dim(DD)) )

// densification of a range is the sequence of densifications
// of its elements, preserving their order
if Rsub describes the sequence
  i_1, ..., i_N
then densify(Rsub, Rwhole) describes the sequence
  densify(i_1, Rwhole), ..., densify(i_N, Rwhole)

For example, densify(Rwhole, Rwhole) == 0.. #(Rwhole.length)

// densification of an index is its indexOrder
densify(i, Rwhole) = Rwhole.indexOrder(i)
</pre></div>
</div>
</div></blockquote>
<p>The optional module DSIUtil provides the following implementations
of densifications and the reverse transformation:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>densify(Dsub, Dwhole)
densify(RSsub, RSwhole)  // on tuples of ranges
densify(Rsub, Rwhole)
unDensify(Dsub, Dwhole)
unDensify(RSsub, RSwhole)  // on tuples of ranges
unDensify(Rsub, Rwhole)
</pre></div>
</div>
</div></blockquote>
<p>Hint: when developing a new domain map, skip densification and
de-densification, but ensure it is used in zippering only
with domains/arrays of the same domain map.</p>
</div></blockquote>
</div>
<div class="section" id="b-follower-yield-order">
<h4><a class="toc-backref" href="#id10">B. Follower Yield Order</a><a class="headerlink" href="#b-follower-yield-order" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The follower iterator must traverse the subdomain for which the above
description is created in the order given by the default domain map.
(That order can be observed, e.g., by assigning <tt class="docutils literal"><span class="pre">Rsub</span></tt> to a domain
variable whose type does not specify a domain map explicitly,
then invoking <tt class="docutils literal"><span class="pre">write()</span></tt> on that variable.)</p>
<p>(Interoperability of domain maps implies that the follower must
accept a densification of any subdomain of <tt class="docutils literal"><span class="pre">Dwhole</span></tt>, not just the
ones that can be generated by its leader.)</p>
</div></blockquote>
<dl class="method">
<dt>
<tt class="descname">iter GlobalDomain.these(param tag) where tag == iterKind.standalone</tt></dt>
<dd><p>A &#8220;standlone&#8221; parallel iterator. It is optional. If it is provided,
it is used in non-zippered &#8220;forall&#8221; loops
instead of a combination of leader+follower iterators.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiSerialWrite(f: Writer): void</tt></dt>
<dd><p>Writes out the domain to the given Writer (e.g. a file or stdout) serially.
Is used to implement write() on the corresponding domain.</p>
<p>This method will typically invoke f.write() on <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>&#8216;s components
(e.g. bounds) and strings (e.g. &#8220;[&#8221; and &#8220;]&#8221;). Such invocations, whether
direct or indirect, must occur within the same task that <tt class="docutils literal"><span class="pre">dsiSerialWrite()</span></tt>
is invoked in, and not within any <cite>on</cite> statements, direct or indirect.
Otherwise a deadlock may occur.
(Invoking <tt class="docutils literal"><span class="pre">write()</span></tt> on <tt class="docutils literal"><span class="pre">Writers</span></tt> other than <tt class="docutils literal"><span class="pre">f</span></tt>
is not affected by this.)</p>
<p><tt class="docutils literal"><span class="pre">dsiSerialWrite()</span></tt> will always be invoked on <tt class="docutils literal"><span class="pre">Locales(0)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiDisplayRepresentation(): void</tt></dt>
<dd><p>A debugging method. It implements <tt class="docutils literal"><span class="pre">displayRepresentation()</span></tt>
on the corresponding Chapel domain value.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-globalarray">
<h3><a class="toc-backref" href="#id11">class <tt class="docutils literal"><span class="pre">GlobalArray</span></tt></a><a class="headerlink" href="#class-globalarray" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>An instance of this class is created whenever a Chapel array is created
over a domain represented by a <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>.
There is a one-to-one correspondence at run time between a
(conceptual) Chapel array value and an instance of <tt class="docutils literal"><span class="pre">GlobalArray</span></tt>.</p>
<p>This class is returned by <tt class="docutils literal"><span class="pre">GlobalDomain.dsiBuildArray</span></tt>.
It must be a subclass of <tt class="docutils literal"><span class="pre">BaseArr</span></tt>.</p>
<p>It is legal for <tt class="docutils literal"><span class="pre">GlobalDomain.dsiBuildArray</span></tt> to return instances of
different classes in different circumstances.
The DSI requirements apply to each of those classes.
Here <tt class="docutils literal"><span class="pre">GlobalArray</span></tt> refers to each such class.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span class="k">class</span> <span class="nc">GlobalArray</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dom</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The field <tt class="docutils literal"><span class="pre">eltType</span></tt> gives the type of the array elements.</p>
<p>The field <tt class="docutils literal"><span class="pre">dom</span></tt> must contain a reference to the <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> object
that created this <tt class="docutils literal"><span class="pre">GlobalArray</span></tt>. This is used when creating the (runtime)
type for this array, which contains the array&#8217;s domain.</p>
</div></blockquote>
<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.GlobalArray() // or with arguments</tt></dt>
<dd><p>Constructor(s). These are not regulated by DSI &#8211; their specifics are
at the domain map implementor&#8217;s discretion.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiBuildArray(type eltType) : GlobalArray(eltType, this.type)</tt></dt>
<dd><p>This method is invoked when the Chapel program is creating
an array value over the domain <cite>this</cite> with the element type <tt class="docutils literal"><span class="pre">eltType</span></tt>.
This method returns a new <tt class="docutils literal"><span class="pre">GlobalArray</span></tt> instance that will correspond to
that Chapel array value, i.e., be that value&#8217;s runtime representation.
The field <tt class="docutils literal"><span class="pre">dom</span></tt> of the returned <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> must point to <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiGetBaseDom() return dom;</tt></dt>
<dd><p>Returns this array&#8217;s <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>.
This procedure should be provided as shown.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiAccess(indexx) var: eltType</tt></dt>
<dd><p>Given an index, returns the corresponding array element (as an l-value).</p>
<p>The domain map implementer is allowed to restrict the type of indexx
that this method accepts.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiSerialWrite(f: Writer): void</tt></dt>
<dd><p>Writes out the array to the given <tt class="docutils literal"><span class="pre">Writer</span></tt>
(e.g. a <tt class="docutils literal"><span class="pre">file</span></tt> or <tt class="docutils literal"><span class="pre">stdout</span></tt>) serially.
Is used to implement <tt class="docutils literal"><span class="pre">write()</span></tt> on the corresponding array.</p>
<p>The restrictions on this method are the same as on
<tt class="docutils literal"><span class="pre">GlobalDomain.dsiSerialWrite()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalArray.these() var: eltType</tt></dt>
<dd><p>The serial iterator over the elements of this array.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalArray.these(param tag) where tag == iterKind.leader</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalArray.these(param tag, followThis) var  where tag == iterKind.follower</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">iter GlobalArray.these(param tag) where tag == iterKind.standalone</tt></dt>
<dd><p>The leader, follower, and standalone iterators.</p>
<p>These are defined in the same way as the leader and follower for
<tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>, except the follower must yield array locations.</p>
<p>Given a subdomain description passed to the <tt class="docutils literal"><span class="pre">followThis</span></tt> argument,
the <tt class="docutils literal"><span class="pre">GlobalArray</span></tt> follower iterator must yield array locations
corresponding to the indices yielded by the <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> follower,
in the same order.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiReallocate(d: domain): void</tt></dt>
<dd><p>When this array&#8217;s domain is assigned a new value, say <tt class="docutils literal"><span class="pre">newDom</span></tt>,
first <tt class="docutils literal"><span class="pre">dsiReallocate(newDom)</span></tt> is invoked on this array.
Then, <tt class="docutils literal"><span class="pre">dsiSetIndices(newDom)</span></tt> is invoked on this array&#8217;s <tt class="docutils literal"><span class="pre">dom</span></tt>.</p>
<p>Correspondingly, <tt class="docutils literal"><span class="pre">dsiReallocate</span></tt> needs to adjust everything
that won&#8217;t be taken care of in <tt class="docutils literal"><span class="pre">dsiSetIndices</span></tt>.</p>
<p>NOTE: the formal&#8217;s name must be exactly <tt class="docutils literal"><span class="pre">d</span></tt>
at present (due to compiler specifics).</p>
<p>NOTE: this method can/should be a no-op if:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">GlobalArray</span></tt> stores its array elements in Chapel array(s), and</li>
<li>the domain(s) of those array(s) are updated by <tt class="docutils literal"><span class="pre">dsiSetIndices</span></tt>,</li>
</ul>
</div></blockquote>
<p>as in the following simplified example:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="p">:</span> <span class="nx">BaseRectangularDom</span> <span class="p">{</span>
  <span class="c1">// required</span>
  <span class="kd">param</span> <span class="nx">rank</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">idxType</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">stridable</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="c1">// for example, store indices as a single Chapel domain</span>
  <span class="kd">var</span> <span class="nx">myIndices</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span> <span class="nx">idxType</span><span class="p">,</span> <span class="nx">stridable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiSetIndices</span><span class="p">(</span><span class="nx">dom</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span><span class="nx">idxType</span><span class="p">,</span><span class="nx">stridable</span><span class="p">)):</span> <span class="nx">void</span>
<span class="p">{</span> <span class="nx">myIndices</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">;</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">GlobalArray</span> <span class="p">:</span> <span class="nx">BaseArr</span> <span class="p">{</span>
  <span class="c1">// required</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dom</span><span class="p">;</span>
  <span class="c1">// for example, store elements as a single Chapel array</span>
  <span class="kd">var</span> <span class="nx">myElements</span><span class="p">:</span> <span class="p">[</span><span class="nx">dom</span><span class="p">.</span><span class="nx">myIndices</span><span class="p">]</span> <span class="nx">eltType</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Given one instance of each class, say <tt class="docutils literal"><span class="pre">gd</span></tt> and <tt class="docutils literal"><span class="pre">ga</span></tt>,
where <tt class="docutils literal"><span class="pre">ga.dom</span> <span class="pre">==</span> <span class="pre">gd</span></tt>
the domain of <tt class="docutils literal"><span class="pre">ga.myElements</span></tt> is <tt class="docutils literal"><span class="pre">gd.myIndices</span></tt>.
A call <tt class="docutils literal"><span class="pre">gd.dsiSetIndices(newDom)</span></tt> updates <tt class="docutils literal"><span class="pre">gd.myIndices</span></tt>, which, in turn,
resizes <tt class="docutils literal"><span class="pre">ga.myElements</span></tt>, according to Chapel&#8217;s array semantics.
Nothing remains to do in <tt class="docutils literal"><span class="pre">dsiReallocate()</span></tt>.</p>
<p>(Behind the scene, resizing of <tt class="docutils literal"><span class="pre">ga.myElements</span></tt> is implemented by
<tt class="docutils literal"><span class="pre">dsiReallocate</span></tt> of the default domain map. That&#8217;s the domain map
that <tt class="docutils literal"><span class="pre">myIndices</span></tt> is distributed with, since <tt class="docutils literal"><span class="pre">myIndices</span></tt>&#8216;s type
provides no explicit domain map.)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiDisplayRepresentation(): void</tt></dt>
<dd><p>A debugging method. It implements <tt class="docutils literal"><span class="pre">displayRepresentation()</span></tt>
on the corresponding Chapel array value.</p>
</dd></dl>

</div>
<div class="section" id="naming">
<h3><a class="toc-backref" href="#id12">Naming</a><a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h3>
<p>Once you have chosen the name for your domain map, say, MyMap,
we suggest naming the descriptor classes as follows:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">in this document</th>
<th class="head">in your code</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt></td>
<td><tt class="docutils literal"><span class="pre">MyMapDist</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">GlobalDomain</span></tt></td>
<td><tt class="docutils literal"><span class="pre">MyMapDom</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">GlobalArray</span></tt></td>
<td><tt class="docutils literal"><span class="pre">MyMapArr</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">LocalDistribution</span></tt></td>
<td><tt class="docutils literal"><span class="pre">LocMyMapDist</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">LocalDomain</span></tt></td>
<td><tt class="docutils literal"><span class="pre">LocMyMapDom</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">LocalArray</span></tt></td>
<td><tt class="docutils literal"><span class="pre">LocMyMapArr</span></tt></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Some domain maps in this Chapel distribution use just the domain map
name for their <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> classes, e.g. Block and Cyclic.</p>
</div>
</div>
<div class="section" id="phase-2-additional-operations">
<h2><a class="toc-backref" href="#id13">Phase 2: Additional Operations</a><a class="headerlink" href="#phase-2-additional-operations" title="Permalink to this headline">¶</a></h2>
<p>The operations in this phase are required by DSI.
However, if a domain map is in use by a limited set of applications,
these operations do not need to be implemented up front. Instead,
each of them could be implemented later, when the need arises.
The &#8220;unresolved call&#8221; compilation errors could be used
as an indication of what procedure(s) need to be defined.</p>
<dl class="method">
<dt>
<tt class="descname">proc GlobalDistribution.dsiIndexToLocale(indexx): locale</tt></dt>
<dd><p>Given an index <tt class="docutils literal"><span class="pre">indexx</span></tt>, returns the locale that &#8220;owns&#8221; that index,
i.e. on which the corresponding data is located.
This is used to implement <tt class="docutils literal"><span class="pre">idxToLocale()</span></tt> on the <tt class="docutils literal"><span class="pre">dmap</span></tt> wrapper.</p>
<p>The domain map implementer is allowed to restrict the type of <tt class="docutils literal"><span class="pre">indexx</span></tt>
that this method accepts.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiDim(dim: int): range(idxType, BoundedRangeType.bounded, stridable)</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiDims(): rank * range(idxType, BoundedRangeType.bounded, stridable)</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiLow</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiHigh</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiStride</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiNumIndices</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiMember(indexx)</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiIndexOrder(indexx)</tt></dt>
<dd><p>These methods implement the corresponding queries
(<tt class="docutils literal"><span class="pre">dim</span></tt>, <tt class="docutils literal"><span class="pre">dims</span></tt>, <tt class="docutils literal"><span class="pre">low</span></tt>, etc.)
of the domain value for which this <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> instance was created.
For example, <tt class="docutils literal"><span class="pre">dsiDim(d)</span></tt> returns the range describing the domain&#8217;s
<tt class="docutils literal"><span class="pre">d</span></tt>-th dimension.</p>
<p><tt class="docutils literal"><span class="pre">dsiDims()</span></tt> and <tt class="docutils literal"><span class="pre">dsiGetIndices()</span></tt> have the same specification
and so may be implemented in terms of one another.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiBuildRectangularDom(param rank: int, type idxType, param stridable: bool, ranges: rank * range(idxType, BoundedRangeType.bounded, stridable))</tt></dt>
<dd><p>This method is similar to <tt class="docutils literal"><span class="pre">dsiNewRectangularDom()</span></tt>, except it is used
in the cases where a new Chapel domain is created from an existing
Chapel domain (represented by <cite>this</cite>) and the index set of the desired
domain is known (it is defined by the <tt class="docutils literal"><span class="pre">ranges</span></tt> argument). For example,
it is invoked upon domain slicing and when applying domain operations
such as expand, exterior, interior, translate.
The <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> of the result is the same as that of <cite>this</cite>.</p>
<p>This method returns a new instance of
<tt class="docutils literal"><span class="pre">GlobalDomain(rank,</span> <span class="pre">idxType,</span> <span class="pre">stridable)</span></tt>
that will be the runtime representation of a Chapel domain whose index set
is initialized as defined by <tt class="docutils literal"><span class="pre">ranges</span></tt>. Other than that, this instance must
satisfy the same constraints as the result of <tt class="docutils literal"><span class="pre">dsiNewRectangularDom()</span></tt>.</p>
<p>This method can be implemented as follows,
unless a more efficient implementation is desired:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">.</span><span class="nx">dsiNewRectangularDom</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span> <span class="nx">idxType</span><span class="p">,</span> <span class="nx">stridable</span><span class="p">);</span>
<span class="nx">result</span><span class="p">.</span><span class="nx">dsiSetIndices</span><span class="p">(</span><span class="nx">ranges</span><span class="p">);</span>
<span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiSlice(sliceDef: GlobalDomain)</tt></dt>
<dd><p>Returns a <tt class="docutils literal"><span class="pre">GlobalArray</span></tt> object representing a slice of the array
corresponding to <cite>this</cite>. Like generally in Chapel, the array elements
in the slice must be aliases of the corresponding elements of <cite>this</cite>.
The argument <tt class="docutils literal"><span class="pre">sliceDef</span></tt> defines the slice, i.e., which of the elements
of <cite>this</cite> are to be included in the result.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiReindex(reindexDef: GlobalDomain)</tt></dt>
<dd><p>Similar to <tt class="docutils literal"><span class="pre">dsiSlice</span></tt>, except: The array alias represented by the
returned object is a reindexing, rather than a slice, of the array
represented by <cite>this</cite>. The argument <tt class="docutils literal"><span class="pre">reindexDef</span></tt> represents the
reindexing expression. The callers of dsiReindex must ensure that
the domain of this array and <tt class="docutils literal"><span class="pre">reindexDef</span></tt> have the same number of
dimensions and the same number of indices along each dimension.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalArray.dsiRankChange(reindexDef: GlobalDomain, param newRank: int, param newStridable: bool, args)</tt></dt>
<dd><p>Similar to <tt class="docutils literal"><span class="pre">dsiReindex</span></tt>, except reindexing changes the rank.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.linksDistribution() param</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc GlobalDomain.dsiLinksDistribution()</tt></dt>
<dd><p>Typically these should not be defined.</p>
<p>If the domains mapped using <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> do NOT need to be tracked
and the <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> itself does NOT need to be reference counted,
these two methods should be defined to return <cite>false</cite>;
Also in this case <tt class="docutils literal"><span class="pre">dsiMyDist()</span></tt> does not need to be defined.</p>
</dd></dl>

</div>
<div class="section" id="phase-3-privatization">
<h2><a class="toc-backref" href="#id14">Phase 3: Privatization</a><a class="headerlink" href="#phase-3-privatization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-privatization">
<h3><a class="toc-backref" href="#id15">What is privatization?</a><a class="headerlink" href="#what-is-privatization" title="Permalink to this headline">¶</a></h3>
<p>Privatization of an object <tt class="docutils literal"><span class="pre">X</span></tt> means providing a local copy of <tt class="docutils literal"><span class="pre">X</span></tt> on
each locale. Such a copy is called the &#8220;privatized copy&#8221;.
On <tt class="docutils literal"><span class="pre">X.locale</span></tt>, <tt class="docutils literal"><span class="pre">X</span></tt> itself serves as the privatized copy.
We refer to <tt class="docutils literal"><span class="pre">X</span></tt> as the &#8220;original object&#8221;.</p>
<p>Privatization aims at reducing communication between locales.
When <tt class="docutils literal"><span class="pre">X</span></tt> needs to be accessed (by reading its fields or invoking
its methods) from another locale, its privatized copy
on the current locale is used instead.
Therefore, communication to <tt class="docutils literal"><span class="pre">X.locale</span></tt> is eliminated.</p>
</div>
<div class="section" id="how-does-privatization-work-with-dsi">
<h3><a class="toc-backref" href="#id16">How does privatization work with DSI?</a><a class="headerlink" href="#how-does-privatization-work-with-dsi" title="Permalink to this headline">¶</a></h3>
<p>Privatization is optional in DSI. Each of the global descriptor classes
can support privatization independently of the others. A class indicates
to the Chapel implementation whether it supports privatization via
its method <tt class="docutils literal"><span class="pre">dsiSupportsPrivatization()</span></tt> (see below).</p>
<p>Layouts (i.e. the domain maps that do not distribute domains across locales)
can potentially benefit from privatization. However, the standard
layouts do not support it.</p>
<p>The remainder of DSI privatization requirements must be implemented
by each global descriptor class that chooses to support privatization.</p>
<p>The domain map implementation must provide methods to:</p>
<ul class="simple">
<li>create a privatized copy given the original object, and</li>
<li>update a privatized copy when some other privatized copy changes
(see &#8220;reprivatization&#8221; below).</li>
</ul>
<p>The Chapel implementation:</p>
<ul class="simple">
<li>invokes DSI privatization methods to create or update privatized copies, and</li>
<li>redirects original object accesses to its privatized copies.</li>
</ul>
<p>The Chapel implementation creates privatized copies (over <em>all</em> locales)
greedily as follows (if that class supports privatization):</p>
<ul class="simple">
<li>of a <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> - when it is wrapped in <tt class="docutils literal"><span class="pre">new</span> <span class="pre">dmap()</span></tt>
and when that wrapper is copied;</li>
<li>of a <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> or <tt class="docutils literal"><span class="pre">GlobalArray</span></tt> - when the corresponding
Chapel domain or array is created.</li>
</ul>
</div>
<div class="section" id="what-is-reprivatization">
<h3><a class="toc-backref" href="#id17">What is reprivatization?</a><a class="headerlink" href="#what-is-reprivatization" title="Permalink to this headline">¶</a></h3>
<p>Should any privatized copy be modified, the changes need to be
propagated to all the other privatized copies.
This propagation is called reprivatization.</p>
<p>The domain map implementation provides methods to update a privatized copy.
The Chapel implementation invokes these methods when necessary.</p>
</div>
<div class="section" id="dsi-privatization-requirements">
<h3><a class="toc-backref" href="#id18">DSI privatization requirements</a><a class="headerlink" href="#dsi-privatization-requirements" title="Permalink to this headline">¶</a></h3>
<p>The following requirements apply individually to each global descriptor
class that chooses to support privatization.
<tt class="docutils literal"><span class="pre">Global</span></tt> denotes such a class.</p>
<dl class="method">
<dt>
<tt class="descname">proc Global.dsiSupportsPrivatization() param return true;</tt></dt>
<dd><p>Returns <cite>true</cite> to indicate that privatization is supported.
NOTE: do not specify the return type (due to a bug in the compiler).</p>
</dd></dl>

<div class="highlight-chapel"><div class="highlight"><pre>  class Global ... {
    ...
    var pid = -1;
    ...
  }

The field ``pid`` should be provided as shown.
It should not be accessed by the DSI implementation except
in conjunction with ``chpl_getPrivatizedCopy()`` as discussed later.
</pre></div>
</div>
<dl class="method">
<dt>
<tt class="descname">proc Global.dsiGetPrivatizeData()</tt></dt>
<dd><p>Returns the data to be used as the argument to <tt class="docutils literal"><span class="pre">dsiPrivatize()</span></tt>.
It can be a tuple of values or any other type, at the implementor&#8217;s
discretion. See <tt class="docutils literal"><span class="pre">dsiPrivatize()</span></tt> for explanation.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc Global.dsiPrivatize(privatizeData): Global</tt></dt>
<dd><p>Returns a privatized copy of <cite>this</cite>. The Chapel implementation
invokes this method as follows:</p>
<ul class="simple">
<li>on the locale where the privatized copy is to be located,</li>
<li><cite>this</cite> is either the original object or its privatized copy
created by <tt class="docutils literal"><span class="pre">dsiPrivatize</span></tt> on some other locale,</li>
<li><tt class="docutils literal"><span class="pre">privatizeData</span></tt> is the result of invoking dsiGetPrivatizeData()
on the original object.</li>
</ul>
<p>Typically <tt class="docutils literal"><span class="pre">dsiPrivatize()</span></tt> will need to copy and/or privatize
some information from the original object into the privatized copy
being created. This information could be obtained by querying <cite>this</cite>
directly. Alternatively, it could be passed from the original object
via <tt class="docutils literal"><span class="pre">privatizeData</span></tt>. This approach could allow the needed information
to be bundled into the original active message, rather than requiring
additional communications when accessing <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc Global.dsiGetReprivatizeData()</tt></dt>
<dd><p>Similar do <tt class="docutils literal"><span class="pre">dsiGetPrivatizeData()</span></tt>, except the result is used
as the argument to <tt class="docutils literal"><span class="pre">dsiReprivatize()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">proc Global.dsiReprivatize(other: Global, reprivatizeData): void</tt></dt>
<dd><p>Updates a privatized copy.</p>
<p><cite>this</cite> is the object to be updated as part of reprivatization.</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> is either the object whose modification originally
necessitated reprivatization or one of the privatized copies
that have already been updated for that modification
by <tt class="docutils literal"><span class="pre">dsiReprivatize()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">reprivatizeData</span></tt> is the result of invoking dsiGetReprivatizeData()
on the originally-modified object.</p>
<p>Q: What modifications must <tt class="docutils literal"><span class="pre">dsiReprivatize()</span></tt> reflect?</p>
<p>A: Any changes that the domain map implementation may perform on
an instance of <tt class="docutils literal"><span class="pre">Global</span></tt> (or its privatized copy) after that instance
has been created and privatized.</p>
<p>For example, <tt class="docutils literal"><span class="pre">GlobalDomain.dsiReprivatize()</span></tt> must reflect any changes
that <tt class="docutils literal"><span class="pre">GlobalDomain.dsiSetIndices()</span></tt> may perform.</p>
</dd></dl>

</div>
<div class="section" id="tip-testing-privatization">
<h3><a class="toc-backref" href="#id19">Tip: testing privatization</a><a class="headerlink" href="#tip-testing-privatization" title="Permalink to this headline">¶</a></h3>
<p>In addition to the usual correctness testing, it may be useful to check
whether array access is purely local, i.e., results in no communication.
This can be done using <cite>local</cite> statements.</p>
<p>(A <cite>local</cite> statement performs runtime checks that report an error
whenever any communication occurs within the its body.)</p>
<p>Here is a simple example:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="c1">// declare an array that uses the domain map to be tested</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="o">..</span><span class="p">.;</span>

<span class="c1">// initialize it</span>
<span class="nx">A</span> <span class="o">=</span> <span class="nx">value1</span><span class="p">;</span>

<span class="k">forall</span> <span class="nx">loc</span> <span class="kd">in</span> <span class="p">(</span><span class="nx">locales</span> <span class="nx">that</span> <span class="nx">A</span> <span class="nx">is</span> <span class="nx">distributed</span> <span class="nx">over</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1">// run the check on each locale</span>
  <span class="k">on</span> <span class="nx">loc</span> <span class="p">{</span>
    <span class="c1">// value2 to be different from value1</span>
    <span class="kd">var</span> <span class="nx">valTemp</span> <span class="o">=</span> <span class="nx">value2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">idxTemp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">an</span> <span class="k">index</span> <span class="p">(</span><span class="nx">tuple</span><span class="p">)</span> <span class="nx">that</span> <span class="nx">is</span> <span class="nx">mapped</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">locale</span> <span class="s">&#39;loc&#39;</span><span class="p">);</span>
    <span class="k">local</span> <span class="p">{</span>
      <span class="c1">// Access the array.</span>
      <span class="c1">// This statement succeeds if there is no communication.</span>
      <span class="nx">valTemp</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">idxTemp</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// reference the read value</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">valTemp</span> <span class="o">==</span> <span class="nx">value1</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tip-privatized-copies-should-reference-privatized-copies">
<h3><a class="toc-backref" href="#id20">Tip: privatized copies should reference privatized copies</a><a class="headerlink" href="#tip-privatized-copies-should-reference-privatized-copies" title="Permalink to this headline">¶</a></h3>
<p>The global descriptor classes are required to reference each other
(e.g. <tt class="docutils literal"><span class="pre">GlobalArray.dom</span></tt> references <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>; <tt class="docutils literal"><span class="pre">GlobalDomain.dist</span></tt>
references <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt>). Therefore, if it is desired to
eliminate communication completely upon array references,
all the three global descriptor classes may have to be privatized.
When one descriptor object references another, a privatized copy of
the former needs to reference a privatized copy of the latter.</p>
<p>To obtain a privatized copy of an object, e.g. for use within
<tt class="docutils literal"><span class="pre">dsiPrivatize()</span></tt>, use the following procedure:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="k">proc</span> <span class="nf">chpl_getPrivatizedCopy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">objectType</span><span class="p">,</span> <span class="nx">objectPid</span><span class="p">:</span><span class="kt">int</span><span class="p">):</span> <span class="nx">objectType</span>
</pre></div>
</div>
</div></blockquote>
<p>Notes:</p>
<ul class="simple">
<li>The first argument is type of the object being privatized.</li>
<li>The second argument is the original object&#8217;s <tt class="docutils literal"><span class="pre">pid</span></tt> field.</li>
<li>The procedure returns a privatized copy of the original object.</li>
<li>The procedure can be applied only to objects that have already
been privatized.<ul>
<li>A <tt class="docutils literal"><span class="pre">GlobalArray</span></tt> is privatized after its <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>, which is
privatized after its <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">pid</span></tt> field is set to a different value than <tt class="docutils literal"><span class="pre">-1</span></tt>
when an object is privatized.</li>
</ul>
</li>
</ul>
<p>Here is an example of using it for privatizing <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>,
assuming that <tt class="docutils literal"><span class="pre">GlobalDistribution</span></tt> also supports privatization:</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiGetPrivatizeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// include the desired &#39;pid&#39;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="o">..</span><span class="p">.</span> <span class="nx">other</span> <span class="nx">data</span> <span class="nx">as</span> <span class="nx">needed</span> <span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiPrivatize</span><span class="p">(</span><span class="nx">privatizeData</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// extract the &#39;pid&#39; provided above</span>
  <span class="kd">const</span> <span class="nx">distPid</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// obtain the privatized copy of the GlobalDistribution object</span>
  <span class="kd">const</span> <span class="nx">privatizedDMap</span> <span class="o">=</span> <span class="nx">chpl_getPrivatizedCopy</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="kd">type</span><span class="p">,</span> <span class="nx">distPid</span><span class="p">);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nx">GlobalDomain</span><span class="p">(</span><span class="nx">dist</span> <span class="o">=</span> <span class="nx">privatizedDMap</span><span class="p">,</span>
                          <span class="o">..</span><span class="p">.</span> <span class="nx">other</span> <span class="nx">fields</span> <span class="nx">as</span> <span class="nx">needed</span> <span class="o">..</span><span class="p">.)</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tip-privatize-the-domains-and-arrays-used-in-the-implementation">
<h3><a class="toc-backref" href="#id21">Tip: &#8220;privatize&#8221; the domains and arrays used in the implementation</a><a class="headerlink" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation" title="Permalink to this headline">¶</a></h3>
<p>If a global descriptor class to be privatized uses domains and arrays,
those need to be &#8220;privatized&#8221;, too, to reduce communication. In the
case of domains and arrays mapped using the default layout,
their &#8220;privatization&#8221; is achieved by copying.</p>
<p>Careful consideration is needed to eliminate all communication.
For example:</p>
<ul class="simple">
<li>Copying an array preserves the source&#8217;s domain - unless
the destination&#8217;s domain is declared explicitly.</li>
<li>Copying a domain preserves the source&#8217;s domain map - unless
the destination&#8217;s type is declared explicitly.</li>
<li>If an array&#8217;s domain or a domain&#8217;s domain map is declared explicitly,
ensure that privatized copies of those are used.</li>
<li>There is no need to privatize the default layout.
Specifically, copying a domain declared without an explicit domain map
is sufficient to privatize that domain.</li>
<li>The same considerations are valid for reprivatization.</li>
</ul>
<p>Here is an example of &#8220;privatizing&#8221; domains/arrays within <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt>.
The key insight here is that <tt class="docutils literal"><span class="pre">auxArrayG</span></tt>&#8216;s domain needs to be &#8220;privatized&#8221;.
Cf. the domains of <tt class="docutils literal"><span class="pre">auxArrayED1</span></tt> and <tt class="docutils literal"><span class="pre">auxArrayED2</span></tt> are created
implicitly for each <tt class="docutils literal"><span class="pre">GlobalDomain</span></tt> object and so will be local in any case.</p>
<blockquote>
<div><div class="highlight-chapel"><div class="highlight"><pre><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>

  <span class="c1">// this field is generic</span>
  <span class="kd">var</span> <span class="nx">auxArrayG</span><span class="p">;</span>

  <span class="c1">// domain is specified explicitly</span>
  <span class="kd">var</span> <span class="nx">auxArrayED1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>

  <span class="c1">// similar</span>
  <span class="kd">var</span> <span class="nx">auxDomain</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">auxArrayED2</span><span class="p">:</span> <span class="p">[</span><span class="nx">auxDomain</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiGetPrivatizeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="nx">auxArrayG</span><span class="p">,</span>
          <span class="nx">auxArrayED1</span><span class="p">,</span> <span class="nx">auxDomain</span><span class="p">,</span> <span class="nx">auxArrayED2</span><span class="p">,</span> <span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain</span><span class="p">.</span><span class="nx">dsiPrivatize</span><span class="p">(</span><span class="nx">privatizeData</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// To privatize auxArrayG, we must &quot;privatize&quot; its domain first.</span>
  <span class="c1">// No need to declare privDom&#39;s type if auxArrayG uses the default layout.</span>
  <span class="kd">var</span> <span class="nx">privDom</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="k">domain</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">privArr</span><span class="p">:</span> <span class="p">[</span><span class="nx">privDom</span><span class="p">]</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">eltType</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

  <span class="c1">// If the following were used, privArr.domain would be the same</span>
  <span class="c1">// as privatizeData(2).domain, i.e., it would not be privatized.</span>
  <span class="c1">//var privArr = privatizeData(2);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nx">GlobalDomain</span><span class="p">(</span><span class="o">..</span><span class="p">.,</span> <span class="nx">auxArrayG</span> <span class="o">=</span> <span class="nx">privArr</span><span class="p">,</span>
    <span class="c1">// the other fields can be simply copied</span>
    <span class="nx">auxArrayED1</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
    <span class="nx">auxDomain</span>   <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
    <span class="nx">auxArrayED2</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>

<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extern.html" class="btn btn-neutral float-right" title="C Interoperability">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="chpldoc.html" class="btn btn-neutral" title="Documenting Chapel"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Cray Inc.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.12.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

</body>
</html>
