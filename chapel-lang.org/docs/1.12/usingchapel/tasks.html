

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapel Tasks &mdash; Chapel Documentation 1.12 1.12.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  

  
    <link rel="top" title="Chapel Documentation 1.12 1.12.0 documentation" href="../index.html"/>
        <link rel="up" title="Using Chapel" href="index.html"/>
        <link rel="next" title="Debugging Chapel Programs" href="debugging.html"/>
        <link rel="prev" title="Chapel Launchers" href="launcher.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> Chapel Documentation</a>
        
        
<?php   // Variables given by sphinx 
   $chplTitle = "1.12";   $pagename = "./usingchapel/tasks";   include "../versionButton.php";   ?>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">Quickstart Instructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="README.html#quick-start-instructions">Quick Start Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="README.html#what-s-next">What&#8217;s next?</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Using Chapel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="prereqs.html">Chapel Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="chplenv.html">Setting up Your Environment for Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html">Building Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="compiling.html">Compiling Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="executing.html">Executing Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="multilocale.html">Multilocale Chapel Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="launcher.html">Chapel Launchers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Chapel Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">Debugging Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="bugs.html">Reporting Chapel Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../platforms/cray.html">Using Chapel on Cray Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/cygwin.html">Using Chapel on Cygwin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/ibm.html">Using Chapel on IBM Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/knc.html">Using Chapel on Intel Xeon Phi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/macosx.html">Using Chapel on Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/marenostrum.html">Using Chapel on MareNostrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platforms/sgi.html">Using Chapel on SGI Altix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/builtins.html">Built-in Types and Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/Atomics.html">Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelArray.html">Domain and Array Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelComplex_forDocs.html">Complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelIO.html">IO Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelIteratorSupport.html">Vectorizing Iterator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelLocale.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelRange.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelSyncvar.html">Synchronization Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/ChapelTuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/internal/UtilMisc_forDocs.html">Misc Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standardlibrary.html">Standard Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/distributions.html">Distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/layouts.html">Layouts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../technotes/allocators.html">Chapel&#8217;s Use of Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/atomics.html">Runtime Support for Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/auxIO.html">Auxiliary I/O Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/chpl-ipe.html">Interactive Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/chpldoc.html">Documenting Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/dsi.html">Domain Map Standard Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/extern.html">C Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/firstClassFns.html">First-class Functions in Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/libraries.html">Exporting Chapel as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/llvm.html">LLVM Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/local.html">The &#8216;local&#8217; Statement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/localeModels.html">Locale Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/main.html">Support for main() Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/module_search.html">Module Search Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/reduceIntents.html">Reduce Intents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/sets.html">Associative Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technotes/subquery.html">Querying a Local Subdomain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tools/chplvis/index.html">chplvis</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Chapel Documentation 1.12</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Using Chapel</a> &raquo;</li>
      
    <li>Chapel Tasks</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/usingchapel/tasks.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="chapel-tasks">
<span id="readme-tasks"></span><h1><a class="toc-backref" href="#id8">Chapel Tasks</a><a class="headerlink" href="#chapel-tasks" title="Permalink to this headline">Â¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#chapel-tasks" id="id8">Chapel Tasks</a><ul>
<li><a class="reference internal" href="#overview" id="id9">Overview</a></li>
<li><a class="reference internal" href="#task-implementation-layers" id="id10">Task Implementation Layers</a><ul>
<li><a class="reference internal" href="#chpl-tasks-qthreads" id="id11">CHPL_TASKS == qthreads</a><ul>
<li><a class="reference internal" href="#stack-overflow-detection" id="id12">Stack overflow detection</a></li>
<li><a class="reference internal" href="#environment-variables" id="id13">Environment variables</a></li>
<li><a class="reference internal" href="#worker-affinity-and-number" id="id14">Worker affinity and number</a></li>
<li><a class="reference internal" href="#overloading-system-nodes" id="id15">Overloading system nodes</a></li>
<li><a class="reference internal" href="#hwloc" id="id16">Hwloc</a></li>
<li><a class="reference internal" href="#further-information" id="id17">Further information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chpl-tasks-fifo" id="id18">CHPL_TASKS == fifo</a><ul>
<li><a class="reference internal" href="#id1" id="id19">Stack overflow detection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chpl-tasks-massivethreads" id="id20">CHPL_TASKS == massivethreads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-the-number-of-threads" id="id21">Controlling the Number of Threads</a><ul>
<li><a class="reference internal" href="#id2" id="id22">CHPL_TASKS == fifo</a></li>
<li><a class="reference internal" href="#id3" id="id23">CHPL_TASKS == qthreads</a></li>
<li><a class="reference internal" href="#id4" id="id24">CHPL_TASKS == massivethreads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-call-stacks" id="id25">Task Call Stacks</a><ul>
<li><a class="reference internal" href="#id5" id="id26">CHPL_TASKS == fifo</a></li>
<li><a class="reference internal" href="#id6" id="id27">CHPL_TASKS == qthreads</a></li>
<li><a class="reference internal" href="#id7" id="id28">CHPL_TASKS == massivethreads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-related-quantification-methods-on-locales" id="id29">Task-Related Quantification Methods on Locales</a></li>
<li><a class="reference internal" href="#future-tasking-directions" id="id30">Future Tasking Directions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id9">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h2>
<p>Chapel programs create new tasks via the begin, cobegin, and coforall
statements.  Tasks are computations that can conceptually execute
concurrently, though they may or may not do so in practice.</p>
<p>An implementation of Chapel must include at least one tasking layer.
A tasking layer will in turn implement <em>threads</em> which are a mechanism
for executing work in parallel.</p>
<p>All tasking layers support configuration constants to control system
resources such as the number of threads that are available to execute
tasks and the amount of call stack space reserved for each task.  Generally
speaking, the Chapel programmer can make no assumptions about the
scheduling of threads or the mapping of tasks to threads other than
those semantics defined by the language specification.</p>
<p>This document describes the currently-supported tasking options in more
detail.  The rest of this document includes:</p>
<ul class="simple">
<li>an overview of the different tasking options</li>
<li>a detailed description of each tasking option</li>
<li>a discussion of the number of threads used by each tasking option</li>
<li>a discussion of call stack sizes and overflow handling</li>
<li>a list of tasking-related methods on the locale type</li>
<li>a brief description of future directions for the tasking layer</li>
</ul>
<p>If you have questions about tasks that are not covered in the following,
please send them to <a class="reference external" href="mailto:chapel_info&#37;&#52;&#48;cray&#46;com">chapel_info<span>&#64;</span>cray<span>&#46;</span>com</a>.</p>
</div>
<div class="section" id="task-implementation-layers">
<h2><a class="toc-backref" href="#id10">Task Implementation Layers</a><a class="headerlink" href="#task-implementation-layers" title="Permalink to this headline">Â¶</a></h2>
<p>This release contains four distinct tasking layers for Chapel tasks.
The user can select between these options by setting the <tt class="docutils literal"><span class="pre">CHPL_TASKS</span></tt>
environment variable to one of the following values:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">qthreads:</th><td class="field-body">best performance; default for most targets</td>
</tr>
<tr class="field-even field"><th class="field-name">fifo:</th><td class="field-body">most portable, but heavyweight; default for Intel KNC, NetBSD, Cygwin,
or when Cray is the target compiler</td>
</tr>
<tr class="field-odd field"><th class="field-name">massivethreads:</th><td class="field-body">based on U Tokyo&#8217;s MassiveThreads library</td>
</tr>
<tr class="field-even field"><th class="field-name">muxed:</th><td class="field-body">available only on Cray Inc. systems; not documented here,
see <a class="reference internal" href="../platforms/cray.html#readme-cray"><em>Using Chapel on Cray Systems</em></a> instead</td>
</tr>
</tbody>
</table>
<p>Each tasking layer is described in more detail below:</p>
<div class="section" id="chpl-tasks-qthreads">
<h3><a class="toc-backref" href="#id11">CHPL_TASKS == qthreads</a><a class="headerlink" href="#chpl-tasks-qthreads" title="Permalink to this headline">Â¶</a></h3>
<p>Chapel&#8217;s default tasking layer implementation for most targets is based
on the Qthreads user-level threading package from Sandia National Labs.
This provides a lightweight implementation of Chapel tasking and will
also ultimately provide an optimized implementation of sync variables.
To use qthreads tasking, please take the following steps:</p>
<ol class="arabic">
<li><p class="first">Ensure that the environment variable <tt class="docutils literal"><span class="pre">CHPL_HOME</span></tt> points to the
top-level Chapel directory.</p>
</li>
<li><p class="first">Set up your environment to use Qthreads:</p>
<p>ensure <tt class="docutils literal"><span class="pre">CHPL_TASKS</span></tt> is not set (if qthreads is the default)</p>
<p>&#8211; or &#8211;</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nb">export </span><span class="nv">CHPL_TASKS</span><span class="o">=</span>qthreads
</pre></div>
</div>
</li>
<li><p class="first">Follow the instructions in <a class="reference internal" href="chplenv.html#readme-chplenv"><em>Setting up Your Environment for Chapel</em></a> to set up,
compile and run your Chapel programs.</p>
</li>
</ol>
<p>Please report any apparent bugs in Qthreads tasking to the Chapel team.</p>
<div class="section" id="stack-overflow-detection">
<h4><a class="toc-backref" href="#id12">Stack overflow detection</a><a class="headerlink" href="#stack-overflow-detection" title="Permalink to this headline">Â¶</a></h4>
<p>The qthreads tasking implementation can arrange to halt programs when
any task overflows its call stack (see <a class="reference internal" href="#task-call-stacks">Task Call Stacks</a>).
It does this by placing a guard page, which cannot be referenced, at the
end of each task stack.  When a task tries to extend its stack onto a
guard page, it fails with a segfault.</p>
<p>Normally guard pages for stack overflow detection are configured and
enabled.  There is a performance cost for this, however.  We do not have
a quantitative estimate for this cost, but it is a fixed overhead (a
couple of system calls) added to the time needed to run every task, so
qualitatively speaking it will have a greater effect on programs which
create more or shorter-lived tasks than on programs which create fewer
or longer-lived ones.</p>
<p>As described in <a class="reference internal" href="#task-call-stacks">Task Call Stacks</a>, the execution-time default for
stack overflow checking can be set by using the <tt class="docutils literal"><span class="pre">--[no-]stack-checks</span></tt>
compiler option.  But whatever the default is, at execution time stack
overflow detection can be turned off by setting the environment variable
<tt class="docutils literal"><span class="pre">QT_GUARD_PAGES</span></tt> to any of the values &#8220;0&#8221;, &#8220;no&#8221;, or &#8220;false&#8221;, or on by
setting it to any of &#8220;1&#8221;, &#8220;yes&#8221;, or &#8220;true&#8221;.  When it is off the execution
overhead is negligible (just a couple of scalar tests).  Developers
who wish to remove even this small cost can disable guard pages by
building qthreads with guard pages entirely configured out, as follows:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nb">cd</span> <span class="nv">$CHPL_HOME</span>/third-party/qthread
make <span class="nv">CHPL_QTHREAD_NO_GUARD_PAGES</span><span class="o">=</span>yes ... clean all
</pre></div>
</div>
<p>As noted, running without guard pages can improve performance and thus
may be desirable for production work.  However, if this is done, test
runs at similar scale with guard pages turned on to check for stack
overflow should be done beforehand if possible, because undetected stack
overflows can cause subtle and intermittent errors in execution.</p>
</div>
<div class="section" id="environment-variables">
<h4><a class="toc-backref" href="#id13">Environment variables</a><a class="headerlink" href="#environment-variables" title="Permalink to this headline">Â¶</a></h4>
<p>Qthreads provides a number of environment variables that can be used to
configure its behavior at execution time.  An introduction to these can
be found in the ENVIRONMENT section of the qthread_init man page.  (Note
that although this man page documents variables named <tt class="docutils literal"><span class="pre">QTHREAD_*</span></tt>, each
variable is actually present in both <tt class="docutils literal"><span class="pre">QT_*</span></tt> and <tt class="docutils literal"><span class="pre">QTHREAD_*</span></tt> forms,
with the former superseding the latter.)  The qthreads man pages are
available by means of the man(1) -m option, for example:</p>
<div class="highlight-sh"><div class="highlight"><pre>man -M <span class="nv">$CHPL_HOME</span>/third-party/qthread/qthread-*/man qthread_init
</pre></div>
</div>
<p>Note that in some cases there are Chapel environment variables that
override Qthreads counterparts. <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> overrides
<tt class="docutils literal"><span class="pre">QT_HWPAR</span></tt>, for example.  Whenever a Chapel variable overrides a Qthreads
variable, you should use the Chapel one.</p>
</div>
<div class="section" id="worker-affinity-and-number">
<h4><a class="toc-backref" href="#id14">Worker affinity and number</a><a class="headerlink" href="#worker-affinity-and-number" title="Permalink to this headline">Â¶</a></h4>
<p>Simplistically, there are two kinds of threads in Qthreads: shepherds
that manage work distribution, and workers that host qthreads (Chapel
tasks, for our purposes).  The execution-time environment variable
<tt class="docutils literal"><span class="pre">QT_WORKER_UNIT</span></tt> controls how worker threads are distributed on hardware
processors.  The default is &#8220;core&#8221; to distribute workers across CPU
cores (physical processors).  An alternative is &#8220;pu&#8221;, which distributes
workers across processing units.  These are instances of the processor
architecture, or hardware threads if the cores have those.  Note that
&#8220;pu&#8221; will be automatically selected if <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt>
is set to anything larger than the number of cores, so it usually isn&#8217;t
necessary to set <tt class="docutils literal"><span class="pre">QT_WORKER_UNIT</span></tt>.</p>
</div>
<div class="section" id="overloading-system-nodes">
<h4><a class="toc-backref" href="#id15">Overloading system nodes</a><a class="headerlink" href="#overloading-system-nodes" title="Permalink to this headline">Â¶</a></h4>
<p>By default the qthreads tasking implementation is set up to assume that
its process is not competing with anything else for system resources
(CPUs and memory) on its system node.  In this mode, qthreads optimizes
its internal behavior to favor performance over load balancing.  This
works out well for Chapel programs, because normally Chapel runs with
one process (locale) per system node.  However, with <tt class="docutils literal"><span class="pre">CHPL_COMM=gasnet</span></tt>
one can run multiple Chapel locales on a single system node, say for
doing multilocale functional correctness testing with limited system
resources.  (See <a class="reference internal" href="multilocale.html#readme-multilocale"><em>Multilocale Chapel Execution</em></a> for more details.)  When this is
done qthreads&#8217; optimization for performance can actually greatly reduce
performance, due to resource starvation among the multiple Chapel
processes.  If you need qthreads to share system resources more
cooperatively with other processes, you can build it to optimize its
behavior to favor load balancing over performance.  To do this, build
qthreads with <tt class="docutils literal"><span class="pre">CHPL_QTHREAD_ENABLE_OVERSUBSCRIPTION</span></tt> turned on like this:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nb">cd</span> <span class="nv">$CHPL_HOME</span>/third-party/qthread
make <span class="nv">CHPL_QTHREAD_ENABLE_OVERSUBSCRIPTION</span><span class="o">=</span>yes ... clean all
</pre></div>
</div>
</div>
<div class="section" id="hwloc">
<h4><a class="toc-backref" href="#id16">Hwloc</a><a class="headerlink" href="#hwloc" title="Permalink to this headline">Â¶</a></h4>
<p>When <tt class="docutils literal"><span class="pre">CHPL_TASKS=qthreads</span></tt>, the default for <tt class="docutils literal"><span class="pre">CHPL_HWLOC</span></tt> becomes &#8220;hwloc&#8221;,
and the hwloc third-party package will be built.  Qthreads depends on
this package to provide it with a description of the locale hardware, to
support locality and affinity operations.  This is especially important
when <tt class="docutils literal"><span class="pre">CHPL_LOCALE_MODEL=numa</span></tt>, and will become more so in the future.</p>
</div>
<div class="section" id="further-information">
<h4><a class="toc-backref" href="#id17">Further information</a><a class="headerlink" href="#further-information" title="Permalink to this headline">Â¶</a></h4>
<p>For more information on Qthreads, see $CHPL_HOME/third-party/README.</p>
</div>
</div>
<div class="section" id="chpl-tasks-fifo">
<h3><a class="toc-backref" href="#id18">CHPL_TASKS == fifo</a><a class="headerlink" href="#chpl-tasks-fifo" title="Permalink to this headline">Â¶</a></h3>
<p>FIFO tasking over POSIX threads (or pthreads) works on all platforms
and is the default for Intel KNC, Cygwin, NetBSD, or when Cray is the
target compiler.  It is attractive in its portability, though on most
platforms it will tend to be heavier weight than Chapel strictly
requires.  FIFO tasking is also used when Chapel is configured in
&#8216;Quick Start&#8217; mode (see <a class="reference internal" href="README.html#chapelhome-quickstart"><em>Quick Start Instructions</em></a>).  To use FIFO
tasking, please take the following steps:</p>
<ol class="arabic">
<li><p class="first">Ensure that the environment variable <tt class="docutils literal"><span class="pre">CHPL_HOME</span></tt> points to the
top-level Chapel directory.</p>
</li>
<li><p class="first">Set up your environment to use FIFO tasking:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nb">export </span><span class="nv">CHPL_TASKS</span><span class="o">=</span>fifo
</pre></div>
</div>
</li>
<li><p class="first">Follow the instructions in <a class="reference internal" href="chplenv.html#readme-chplenv"><em>Setting up Your Environment for Chapel</em></a> to set up,
compile and run your Chapel programs.</p>
</li>
</ol>
<p>In the FIFO tasking implementation, Chapel tasks are mapped to threads
such that each task is executed by a single thread and is run to
completion before giving up that thread.  As a result, a program can
have no more tasks active (that is, created and started) at any given
time than it has threads on which to run those tasks.  It can create
more tasks than threads, but no more tasks will be run at any time
than there are threads.  Excess tasks are placed in a pool where they
will be picked up and started by threads as they complete their tasks.</p>
<p>The threading implementation uses POSIX threads (pthreads) to run Chapel
tasks.  Because pthreads are relatively expensive to create, it does not
destroy them when there are no tasks for them to execute.  Instead they
stay around and continue to check the task pool for tasks to execute.
Setting the number of pthreads is described in <a class="reference internal" href="#controlling-the-number-of-threads">Controlling the Number of Threads</a>.</p>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id19">Stack overflow detection</a><a class="headerlink" href="#id1" title="Permalink to this headline">Â¶</a></h4>
<p>The fifo tasking implementation can arrange to halt programs when any
task overflows its call stack (see <a class="reference internal" href="#task-call-stacks">Task Call Stacks</a>).  It does
this by placing a guard page, which cannot be referenced, at the end of
each task stack.  When a task tries to extend its stack onto a guard
page, it fails with a segfault.</p>
<p>This feature is enabled in fifo tasking and cannot currently be turned
off.  There is a performance cost for it, which we expect to be small in
most cases.  We do not have a quantitative estimate for this cost, but
it is a fixed overhead (a couple of system calls) added to the time
needed to start each pthread.  Since the pthreads in fifo tasking are
long-lived and can host many tasks over their lifespan, on a per-task
basis we don&#8217;t expect stack overflow detection to be expensive.</p>
</div>
</div>
<div class="section" id="chpl-tasks-massivethreads">
<h3><a class="toc-backref" href="#id20">CHPL_TASKS == massivethreads</a><a class="headerlink" href="#chpl-tasks-massivethreads" title="Permalink to this headline">Â¶</a></h3>
<p>The MassiveThreads team at the University of Tokyo has provided an
implementation of Chapel tasking via their MassiveThreads library
(&#8216;massivethreads&#8217;) in order to create a lighter-weight implementation
of Chapel tasks.  To try MassiveThreads tasking, please take the
following steps:</p>
<ol class="arabic">
<li><p class="first">Ensure that the environment variable <tt class="docutils literal"><span class="pre">CHPL_HOME</span></tt> points to the
top-level Chapel directory.</p>
</li>
<li><p class="first">Set up your environment to use MassiveThreads:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nb">export </span><span class="nv">CHPL_TASKS</span><span class="o">=</span>massivethreads
</pre></div>
</div>
</li>
<li><p class="first">Follow the <a class="reference internal" href="README.html#chapelhome-quickstart"><em>Quick Start Instructions</em></a>
to set up, compile and run your Chapel programs.</p>
</li>
</ol>
<p>For more information on MassiveThreads, please see its entry in:
$CHPL_HOME/third-party/README.</p>
</div>
</div>
<div class="section" id="controlling-the-number-of-threads">
<h2><a class="toc-backref" href="#id21">Controlling the Number of Threads</a><a class="headerlink" href="#controlling-the-number-of-threads" title="Permalink to this headline">Â¶</a></h2>
<p>The number of threads per compute node used to implement a Chapel
program can be controlled by the <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt>
environment variable.  This may be set to either an explicit number
or one of the following symbolic strings:</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">&#8216;MAX_PHYSICAL&#8217;:</th><td class="field-body">number of physical CPUs (cores) on the node</td>
</tr>
<tr class="field-even field"><th class="field-name">&#8216;MAX_LOGICAL&#8217;:</th><td class="field-body">number of logical CPUs (hyperthreads) on the node</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> is not set, the number of threads is
left up to the tasking layer.  See the case-by-case discussions below
for more details.</p>
<p>The Chapel program will generate an error if the requested number of
threads per locale is too large.  For example, when running multi-locale
programs, the GASNet communication layer typically places an upper bound
of 127 or 255 on the number of threads per locale (There are ways to
work around this assumption on certain platforms &#8211; please contact us at
<a class="reference external" href="mailto:chapel_info&#37;&#52;&#48;cray&#46;com">chapel_info<span>&#64;</span>cray<span>&#46;</span>com</a> or peruse the GASNet documentation if you need to
do so.)</p>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id22">CHPL_TASKS == fifo</a><a class="headerlink" href="#id2" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div><p>The value of <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> indicates the maximum
number of threads that the fifo tasking layer can create on each
locale to execute tasks.  These threads are created on a demand-driven
basis, so a program with a small number of concurrent tasks may never
create the specified number.  If the value is zero, then the number of
threads will be limited by system resources and other constraints
(such as GASNet&#8217;s configuration-time limit).</p>
<p>The value of <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> can have a major impact on
performance for fifo tasking.  For programs with few inter-task
dependences and high computational intensity, setting it roughly equal
to the number of physical CPUs on each locale can lead to near-optimal
performance.  However, for programs with lots of fine-grained
synchronization in which tasks frequently block on sync or single
variables, <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> can often exceed the number
of physical CPUs without an adverse effect on performance since
blocked threads will not consume the CPU&#8217;s cycles.</p>
<p>Note that setting <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> too low can result in
program deadlock for fifo tasking.  For example, for programs written
with an assumption that some minimum number of tasks are executing
concurrently, setting <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt> lower than this
can result in deadlock if there are not enough threads to implement
all of the required tasks.  The <tt class="docutils literal"><span class="pre">-b/--blockreport</span></tt> flag can help debug
programs like this that appear to be deadlocked.</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id23">CHPL_TASKS == qthreads</a><a class="headerlink" href="#id3" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div>In the Qthreads tasking layer, <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt>
specifies the number of system threads used to execute tasks.  The
default is to use a number of threads equal to the number of physical
CPUs on the locale.</div></blockquote>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id24">CHPL_TASKS == massivethreads</a><a class="headerlink" href="#id4" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div>In the MassiveThreads tasking layer, <tt class="docutils literal"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></tt>
specifies the number of system threads used to execute tasks.  If the
value is 0, the massivethreads tasking layer will create a number of
threads equal to the number of logical CPUs on the locale.</div></blockquote>
</div>
</div>
<div class="section" id="task-call-stacks">
<h2><a class="toc-backref" href="#id25">Task Call Stacks</a><a class="headerlink" href="#task-call-stacks" title="Permalink to this headline">Â¶</a></h2>
<p>Each task including the main Chapel program has an associated call
stack.  As documented in <a class="reference internal" href="executing.html#readme-executing"><em>Executing Chapel Programs</em></a>, the <tt class="docutils literal"><span class="pre">CHPL_RT_CALL_STACK_SIZE</span></tt>
environment variable can be used to specify how big these call stacks
will be during execution.  See there for a full description of this
environment variable and the values it can take.</p>
<p>When a task&#8217;s call chain becomes so deep that it needs more space than
the size of its call stack, stack overflow occurs.  Whether or not a
program checks for stack overflow checking at execution time can be
specified when it is compiled, via the <tt class="docutils literal"><span class="pre">--[no-]stack-checks</span></tt> compilation
option.  The compile-time default is <tt class="docutils literal"><span class="pre">--stack-checks</span></tt>; <tt class="docutils literal"><span class="pre">--no-stack-checks</span></tt>
can be given directly, and is also implied by <tt class="docutils literal"><span class="pre">--no-checks</span></tt>, which in turn
is implied by <tt class="docutils literal"><span class="pre">--fast</span></tt>.  By default stack overflow checks are enabled.</p>
<p>Chapel does not yet have a consistent, implementation-independent way to
deal with call stack overflow.  Each tasking layer implementation
handles stacks and stack overflow in its own way, as described below.</p>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id26">CHPL_TASKS == fifo</a><a class="headerlink" href="#id5" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div><p>In fifo tasking, Chapel tasks use their host pthreads&#8217; stacks when
executing.  If stack checks are enabled, these stacks are created with
an additional memory page called a &#8220;guard page&#8221; beyond their end, that
is marked so that it cannot be referenced.  When stack overflow occurs
the task&#8217;s attempt to reference the guard page will cause the OS to
react as it usually does when bad memory references are done.  On
Linux, for example, it will kill the program with this message:</p>
<blockquote>
<div>Segmentation fault</div></blockquote>
<p>Unfortunately, many other things that cause improper memory references
result in this same kind of program termination, so as a diagnostic it
is ambiguous.  However, it does at least prevent the program from
continuing on in an erroneous state.</p>
</div></blockquote>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id27">CHPL_TASKS == qthreads</a><a class="headerlink" href="#id6" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div>Like fifo tasks (see above), qthreads tasking can place guard pages
beyond the ends of task stacks.  Stack overflow then results in the
system&#8217;s usual response to referencing memory that cannot be reached.
With qthreads tasking, the compiler <tt class="docutils literal"><span class="pre">--stack-checks</span></tt> setting specifies
the default setting for execution-time stack overflow checking.  Final
control over stack overflow checks is provided by the <tt class="docutils literal"><span class="pre">QT_GUARD_PAGE</span></tt>
environment variable.  See the qthreads subsection of <a class="reference internal" href="#task-implementation-layers">Task
Implementation Layers</a> for more information.</div></blockquote>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id28">CHPL_TASKS == massivethreads</a><a class="headerlink" href="#id7" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div>No stack overflow detection is available.  If the <tt class="docutils literal"><span class="pre">--stack-checks</span></tt>
option is given to the compiler and <tt class="docutils literal"><span class="pre">CHPL_TASKS==massivethreads</span></tt>,
the compiler emits a warning that stack checks cannot be done.</div></blockquote>
</div>
</div>
<div class="section" id="task-related-quantification-methods-on-locales">
<h2><a class="toc-backref" href="#id29">Task-Related Quantification Methods on Locales</a><a class="headerlink" href="#task-related-quantification-methods-on-locales" title="Permalink to this headline">Â¶</a></h2>
<p>Several methods on the locale type are available to query the state of
the program with respect to its tasks.</p>
<blockquote>
<div><dl class="docutils">
<dt>queuedTasks()</dt>
<dd>returns the number of tasks that are ready to run, but
have not yet begun executing.</dd>
<dt>runningTasks()</dt>
<dd><p class="first">returns the number of tasks that have begun executing,
but have not yet finished.  Note that this number can exceed the
number of non-idle threads because there are cases in which a thread
is working on more than one task.  As one example, in fifo tasking,
when a parent task creates child tasks to execute the iterations of
a coforall construct, the thread the parent is running on may
temporarily suspend executing the parent task in order to help with
the child tasks, until the construct completes.  When this occurs
the count of running tasks can include both the parent task and a
child, although strictly speaking only the child is executing
instructions.</p>
<p class="last">As another example, any tasking implementation in which threads can
switch from running one task to running another, such as qthreads,
can have more tasks running than threads on which to run them.</p>
</dd>
<dt>blockedTasks()</dt>
<dd>returns the number of tasks that are blocked because
they are waiting on a sync or single variable.  In order to avoid
unnecessary overheads, in the implementations this method will not
generate meaningful information unless the program was run with the
<tt class="docutils literal"><span class="pre">-b/--blockreport</span></tt> flag.</dd>
<dt>totalThreads()</dt>
<dd>returns the number of threads that have been created
since the program started executing, regardless of whether they
are busy or idle.</dd>
<dt>idleThreads()</dt>
<dd>returns the number of threads are idle, i.e., not assigned to any task.</dd>
</dl>
</div></blockquote>
<p>In order to use these methods, you have to specify the locale you wish
to query, as in here.runningTasks(), where &#8216;here&#8217; is the current
locale.</p>
<p>(Note that these methods are available for all tasking options, but
currently only runningTasks() returns meaningful values for all options.
The others only return meaningful values for <tt class="docutils literal"><span class="pre">CHPL_TASKS=fifo</span></tt>.)</p>
</div>
<div class="section" id="future-tasking-directions">
<h2><a class="toc-backref" href="#id30">Future Tasking Directions</a><a class="headerlink" href="#future-tasking-directions" title="Permalink to this headline">Â¶</a></h2>
<p>As Chapel&#8217;s task parallel implementation matures, we expect to have
multiple task-&gt;thread scheduling policies, from literally creating and
destroying new threads with each task (for programmers who want full
control over a thread&#8217;s lifetime) to automated work stealing and load
balancing at the other end of the spectrum (for programmers who would
prefer not to manage threads or whose programs cannot trivially be
load balanced manually).  Our hope is to leverage existing open source
threading and task management software and to collaborate with others
in these areas, so please contact us at <a class="reference external" href="mailto:chapel_info&#37;&#52;&#48;cray&#46;com">chapel_info<span>&#64;</span>cray<span>&#46;</span>com</a> if you&#8217;d
like to work with us in this area.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="debugging.html" class="btn btn-neutral float-right" title="Debugging Chapel Programs">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="launcher.html" class="btn btn-neutral" title="Chapel Launchers"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Cray Inc.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.12.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

</body>
</html>
