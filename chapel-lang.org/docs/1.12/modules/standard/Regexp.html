

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Module: Regexp &mdash; Chapel Documentation 1.12 1.12.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  

  
    <link rel="top" title="Chapel Documentation 1.12 1.12.0 documentation" href="../../index.html"/>
        <link rel="up" title="Modules" href="../modules.html"/>
        <link rel="next" title="Module: Search" href="Search.html"/>
        <link rel="prev" title="Module: RecordParser" href="RecordParser.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> Chapel Documentation</a>
        
        
<?php   // Variables given by sphinx 
   $chplTitle = "1.12";   $pagename = "./modules/standard/Regexp";   include "../../versionButton.php";   ?>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/README.html">Quickstart Instructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/README.html#quick-start-instructions">Quick Start Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/README.html#what-s-next">What&#8217;s next?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/prereqs.html">Chapel Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/chplenv.html">Setting up Your Environment for Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/building.html">Building Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/compiling.html">Compiling Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/executing.html">Executing Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/multilocale.html">Multilocale Chapel Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/launcher.html">Chapel Launchers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/tasks.html">Chapel Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/debugging.html">Debugging Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usingchapel/bugs.html">Reporting Chapel Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/cray.html">Using Chapel on Cray Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/cygwin.html">Using Chapel on Cygwin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/ibm.html">Using Chapel on IBM Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/knc.html">Using Chapel on Intel Xeon Phi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/macosx.html">Using Chapel on Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/marenostrum.html">Using Chapel on MareNostrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../platforms/sgi.html">Using Chapel on SGI Altix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../builtins.html">Built-in Types and Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../internal/Atomics.html">Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelArray.html">Domain and Array Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelComplex_forDocs.html">Complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelIO.html">IO Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelIteratorSupport.html">Vectorizing Iterator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelLocale.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelRange.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelSyncvar.html">Synchronization Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/ChapelTuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/UtilMisc_forDocs.html">Misc Functions</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../standardlibrary.html">Standard Library</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../distributions.html">Distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../layouts.html">Layouts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/allocators.html">Chapel&#8217;s Use of Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/atomics.html">Runtime Support for Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/auxIO.html">Auxiliary I/O Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/chpl-ipe.html">Interactive Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/chpldoc.html">Documenting Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/dsi.html">Domain Map Standard Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/extern.html">C Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/firstClassFns.html">First-class Functions in Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/libraries.html">Exporting Chapel as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/llvm.html">LLVM Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/local.html">The &#8216;local&#8217; Statement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/localeModels.html">Locale Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/main.html">Support for main() Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/module_search.html">Module Search Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/reduceIntents.html">Reduce Intents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/sets.html">Associative Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../technotes/subquery.html">Querying a Local Subdomain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tools/chplvis/index.html">chplvis</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Chapel Documentation 1.12</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../standardlibrary.html">Standard Library</a> &raquo;</li>
      
          <li><a href="../modules.html">Modules</a> &raquo;</li>
      
    <li>Module: Regexp</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/modules/standard/Regexp.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <span class="target" id="module-Regexp"></span><div class="section" id="module-regexp">
<h1>Module: Regexp<a class="headerlink" href="#module-regexp" title="Permalink to this headline">¶</a></h1>
<p>Regular expression support.</p>
<p>The regular expression support is built on top of the RE2 regular expression
library. As such, the exact regular expression syntax available is the syntax
from RE2, which is available within the RE2 project at
<a class="reference external" href="https://github.com/google/re2">https://github.com/google/re2</a> and included here for your convenience.</p>
<div class="section" id="enabling-regular-expression-support">
<h2>Enabling Regular Expression Support<a class="headerlink" href="#enabling-regular-expression-support" title="Permalink to this headline">¶</a></h2>
<p>Setting the environment variable CHPL_REGEXP to re2 will enable regular
expression support with the RE2 library:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nb">export </span><span class="nv">CHPL_REGEXP</span><span class="o">=</span>re2
</pre></div>
</div>
<p>Then, rebuild Chapel. The RE2 library will be expanded from a release included
in the Chapel distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if re2 support is not enabled (which is the default), all features
described below will compile successfully, but will result in an internal
error at <em>run time</em>, saying &#8220;No Regexp Support&#8221;.</p>
</div>
</div>
<div class="section" id="using-regular-expression-support">
<h2>Using Regular Expression Support<a class="headerlink" href="#using-regular-expression-support" title="Permalink to this headline">¶</a></h2>
<div class="highlight-chapel"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Regexp</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">myRegexp</span> <span class="o">=</span> <span class="nx">compile</span><span class="p">(</span><span class="s">&quot;a+&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Now you can use these methods on regular expressions: <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.search</span></tt></a>,
<a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.match</span></tt></a>, <a class="reference internal" href="#Regexp.regexp.split" title="Regexp.regexp.split"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.split</span></tt></a>, <a class="reference internal" href="#Regexp.regexp.matches" title="Regexp.regexp.matches"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.matches</span></tt></a>.</p>
<p>You can also use the string versions of these methods: <a class="reference internal" href="#Regexp.string.search" title="Regexp.string.search"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">string.search</span></tt></a>,
<a class="reference internal" href="#Regexp.string.match" title="Regexp.string.match"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">string.match</span></tt></a>, <a class="reference internal" href="#Regexp.string.split" title="Regexp.string.split"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">string.split</span></tt></a>, or <a class="reference internal" href="#Regexp.string.matches" title="Regexp.string.matches"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">string.matches</span></tt></a>.</p>
<p>Lastly, you can include regular expressions in the format string for
<a class="reference internal" href="IO.html#IO.readf" title="IO.readf"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">readf</span></tt></a> for searching on QIO channels using the <tt class="docutils literal"><span class="pre">%/&lt;regexp&gt;/</span></tt>
syntax.</p>
</div>
<div class="section" id="regular-expression-examples">
<h2>Regular Expression Examples<a class="headerlink" href="#regular-expression-examples" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a+</span></tt></dt>
<dd>Match one or more <tt class="docutils literal"><span class="pre">a</span></tt> characters</dd>
<dt><tt class="docutils literal"><span class="pre">[[:space:]]*</span></tt> or <tt class="docutils literal"><span class="pre">\s*</span></tt> (which would be <tt class="docutils literal"><span class="pre">&quot;\\s*&quot;</span></tt> in a string)</dt>
<dd>Match zero or more spaces</dd>
<dt><tt class="docutils literal"><span class="pre">[[:digit:]]+</span></tt> or <tt class="docutils literal"><span class="pre">\d+</span></tt> (which would be <tt class="docutils literal"><span class="pre">&quot;\\d+&quot;</span></tt> in a string)</dt>
<dd>Match one or more digits</dd>
<dt><tt class="docutils literal"><span class="pre">([a-zA-Z0-9]+[[:space:]]+=[[:space:]]+[0-9]+</span></tt></dt>
<dd>Match sequences of the form <em>&lt;letters-and-digits&gt; &lt;spaces&gt;</em> <tt class="docutils literal"><span class="pre">=</span></tt> <em>&lt;digits&gt;</em></dd>
</dl>
</div>
<div class="section" id="re2-regular-expression-syntax-reference">
<span id="regular-expression-syntax"></span><h2>RE2 regular expression syntax reference<a class="headerlink" href="#re2-regular-expression-syntax-reference" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre>Single characters:
.            any character, possibly including newline (s=true)
[xyz]        character class
[^xyz]       negated character class
\d           Perl character class (see below)
\D           negated Perl character class (see below)
[:alpha:]    ASCII character class
[:^alpha:]   negated ASCII character class
\pN          Unicode character class (one-letter name)
\p{Greek}    Unicode character class
\PN          negated Unicode character class (one-letter name)
\P{Greek}    negated Unicode character class

Composites:
xy           «x» followed by «y»
x|y          «x» or «y» (prefer «x»)

Repetitions:
x*           zero or more «x», prefer more
x+           one or more «x», prefer more
x?           zero or one «x», prefer one
x{n,m}       «n» or «n»+1 or ... or «m» «x», prefer more
x{n,}        «n» or more «x», prefer more
x{n}         exactly «n» «x»
x*?          zero or more «x», prefer fewer
x+?          one or more «x», prefer fewer
x??          zero or one «x», prefer zero
x{n,m}?      «n» or «n»+1 or ... or «m» «x», prefer fewer
x{n,}?       «n» or more «x», prefer fewer
x{n}?        exactly «n» «x»

Grouping:
(re)         numbered capturing group
(?P&lt;name&gt;re) named &amp; numbered capturing group
(?:re)       non-capturing group
(?flags)     set flags within current group; non-capturing
(?flags:re)  set flags during re; non-capturing

Flags:
i            case-insensitive (default false)
m            multi-line mode: «^» and «$» match begin/end line in addition to
               begin/end text (default false)
s            let «.» match «\n» (default false)
U            ungreedy: swap meaning of «x*» and «x*?», «x+» and «x+?», etc.
               (default false)

Flag syntax is:
  «xyz»   (set)
  «-xyz»  (clear)
  «xy-z»  (set «xy», clear «z»)

Empty strings:
^            at beginning of text or line («m»=true)
$            at end of text (like «\z» not «\Z») or line («m»=true)
\A           at beginning of text
\b           at word boundary («\w» on one side and «\W», «\A», or «\z» on the
               other)
\B           not a word boundary
\z           at end of text

Escape sequences:
\a           bell (== \007)
\f           form feed (== \014)
\t           horizontal tab (== \011)
\n           newline (== \012)
\r           carriage return (== \015)
\v           vertical tab character (== \013)
\*           literal «*», for any punctuation character «*»
\123         octal character code (up to three digits)
\x7F         hex character code (exactly two digits)
\x{10FFFF}   hex character code
\C           match a single byte even in UTF-8 mode
\Q...\E      literal text «...» even if «...» has punctuation

Character class elements:
x            single character
A-Z          character range (inclusive)
\d           Perl character class (see below)
[:foo:]      ASCII character class «foo»
\p{Foo}      Unicode character class «Foo»
\pF          Unicode character class «F» (one-letter name)

Named character classes as character class elements:
[\d]         digits (== \d)
[^\d]        not digits (== \D)
[\D]         not digits (== \D)
[^\D]        not not digits (== \d)
[[:name:]]   named ASCII class inside character class (== [:name:])
[^[:name:]]  named ASCII class inside negated character class (== [:^name:])
[\p{Name}]   named Unicode property inside character class (== \p{Name})
[^\p{Name}]  named Unicode property inside negated character class (==\P{Name})

Perl character classes:
\d           digits (== [0-9])
\D           not digits (== [^0-9])
\s           whitespace (== [\t\n\f\r ])
\S           not whitespace (== [^\t\n\f\r ])
\w           word characters (== [0-9A-Za-z_])
\W           not word characters (== [^0-9A-Za-z_])

ASCII character classes::
  Note -- you must use these within a [] group! so if you want
          to match any number of spaces, use [[:space:]]* or \s*

[:alnum:]    alphanumeric (== [0-9A-Za-z])
[:alpha:]    alphabetic (== [A-Za-z])
[:ascii:]    ASCII (== [\x00-\x7F])
[:blank:]    blank (== [\t ])
[:cntrl:]    control (== [\x00-\x1F\x7F])
[:digit:]    digits (== [0-9])
[:graph:]    graphical (== [!-~] ==
               [A-Za-z0-9!&quot;#$%&amp;&#39;()*+,\-./:;&lt;=&gt;?@[\\\]^_`{|}~])
[:lower:]    lower case (== [a-z])
[:print:]    printable (== [ -~] == [[:graph:]])
[:punct:]    punctuation (== [!-/:-@[-`{-~])
[:space:]    whitespace (== [\t\n\v\f\r ])
[:upper:]    upper case (== [A-Z])
[:word:]     word characters (== [0-9A-Za-z_])
[:xdigit:]   hex digit (== [0-9A-Fa-f])

Unicode character class names--general category:
C            other
Cc           control
Cf           format
Co           private use
Cs           surrogate
L            letter
Ll           lowercase letter
Lm           modifier letter
Lo           other letter
Lt           titlecase letter
Lu           uppercase letter
M            mark
Mc           spacing mark
Me           enclosing mark
Mn           non-spacing mark
N            number
Nd           decimal number
Nl           letter number
No           other number
P            punctuation
Pc           connector punctuation
Pd           dash punctuation
Pe           close punctuation
Pf           final punctuation
Pi           initial punctuation
Po           other punctuation
Ps           open punctuation
S            symbol
Sc           currency symbol
Sk           modifier symbol
Sm           math symbol
So           other symbol
Z            separator
Zl           line separator
Zp           paragraph separator
Zs           space separator

Unicode character class names--scripts (with explanation where non-trivial):
Arabic
Armenian
Balinese
Bengali
Bopomofo
Braille
Buginese
Buhid
Canadian_Aboriginal
Carian
Cham
Cherokee
Common       characters not specific to one script
Coptic
Cuneiform
Cypriot
Cyrillic
Deseret
Devanagari
Ethiopic
Georgian
Glagolitic
Gothic
Greek
Gujarati
Gurmukhi
Han
Hangul
Hanunoo
Hebrew
Hiragana
Inherited    inherit script from previous character
Kannada
Katakana
Kayah_Li
Kharoshthi
Khmer
Lao
Latin
Lepcha
Limbu
Linear_B
Lycian
Lydian
Malayalam
Mongolian
Myanmar
New_Tai_Lue  aka Simplified Tai Lue
Nko
Ogham
Ol_Chiki
Old_Italic
Old_Persian
Oriya
Osmanya
Phags_Pa
Phoenician
Rejang
Runic
Saurashtra
Shavian
Sinhala
Sundanese
Syloti_Nagri
Syriac
Tagalog
Tagbanwa
Tai_Le
Tamil
Telugu
Thaana
Thai
Tibetan
Tifinagh
Ugaritic
Vai
Yi

Vim character classes:
\d      digits (== [0-9])
\D      not «\d»
\w      word character
\W      not «\w»
</pre></div>
</div>
</div>
<div class="section" id="regular-expression-types-and-methods">
<h2>Regular Expression Types and Methods<a class="headerlink" href="#regular-expression-types-and-methods" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Regexp.compile">
<em class="property">proc </em><tt class="descname">compile</tt><big>(</big><em>pattern: string</em>, <em>out error: syserr</em>, <em>utf8 = true</em>, <em>posix = false</em>, <em>literal = false</em>, <em>nocapture = false</em>, <em>ignorecase = false</em>, <em>multiline = false</em>, <em>dotnl = false</em>, <em>nongreedy = false</em><big>)</big>: regexp<a class="headerlink" href="#Regexp.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a regular expression. If the optional error argument is provided,
this routine will return an error code if compilation failed. Otherwise, it
will halt with an error message.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> &#8211; the string regular expression to compile.
See <a class="reference internal" href="#regular-expression-syntax"><em>RE2 regular expression syntax reference</em></a> for details. Note that
you may have to escape backslashes. For example, to
get the regular expression <tt class="docutils literal"><span class="pre">\s</span></tt>, you&#8217;d have to write
<tt class="docutils literal"><span class="pre">&quot;\\s&quot;</span></tt> because the <tt class="docutils literal"><span class="pre">\</span></tt> is the escape character within
Chapel string literals</li>
<li><strong>error</strong> &#8211; (optional) if provided, return an error code instead of halting
if an error is encountered</li>
<li><strong>utf8</strong> &#8211; (optional, default true) set to <cite>true</cite> to create a regular
expression matching UTF-8; <cite>false</cite> for binary or ASCII only.</li>
<li><strong>posix</strong> &#8211; (optional) set to true to disable non-POSIX regular expression
syntax</li>
<li><strong>literal</strong> &#8211; (optional) set to true to treat the regular expression as a
literal (ie, create a regexp matching <tt class="docutils literal"><span class="pre">pattern</span></tt> as a string
rather than as a regular expression).</li>
<li><strong>nocapture</strong> &#8211; (optional) set to true in order to disable all capture groups
in the regular expression</li>
<li><strong>ignorecase</strong> &#8211; (optional) set to true in order to ignore case when
matching. Note that this can be set inside the regular
expression with <tt class="docutils literal"><span class="pre">(?i)</span></tt>.</li>
<li><strong>multiline</strong> &#8211; (optional) set to true in order to activate multiline mode
(meaning that <tt class="docutils literal"><span class="pre">^</span></tt> and <tt class="docutils literal"><span class="pre">$</span></tt> match the beginning and end
of a line instead of just the beginning and end of the text.
Note that this can be set inside a regular expression
with <tt class="docutils literal"><span class="pre">(?m)</span></tt>.</li>
<li><strong>dotnl</strong> &#8211; (optional, default false) set to true in order to allow <tt class="docutils literal"><span class="pre">.</span></tt>
to match a newline. Note that this can be set inside the
regular expression with <tt class="docutils literal"><span class="pre">(?s)</span></tt>.</li>
<li><strong>nongreedy</strong> &#8211; (optional) set to true in order to prefer shorter matches for
repetitions; for example, normally x* will match as many x
characters as possible and x*? will match as few as possible.
This flag swaps the two, so that x* will match as few as
possible and x*? will match as many as possible. Note that
this flag can be set inside the regular expression with
<tt class="docutils literal"><span class="pre">(?U)</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="record">
<dt id="Regexp.reMatch">
<em class="property">record </em><tt class="descname">reMatch</tt><a class="headerlink" href="#Regexp.reMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>The reMatch record records a regular expression search match
or a capture group.</p>
<p>Regular expression search routines normally return one of these.
Also, this type can be passed as a capture group argument.
Lastly, something of type reMatch can be checked for a match
in a simple if statement, as in:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span class="kd">var</span> <span class="nx">m</span><span class="p">:</span><span class="nx">reMatch</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>
<span class="k">if</span> <span class="nx">m</span> <span class="k">then</span> <span class="nx">do_something_if_matched</span><span class="p">();</span>
<span class="k">if</span> <span class="o">!</span><span class="nx">m</span> <span class="k">then</span> <span class="nx">do_something_if_not_matched</span><span class="p">();</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="Regexp.reMatch.matched">
<em class="property">var </em><tt class="descname">matched</tt>: bool<a class="headerlink" href="#Regexp.reMatch.matched" title="Permalink to this definition">¶</a></dt>
<dd><p>true if the regular expression search matched successfully</p>
</dd></dl>

<dl class="attribute">
<dt id="Regexp.reMatch.offset">
<em class="property">var </em><tt class="descname">offset</tt>: int<a class="headerlink" href="#Regexp.reMatch.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>0-based offset into the string or channel that matched; -1 if matched=false</p>
</dd></dl>

<dl class="attribute">
<dt id="Regexp.reMatch.length">
<em class="property">var </em><tt class="descname">length</tt>: int<a class="headerlink" href="#Regexp.reMatch.length" title="Permalink to this definition">¶</a></dt>
<dd><p>the length of the match. 0 if matched==false</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Regexp.string.substring">
<em class="property">proc </em><tt class="descclassname">string.</tt><tt class="descname">substring</tt><big>(</big><em>m: reMatch</em><big>)</big><a class="headerlink" href="#Regexp.string.substring" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the part of a string matching a regular
expression or capture group. This method is intended to be
called on the same string used as the <cite>text</cite> in a regular
expression search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>m</strong> &#8211; a match (e.g. returned by <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.search</span></tt></a>)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the portion of <tt class="docutils literal"><span class="pre">this</span></tt> referred to by the match</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="record">
<dt id="Regexp.regexp">
<em class="property">record </em><tt class="descname">regexp</tt><a class="headerlink" href="#Regexp.regexp" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a compiled regular expression. Regular expressions
are currently cached on a per-thread basis and are reference counted.
To create a compiled regular expression, use the compile function.</p>
<p>A regexp can be cast to a string (resulting in the pattern that
was compiled). A string can be cast to a regexp (resulting in a compiled
regexp).</p>
<dl class="method">
<dt id="Regexp.regexp.ok">
<em class="property">proc </em><tt class="descname">ok</tt>: bool<a class="headerlink" href="#Regexp.regexp.ok" title="Permalink to this definition">¶</a></dt>
<dd><p>did this regular expression compile ?</p>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.error">
<em class="property">proc </em><tt class="descname">error</tt><big>(</big><big>)</big>: string<a class="headerlink" href="#Regexp.regexp.error" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string describing any error encountered when compiling this
regular expression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.search">
<em class="property">proc </em><tt class="descname">search</tt><big>(</big><em>text: ?t</em>, <em>ref captures ...?k</em><big>)</big>: reMatch<a class="headerlink" href="#Regexp.regexp.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search within the passed text for the first match at any offset to this
regular expression.  This routine will try matching the regular expression
at different offsets until a match is found. If you want to only match at
the beginning of the pattern, you can start your pattern with <tt class="docutils literal"><span class="pre">^</span></tt> and
end it with <tt class="docutils literal"><span class="pre">$</span></tt> or use <a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.match</span></tt></a>. If a capture group was not
matched, the corresponding argument will get the default value for its
type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> &#8211; a string to search</li>
<li><strong>captures</strong> &#8211; (optional) what to capture from the regular expression. These
should be strings or types that strings can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> object representing the offset in text
where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.match">
<em class="property">proc </em><tt class="descname">match</tt><big>(</big><em>text: ?t</em>, <em>ref captures ...?k</em><big>)</big>: reMatch<a class="headerlink" href="#Regexp.regexp.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a match to this regular expression at the start of the passed
text. If a capture group was not matched, the corresponding argument will
get the default value for its type.</p>
<p>For example, this function can be used to check to see if a string
fits a particular template:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span class="k">if</span> <span class="nx">myregexp</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s">&quot;some string&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">do_something_if_matched</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> &#8211; a string to search</li>
<li><strong>captures</strong> &#8211; what to capture from the regular expression. These should
be strings or types that strings can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> object representing the offset in text
where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.regexp.split">
<em class="property">iter </em><tt class="descname">split</tt><big>(</big><em>text: ?t</em>, <em>maxsplit: int = 0</em><big>)</big><a class="headerlink" href="#Regexp.regexp.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the text by occurrences of this regular expression.
If capturing parentheses are used in pattern, then the text of all
groups in the pattern are also returned as part of the resulting array.
If <em>maxsplit</em> is nonzero, at most maxsplit splits occur, and the
remaining text is returned as the last element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> &#8211; a string to split</li>
<li><strong>maxsplit</strong> &#8211; if nonzero, the maximum number of splits to do</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">each split portion, one at a time</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.regexp.matches">
<em class="property">iter </em><tt class="descname">matches</tt><big>(</big><em>text: ?t</em>, <em>param captures = 0</em>, <em>maxmatches: int = max(int)</em><big>)</big><a class="headerlink" href="#Regexp.regexp.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the string as well as capture groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> &#8211; the string to search</li>
<li><strong>captures</strong> &#8211; (compile-time constant) the size of the captures to return</li>
<li><strong>maxmatches</strong> &#8211; the maximum number of matches to return</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">tuples of <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> objects, the 1st is always
the match for the whole pattern and the rest are the capture groups.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.subn">
<em class="property">proc </em><tt class="descname">subn</tt><big>(</big><em>repl: string</em>, <em>text: ?t</em>, <em>global = true</em><big>)</big>: (string, int)<a class="headerlink" href="#Regexp.regexp.subn" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the same operation as <a class="reference internal" href="#Regexp.regexp.sub" title="Regexp.regexp.sub"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.sub</span></tt></a> but return a tuple
containing the new string and the number of substitutions made.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>repl</strong> &#8211; replace matches with this string</li>
<li><strong>text</strong> : <em>string</em> &#8211; the text to search and replace within</li>
<li><strong>global</strong> &#8211; if true, replace multiple matches</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple containing (new string, number of substitutions made)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.sub">
<em class="property">proc </em><tt class="descname">sub</tt><big>(</big><em>repl: string</em>, <em>text: ?t</em>, <em>global = true</em><big>)</big><a class="headerlink" href="#Regexp.regexp.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Find matches to this regular expression and create a new string in which
those matches are replaced by repl.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>repl</strong> &#8211; replace matches with this string</li>
<li><strong>text</strong> : <em>string</em> &#8211; the text to search and replace within</li>
<li><strong>global</strong> &#8211; if true, replace multiple matches</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Regexp.string.search">
<em class="property">proc </em><tt class="descclassname">string.</tt><tt class="descname">search</tt><big>(</big><em>needle: string</em>, <em>ignorecase = false</em><big>)</big>: reMatch<a class="headerlink" href="#Regexp.string.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a regular expression and search the receiving string for matches at
any offset using <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.search</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>needle</strong> &#8211; the regular expression to search for</li>
<li><strong>ignorecase</strong> &#8211; true to ignore case in the regular expression</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> object representing the offset in the
receiving string where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><tt class="descclassname">string.</tt><tt class="descname">search</tt><big>(</big><em>needle: regexp</em>, <em>ref captures ...?k</em><big>)</big>: reMatch</dt>
<dd><p>Search the receiving string for a regular expression already compiled
by calling <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.search</span></tt></a>. Search for matches at any offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>needle</strong> &#8211; the compiled regular expression to search for</li>
<li><strong>captures</strong> &#8211; (optional) what to capture from the regular expression. These
should be strings or types that strings can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> object representing the offset in the
receiving string where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.string.match">
<em class="property">proc </em><tt class="descclassname">string.</tt><tt class="descname">match</tt><big>(</big><em>pattern: regexp</em>, <em>ref captures ...?k</em><big>)</big>: reMatch<a class="headerlink" href="#Regexp.string.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the receiving string to a regular expression already compiled
by calling <a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.match</span></tt></a>. Only return matches where the match
encompasses the entire string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> &#8211; the compiled regular expression to match</li>
<li><strong>captures</strong> &#8211; (optional) what to capture from the regular expression. These
should be strings or types that strings can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> object representing the offset in the
receiving string where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.string.split">
<em class="property">iter </em><tt class="descclassname">string.</tt><tt class="descname">split</tt><big>(</big><em>pattern: regexp</em>, <em>maxsplit: int = 0</em><big>)</big><a class="headerlink" href="#Regexp.string.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the the receiving string by occurrences of the passed regular
expression by calling <a class="reference internal" href="#Regexp.regexp.split" title="Regexp.regexp.split"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.split</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> &#8211; the regular expression to use to split</li>
<li><strong>maxsplit</strong> &#8211; if nonzero, the maximum number of splits to do</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">each split portion, one at a time</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.string.matches">
<em class="property">iter </em><tt class="descclassname">string.</tt><tt class="descname">matches</tt><big>(</big><em>pattern: regexp</em>, <em>param captures = 0</em>, <em>maxmatches: int = max(int)</em><big>)</big><a class="headerlink" href="#Regexp.string.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the receiving string as well as capture groups
by calling <a class="reference internal" href="#Regexp.regexp.matches" title="Regexp.regexp.matches"><tt class="xref chpl chpl-proc docutils literal"><span class="pre">regexp.matches</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> &#8211; the regular expression to find matches</li>
<li><strong>captures</strong> &#8211; (compile-time constant) the size of the captures to return</li>
<li><strong>maxmatches</strong> &#8211; the maximum number of matches to return</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">tuples of <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><tt class="xref chpl chpl-record docutils literal"><span class="pre">reMatch</span></tt></a> objects, the 1st is always
the match for the whole pattern and the rest are the capture groups.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Search.html" class="btn btn-neutral float-right" title="Module: Search">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="RecordParser.html" class="btn btn-neutral" title="Module: RecordParser"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Cray Inc.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.12.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

</body>
</html>
