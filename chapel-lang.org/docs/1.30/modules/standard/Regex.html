<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Regex &mdash; Chapel Documentation 1.30</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Time" href="Time.html" />
    <link rel="prev" title="Help" href="Help.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.30
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.30";
$pagename = "modules/standard/Regex";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../standard.html#automatic-modules">Automatic Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#data-structures">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#files-io">Files/IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#language-support">Language Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#math-numerical">Math/Numerical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#parallelism-distributed-computing">Parallelism/Distributed Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#system-interoperability">System/Interoperability</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#utilities">Utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ChplConfig.html">ChplConfig</a></li>
<li class="toctree-l3"><a class="reference internal" href="Help.html">Help</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Regex</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#enabling-regular-expression-support">Enabling Regular Expression Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-regular-expression-support">Using Regular Expression Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#regular-expression-examples">Regular Expression Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#re2-regular-expression-syntax-reference">RE2 regular expression syntax reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#regular-expression-types-and-methods">Regular Expression Types and Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Time.html">Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="Version.html">Version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../builtins/WeakPointer.html">WeakPointer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
      <li>Regex</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/standard/Regex.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <span class="target" id="module-Regex"></span><div class="section" id="regex">
<h1>Regex<a class="headerlink" href="#regex" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Regex</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">Regex</span><span class="p">;</span>
</pre></div>
</div>
<p>Regular expression support.</p>
<p>The regular expression support is built on top of the RE2 regular expression
library. As such, the exact regular expression syntax available is the syntax
from RE2, which is available within the RE2 project at
<a class="reference external" href="https://github.com/google/re2">https://github.com/google/re2</a> and included here for your convenience.</p>
<div class="section" id="enabling-regular-expression-support">
<h2>Enabling Regular Expression Support<a class="headerlink" href="#enabling-regular-expression-support" title="Permalink to this headline">¶</a></h2>
<p>Setting the environment variable CHPL_RE2 to bundled will enable regular
expression support with the RE2 library:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">CHPL_RE2</span><span class="o">=</span>bundled
</pre></div>
</div>
<p>Then, rebuild Chapel. The RE2 library will be expanded from a release included
in the Chapel distribution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if re2 support is not enabled (which is the case in quickstart configurations
as in <a class="reference internal" href="../../usingchapel/QUICKSTART.html#chapelhome-quickstart"><span class="std std-ref">Chapel Quickstart Instructions</span></a>), the functionality described below will
result in either a compile-time or a run-time error.</p>
</div>
</div>
<div class="section" id="using-regular-expression-support">
<h2>Using Regular Expression Support<a class="headerlink" href="#using-regular-expression-support" title="Permalink to this headline">¶</a></h2>
<p>Chapel supports both string and bytes regular expressions.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Regex</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">myRegex</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">regex</span><span class="p">(</span><span class="s">&quot;a+&quot;</span><span class="p">);</span>   <span class="c1">// b&quot;a+&quot; for matching arbitrary bytes values</span>
</pre></div>
</div>
<p>Now you can use these methods on regular expressions: <a class="reference internal" href="#Regex.regex.search" title="Regex.regex.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.search</span></code></a>,
<a class="reference internal" href="#Regex.regex.match" title="Regex.regex.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.match</span></code></a>, <a class="reference internal" href="#Regex.regex.split" title="Regex.regex.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.split</span></code></a>, <a class="reference internal" href="#Regex.regex.matches" title="Regex.regex.matches"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.matches</span></code></a>.</p>
<p>Lastly, you can include regular expressions in the format string for
<a class="reference internal" href="IO/FormattedIO.html#FormattedIO.readf" title="FormattedIO.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readf</span></code></a> for searching on QIO channels using the <code class="docutils literal notranslate"><span class="pre">%/&lt;regex&gt;/</span></code>
syntax.</p>
</div>
<div class="section" id="regular-expression-examples">
<h2>Regular Expression Examples<a class="headerlink" href="#regular-expression-examples" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a+</span></code></dt><dd><p>Match one or more <code class="docutils literal notranslate"><span class="pre">a</span></code> characters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[[:space:]]*</span></code> or <code class="docutils literal notranslate"><span class="pre">\s*</span></code> (which would be <code class="docutils literal notranslate"><span class="pre">&quot;\\s*&quot;</span></code> in a string)</dt><dd><p>Match zero or more spaces</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[[:digit:]]+</span></code> or <code class="docutils literal notranslate"><span class="pre">\d+</span></code> (which would be <code class="docutils literal notranslate"><span class="pre">&quot;\\d+&quot;</span></code> in a string)</dt><dd><p>Match one or more digits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">([a-zA-Z0-9]+[[:space:]]+=[[:space:]]+[0-9]+</span></code></dt><dd><p>Match sequences of the form <em>&lt;letters-and-digits&gt; &lt;spaces&gt;</em> <code class="docutils literal notranslate"><span class="pre">=</span></code> <em>&lt;digits&gt;</em></p>
</dd>
</dl>
</div>
<div class="section" id="re2-regular-expression-syntax-reference">
<span id="regular-expression-syntax"></span><h2>RE2 regular expression syntax reference<a class="headerlink" href="#re2-regular-expression-syntax-reference" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Single characters:
.            any character, possibly including newline (s=true)
[xyz]        character class
[^xyz]       negated character class
\d           Perl character class (see below)
\D           negated Perl character class (see below)
[:alpha:]    ASCII character class
[:^alpha:]   negated ASCII character class
\pN          Unicode character class (one-letter name)
\p{Greek}    Unicode character class
\PN          negated Unicode character class (one-letter name)
\P{Greek}    negated Unicode character class

Composites:
xy           «x» followed by «y»
x|y          «x» or «y» (prefer «x»)

Repetitions:
x*           zero or more «x», prefer more
x+           one or more «x», prefer more
x?           zero or one «x», prefer one
x{n,m}       «n» or «n»+1 or ... or «m» «x», prefer more
x{n,}        «n» or more «x», prefer more
x{n}         exactly «n» «x»
x*?          zero or more «x», prefer fewer
x+?          one or more «x», prefer fewer
x??          zero or one «x», prefer zero
x{n,m}?      «n» or «n»+1 or ... or «m» «x», prefer fewer
x{n,}?       «n» or more «x», prefer fewer
x{n}?        exactly «n» «x»

Grouping:
(re)         numbered capturing group
(?P&lt;name&gt;re) named &amp; numbered capturing group
(?:re)       non-capturing group
(?flags)     set flags within current group; non-capturing
(?flags:re)  set flags during re; non-capturing

Flags:
i            case-insensitive (default false)
m            multi-line mode: «^» and «$» match begin/end line in addition to
               begin/end text (default false)
s            let «.» match «\n» (default false)
U            ungreedy: swap meaning of «x*» and «x*?», «x+» and «x+?», etc.
               (default false)

Flag syntax is:
  «xyz»   (set)
  «-xyz»  (clear)
  «xy-z»  (set «xy», clear «z»)

Empty strings:
^            at beginning of text or line («m»=true)
$            at end of text (like «\z» not «\Z») or line («m»=true)
\A           at beginning of text
\b           at word boundary («\w» on one side and «\W», «\A», or «\z» on the
               other)
\B           not a word boundary
\z           at end of text

Escape sequences:
\a           bell (== \007)
\f           form feed (== \014)
\t           horizontal tab (== \011)
\n           newline (== \012)
\r           carriage return (== \015)
\v           vertical tab character (== \013)
\*           literal «*», for any punctuation character «*»
\123         octal character code (up to three digits)
\x7F         hex character code (exactly two digits)
\x{10FFFF}   hex character code
\C           match a single byte even in UTF-8 mode
\Q...\E      literal text «...» even if «...» has punctuation

Character class elements:
x            single character
A-Z          character range (inclusive)
\d           Perl character class (see below)
[:foo:]      ASCII character class «foo»
\p{Foo}      Unicode character class «Foo»
\pF          Unicode character class «F» (one-letter name)

Named character classes as character class elements:
[\d]         digits (== \d)
[^\d]        not digits (== \D)
[\D]         not digits (== \D)
[^\D]        not not digits (== \d)
[[:name:]]   named ASCII class inside character class (== [:name:])
[^[:name:]]  named ASCII class inside negated character class (== [:^name:])
[\p{Name}]   named Unicode property inside character class (== \p{Name})
[^\p{Name}]  named Unicode property inside negated character class (==\P{Name})

Perl character classes:
\d           digits (== [0-9])
\D           not digits (== [^0-9])
\s           whitespace (== [\t\n\f\r ])
\S           not whitespace (== [^\t\n\f\r ])
\w           word characters (== [0-9A-Za-z_])
\W           not word characters (== [^0-9A-Za-z_])

ASCII character classes::
  Note -- you must use these within a [] group! so if you want
          to match any number of spaces, use [[:space:]]* or \s*

[:alnum:]    alphanumeric (== [0-9A-Za-z])
[:alpha:]    alphabetic (== [A-Za-z])
[:ascii:]    ASCII (== [\x00-\x7F])
[:blank:]    blank (== [\t ])
[:cntrl:]    control (== [\x00-\x1F\x7F])
[:digit:]    digits (== [0-9])
[:graph:]    graphical (== [!-~] ==
               [A-Za-z0-9!&quot;#$%&amp;&#39;()*+,\-./:;&lt;=&gt;?@[\\\]^_`{|}~])
[:lower:]    lower case (== [a-z])
[:print:]    printable (== [ -~] == [[:graph:]])
[:punct:]    punctuation (== [!-/:-@[-`{-~])
[:space:]    whitespace (== [\t\n\v\f\r ])
[:upper:]    upper case (== [A-Z])
[:word:]     word characters (== [0-9A-Za-z_])
[:xdigit:]   hex digit (== [0-9A-Fa-f])

Unicode character class names--general category:
C            other
Cc           control
Cf           format
Co           private use
Cs           surrogate
L            letter
Ll           lowercase letter
Lm           modifier letter
Lo           other letter
Lt           titlecase letter
Lu           uppercase letter
M            mark
Mc           spacing mark
Me           enclosing mark
Mn           non-spacing mark
N            number
Nd           decimal number
Nl           letter number
No           other number
P            punctuation
Pc           connector punctuation
Pd           dash punctuation
Pe           close punctuation
Pf           final punctuation
Pi           initial punctuation
Po           other punctuation
Ps           open punctuation
S            symbol
Sc           currency symbol
Sk           modifier symbol
Sm           math symbol
So           other symbol
Z            separator
Zl           line separator
Zp           paragraph separator
Zs           space separator

Unicode character class names--scripts (with explanation where non-trivial):
Arabic
Armenian
Balinese
Bengali
Bopomofo
Braille
Buginese
Buhid
Canadian_Aboriginal
Carian
Cham
Cherokee
Common       characters not specific to one script
Coptic
Cuneiform
Cypriot
Cyrillic
Deseret
Devanagari
Ethiopic
Georgian
Glagolitic
Gothic
Greek
Gujarati
Gurmukhi
Han
Hangul
Hanunoo
Hebrew
Hiragana
Inherited    inherit script from previous character
Kannada
Katakana
Kayah_Li
Kharoshthi
Khmer
Lao
Latin
Lepcha
Limbu
Linear_B
Lycian
Lydian
Malayalam
Mongolian
Myanmar
New_Tai_Lue  aka Simplified Tai Lue
Nko
Ogham
Ol_Chiki
Old_Italic
Old_Persian
Oriya
Osmanya
Phags_Pa
Phoenician
Rejang
Runic
Saurashtra
Shavian
Sinhala
Sundanese
Syloti_Nagri
Syriac
Tagalog
Tagbanwa
Tai_Le
Tamil
Telugu
Thaana
Thai
Tibetan
Tifinagh
Ugaritic
Vai
Yi

Vim character classes:
\d      digits (== [0-9])
\D      not «\d»
\w      word character
\W      not «\w»
</pre></div>
</div>
</div>
<div class="section" id="regular-expression-types-and-methods">
<h2>Regular Expression Types and Methods<a class="headerlink" href="#regular-expression-types-and-methods" title="Permalink to this headline">¶</a></h2>
<dl class="chpl class">
<dt class="sig sig-object chpl" id="Regex.BadRegexError">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">BadRegexError</span></span><span class="pre">:</span> <span class="pre">Error</span><a class="headerlink" href="#Regex.BadRegexError" title="Permalink to this definition">¶</a></dt>
<dd><dl class="chpl attribute">
<dt class="sig sig-object chpl" id="Regex.BadRegexError.msg">
<em class="property"><span class="pre">var</span> </em><span class="sig-name descname"><span class="pre">msg</span></span><span class="pre">:</span> <span class="pre">string</span><a class="headerlink" href="#Regex.BadRegexError.msg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.BadRegexError.init">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msg:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.BadRegexError.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.BadRegexError.message">
<em class="property"><span class="pre">override</span> <span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">message</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Regex.BadRegexError.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="Regex.compile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">posix</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">literal</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">noCapture</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">ignoreCase</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">multiLine</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">dotAll</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">nonGreedy</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">regex(t)</span> <span class="pre">throws</span><a class="headerlink" href="#Regex.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a regular expression. This routine will throw a
class:<cite>BadRegexError</cite> if compilation failed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This procedure is deprecated. Please use <a class="reference internal" href="#Regex.regex.init" title="Regex.regex.init"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.init</span></code></a> via <code class="docutils literal notranslate"><span class="pre">new</span>
<span class="pre">regex()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – the regular expression to compile. This argument can be string
or bytes. See <a class="reference internal" href="#regular-expression-syntax"><span class="std std-ref">RE2 regular expression syntax reference</span></a> for details.
Note that you may have to escape backslashes. For example, to
get the regular expression <code class="docutils literal notranslate"><span class="pre">\s</span></code>, you’d have to write
<code class="docutils literal notranslate"><span class="pre">&quot;\\s&quot;</span></code> because the <code class="docutils literal notranslate"><span class="pre">\</span></code> is the escape character within
Chapel string/bytes literals. Note that, Chapel supports
triple-quoted raw string/bytes literals, which do not require
escaping backslashes. For example <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;\s&quot;&quot;&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;\s&quot;&quot;&quot;</span></code>
can be used.</p></li>
<li><p><strong>posix</strong> – (optional) set to true to disable non-POSIX regular expression
syntax</p></li>
<li><p><strong>literal</strong> – (optional) set to true to treat the regular expression as a
literal (ie, create a regex matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> as a string
rather than as a regular expression).</p></li>
<li><p><strong>noCapture</strong> – (optional) set to true in order to disable all capture groups
in the regular expression</p></li>
<li><p><strong>ignoreCase</strong> – (optional) set to true in order to ignore case when
matching. Note that this can be set inside the regular
expression with <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p></li>
<li><p><strong>multiLine</strong> – (optional) set to true in order to activate multiline mode
(meaning that <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">$</span></code> match the beginning and end
of a line instead of just the beginning and end of the text.
Note that this can be set inside a regular expression
with <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p></li>
<li><p><strong>dotAll</strong> – (optional) set to true in order to allow <code class="docutils literal notranslate"><span class="pre">.</span></code>
to match a newline. Note that this can be set inside the
regular expression with <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p></li>
<li><p><strong>nonGreedy</strong> – (optional) set to true in order to prefer shorter matches for
repetitions; for example, normally x* will match as many x
characters as possible and x*? will match as few as possible.
This flag swaps the two, so that x* will match as few as
possible and x*? will match as many as possible. Note that
this flag can be set inside the regular expression with
<code class="docutils literal notranslate"><span class="pre">(?U)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>BadRegexError</strong> – If the argument ‘pattern’ has syntactical errors.
Refer to <a class="reference external" href="https://github.com/google/re2/blob/master/re2/re2.h">https://github.com/google/re2/blob/master/re2/re2.h</a>
for more details about error codes.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="Regex.regexMatch">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">regexMatch</span></span><a class="headerlink" href="#Regex.regexMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>The regexMatch record records a regular expression search match
or a capture group.</p>
<p>Regular expression search routines normally return one of these.
Also, this type can be passed as a capture group argument.
Lastly, something of type regexMatch can be checked for a match
in a simple if statement, as in:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">m</span><span class="p">:</span><span class="nx">regexMatch</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>
<span class="k">if</span> <span class="nx">m</span> <span class="k">then</span> <span class="nx">do_something_if_matched</span><span class="p">();</span>
<span class="k">if</span> <span class="o">!</span><span class="nx">m</span> <span class="k">then</span> <span class="nx">do_something_if_not_matched</span><span class="p">();</span>
</pre></div>
</div>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="Regex.regexMatch.matched">
<em class="property"><span class="pre">var</span> </em><span class="sig-name descname"><span class="pre">matched</span></span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#Regex.regexMatch.matched" title="Permalink to this definition">¶</a></dt>
<dd><p>true if the regular expression search matched successfully</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="Regex.regexMatch.byteOffset">
<em class="property"><span class="pre">var</span> </em><span class="sig-name descname"><span class="pre">byteOffset</span></span><span class="pre">:</span> <span class="pre">byteIndex</span><a class="headerlink" href="#Regex.regexMatch.byteOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>0-based offset into the string or channel that matched; -1 if matched=false</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="Regex.regexMatch.numBytes">
<em class="property"><span class="pre">var</span> </em><span class="sig-name descname"><span class="pre">numBytes</span></span><span class="pre">:</span> <span class="pre">int</span><a class="headerlink" href="#Regex.regexMatch.numBytes" title="Permalink to this definition">¶</a></dt>
<dd><p>the length of the match. 0 if matched==false</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.string.this">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">string.</span></span><span class="sig-name descname"><span class="pre">this</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">m:</span> <span class="pre">regexMatch</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.string.this" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the part of a string matching a regular
expression or capture group. This method is intended to be
called on the same string used as the <cite>text</cite> in a regular
expression search.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>m</strong> – a match (e.g. returned by <a class="reference internal" href="#Regex.regex.search" title="Regex.regex.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.search</span></code></a>)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> referred to by the match</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.bytes.this">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">this</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">m:</span> <span class="pre">regexMatch</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.bytes.this" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the part of a bytes matching a regular
expression or capture group. This method is intended to be
called on the same bytes used as the <cite>text</cite> in a regular
expression search.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>m</strong> – a match (e.g. returned by <a class="reference internal" href="#Regex.regex.search" title="Regex.regex.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.search</span></code></a>)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> referred to by the match</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="Regex.regex">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">regex</span></span><a class="headerlink" href="#Regex.regex" title="Permalink to this definition">¶</a></dt>
<dd><p>This record represents a compiled regular expression. Regular expressions
are currently cached on a per-thread basis and are reference counted.
To create a compiled regular expression, use the proc:<cite>compile</cite> function.</p>
<p>A string-based regex can be cast to a string (resulting in the pattern that
was compiled). A string can be cast to a string-based regex (resulting in a
compiled regex). Same applies for bytes.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.init">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">exprType</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.regex.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">posix</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">literal</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">noCapture</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">ignoreCase</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">multiLine</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">dotAll</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">nonGreedy</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Initializer for a compiled regular expression. <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">regex()</span></code> throws a
<a class="reference internal" href="#Regex.BadRegexError" title="Regex.BadRegexError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">BadRegexError</span></code></a> if compilation failed.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – the regular expression to compile. This argument can be
string or bytes. See <a class="reference internal" href="#regular-expression-syntax"><span class="std std-ref">RE2 regular expression syntax reference</span></a> for
details.  Note that you may have to escape backslashes. For
example, to get the regular expression <code class="docutils literal notranslate"><span class="pre">\s</span></code>, you’d have to
write <code class="docutils literal notranslate"><span class="pre">&quot;\\s&quot;</span></code> because the <code class="docutils literal notranslate"><span class="pre">\</span></code> is the escape character
within Chapel string/bytes literals. Note that, Chapel
supports triple-quoted raw string/bytes literals, which do
not require escaping backslashes. For example <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;\s&quot;&quot;&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;\s&quot;&quot;&quot;</span></code> can be used.</p></li>
<li><p><strong>posix</strong> – (optional) set to true to disable non-POSIX regular expression
syntax</p></li>
<li><p><strong>literal</strong> – (optional) set to true to treat the regular expression as a
literal (ie, create a regex matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> as a string
rather than as a regular expression).</p></li>
<li><p><strong>noCapture</strong> – (optional) set to true in order to disable all capture
groups in the regular expression</p></li>
<li><p><strong>ignoreCase</strong> – (optional) set to true in order to ignore case when
matching. Note that this can be set inside the regular
expression with <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p></li>
<li><p><strong>multiLine</strong> – (optional) set to true in order to activate multiline mode
(meaning that <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">$</span></code> match the beginning and end
of a line instead of just the beginning and end of the
text.  Note that this can be set inside a regular
expression with <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p></li>
<li><p><strong>dotAll</strong> – (optional) set to true in order to allow <code class="docutils literal notranslate"><span class="pre">.</span></code>
to match a newline. Note that this can be set inside the
regular expression with <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p></li>
<li><p><strong>nonGreedy</strong> – (optional) set to true in order to prefer shorter matches
for repetitions; for example, normally x* will match as
many x characters as possible and x*? will match as few as
possible.  This flag swaps the two, so that x* will match
as few as possible and x*? will match as many as possible.
Note that this flag can be set inside the regular
expression with <code class="docutils literal notranslate"><span class="pre">(?U)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>BadRegexError</strong> – If the argument ‘pattern’ has syntactical errors.
Refer to <a class="reference external" href="https://github.com/google/re2/blob/master/re2/re2.h">https://github.com/google/re2/blob/master/re2/re2.h</a>
for more details about error codes.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.init=">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">init=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x:</span> <span class="pre">regex(?)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.regex.init=" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.search">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">captures</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">regexMatch</span><a class="headerlink" href="#Regex.regex.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search within the passed text for the first match at any offset to this
regular expression.  This routine will try matching the regular expression
at different offsets until a match is found. If you want to only match at
the beginning of the pattern, you can start your pattern with <code class="docutils literal notranslate"><span class="pre">^</span></code> and
end it with <code class="docutils literal notranslate"><span class="pre">$</span></code> or use <a class="reference internal" href="#Regex.regex.match" title="Regex.regex.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.match</span></code></a>. If a capture group was not
matched, the corresponding argument will get the default value for its
type.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – a string or bytes to search</p></li>
<li><p><strong>captures</strong> – (optional) what to capture from the regular expression.
If the class:<cite>regex</cite> was based on string, then, these
should be strings or types that strings can cast to. Same
applies for bytes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an <a class="reference internal" href="#Regex.regexMatch" title="Regex.regexMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">regexMatch</span></code></a> object representing the offset in text
where a match occurred</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.match">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">captures</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">regexMatch</span><a class="headerlink" href="#Regex.regex.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a match to this regular expression at the start of the passed
text. If a capture group was not matched, the corresponding argument will
get the default value for its type.</p>
<p>For example, this function can be used to check to see if a string
fits a particular template:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">myRegex</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s">&quot;some string&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">doSomethingIfMatched</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – a string or bytes to search</p></li>
<li><p><strong>captures</strong> – what to capture from the regular expression.
If the class:<cite>regex</cite> was based on string, then, these
should be strings or types that strings can cast to. Same
applies for bytes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an <a class="reference internal" href="#Regex.regexMatch" title="Regex.regexMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">regexMatch</span></code></a> object representing the offset in text
where a match occurred</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.fullMatch">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">fullMatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">captures</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">regexMatch</span><a class="headerlink" href="#Regex.regex.fullMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a match to this regular expression in the full passed text.
If a capture group was not matched, the corresponding argument will
get the default value for its type.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – a string or bytes to search</p></li>
<li><p><strong>captures</strong> – what to capture from the regular expression.
If the class:<cite>regex</cite> was based on string, then, these
should be strings or types that strings can cast to. Same
applies for bytes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an <a class="reference internal" href="#Regex.regexMatch" title="Regex.regexMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">regexMatch</span></code></a> object representing the offset in text
where a match occurred</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="Regex.regex.split">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">maxsplit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.regex.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the text by occurrences of this regular expression.
If capturing parentheses are used in pattern, then the text of all
groups in the pattern are also returned as part of the resulting array.
If <em>maxsplit</em> is nonzero, at most maxsplit splits occur, and the
remaining text is returned as the last element.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – a string or bytes to split</p></li>
<li><p><strong>maxsplit</strong> – if nonzero, the maximum number of splits to do</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>each split portion, one at a time</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="Regex.regex.matches">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">matches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">numCaptures</span> <span class="pre">=</span> <span class="pre">0</span></em>, <em class="sig-param"><span class="pre">maxMatches:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">max(int)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.regex.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the text as well as capture groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – the string or bytes to search</p></li>
<li><p><strong>captures</strong> – (compile-time constant) the size of the captures to return</p></li>
<li><p><strong>maxmatches</strong> – the maximum number of matches to return</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>tuples of <a class="reference internal" href="#Regex.regexMatch" title="Regex.regexMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">regexMatch</span></code></a> objects, the 1st is always
the match for the whole pattern and the rest are the capture groups.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">matches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">captures</span> <span class="pre">=</span> <span class="pre">0</span></em>, <em class="sig-param"><span class="pre">maxmatches:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">max(int)</span></em><span class="sig-paren">)</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>regex.matches arguments ‘captures’ and ‘maxmatches’ are deprecated. Use ‘numCaptures’ and/or ‘maxMatches instead.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.subn">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">repl:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">global</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">(exprType,</span> <span class="pre">int)</span><a class="headerlink" href="#Regex.regex.subn" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the same operation as <a class="reference internal" href="#Regex.regex.sub" title="Regex.regex.sub"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.sub</span></code></a> but return a tuple
containing the new text and the number of substitutions made.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is deprecated. Please use <a class="reference internal" href="#Regex.string.replaceAndCount" title="Regex.string.replaceAndCount"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.replaceAndCount</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>repl</strong> – replace matches with this string or bytes</p></li>
<li><p><strong>text</strong> : <cite>string</cite> or <cite>bytes</cite> – the text to search and replace within</p></li>
<li><p><strong>global</strong> – if true, replace multiple matches</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple containing (new text, number of substitutions made)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.regex.sub">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">repl:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">text:</span> <span class="pre">exprType</span></em>, <em class="sig-param"><span class="pre">global</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.regex.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Find matches to this regular expression and create a new string or bytes in
which those matches are replaced by repl.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is deprecated. Please use <a class="reference internal" href="#Regex.string.replace" title="Regex.string.replace"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.replace</span></code></a> with <cite>regex</cite>
argument.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>repl</strong> – replace matches with this string or bytes</p></li>
<li><p><strong>text</strong> : <cite>string</cite> or <cite>bytes</cite> – the text to search and replace within</p></li>
<li><p><strong>global</strong> – if true, replace multiple matches</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new string or bytes</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.string.find">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">string.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(string)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">byteIndex</span><a class="headerlink" href="#Regex.string.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the receiving string for the result of a compiled regular
expression. Search for matches at any offset.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>pattern</strong> – the compiled regular expression to search for</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a byteIndex representing the offset in the receiving string
where a match occurred</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.bytes.find">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(bytes)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">byteIndex</span><a class="headerlink" href="#Regex.bytes.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the receiving bytes for the result of a compiled regular
expression. Search for matches at any offset.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>pattern</strong> – the compiled regular expression to search for</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a byteIndex representing the offset in the receiving bytes
where a match occurred</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.string.replace">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">string.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(string)</span></em>, <em class="sig-param"><span class="pre">replacement:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">string</span><a class="headerlink" href="#Regex.string.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the receiving string for the pattern. Returns a new string where the
match(es) to the pattern is replaced with a replacement.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – the compiled regular expression to search for</p></li>
<li><p><strong>replacement</strong> – string to replace with</p></li>
<li><p><strong>count</strong> – number of maximum replacements to make, values less than zero
replaces all occurrences</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.bytes.replace">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(bytes)</span></em>, <em class="sig-param"><span class="pre">replacement:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bytes</span><a class="headerlink" href="#Regex.bytes.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the receiving bytes for the pattern. Returns a new bytes where the
match(es) to the pattern is replaced with a replacement.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – the compiled regular expression to search for</p></li>
<li><p><strong>replacement</strong> – bytes to replace with</p></li>
<li><p><strong>count</strong> – number of maximum replacements to make, values less than zero
replaces all occurrences</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.string.replaceAndCount">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">string.</span></span><span class="sig-name descname"><span class="pre">replaceAndCount</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(string)</span></em>, <em class="sig-param"><span class="pre">replacement:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">(string,</span> <span class="pre">int)</span><a class="headerlink" href="#Regex.string.replaceAndCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the receiving string for the pattern. Returns a new string where the
match(es) to the pattern is replaced with a replacement and number of
replacements.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – the compiled regular expression to search for</p></li>
<li><p><strong>replacement</strong> – string to replace with</p></li>
<li><p><strong>count</strong> – number of maximum replacements to make, values less than zero
replaces all occurrences</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.bytes.replaceAndCount">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">replaceAndCount</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(bytes)</span></em>, <em class="sig-param"><span class="pre">replacement:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">(bytes,</span> <span class="pre">int)</span><a class="headerlink" href="#Regex.bytes.replaceAndCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the receiving bytes for the pattern. Returns a new bytes where the
match(es) to the pattern is replaced with a replacement and number of
replacements.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – the compiled regular expression to search for</p></li>
<li><p><strong>replacement</strong> – bytes to replace with</p></li>
<li><p><strong>count</strong> – number of maximum replacements to make, values less than zero
replaces all occurrences</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.string.startsWith">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">string.</span></span><span class="sig-name descname"><span class="pre">startsWith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(string)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#Regex.string.startsWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the start of the string matches the pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>pattern</strong> – the compiled regular expression to match</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if string starts with <cite>pattern</cite>, false otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.bytes.startsWith">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">startsWith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pattern:</span> <span class="pre">regex(bytes)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#Regex.bytes.startsWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the start of the bytes matches the pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>pattern</strong> – the compiled regular expression to match</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if string starts with <cite>pattern</cite>, false otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="Regex.string.split">
<em class="property"><span class="pre">iter</span> </em><span class="sig-prename descclassname"><span class="pre">string.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sep:</span> <span class="pre">regex(string)</span></em>, <em class="sig-param"><span class="pre">maxsplit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.string.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the receiving string by occurrences of the passed regular
expression by calling <a class="reference internal" href="#Regex.regex.split" title="Regex.regex.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.split</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sep</strong> – the regular expression to use to split</p></li>
<li><p><strong>maxsplit</strong> – if nonzero, the maximum number of splits to do</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>each split portion, one at a time</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="Regex.bytes.split">
<em class="property"><span class="pre">iter</span> </em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sep:</span> <span class="pre">regex(bytes)</span></em>, <em class="sig-param"><span class="pre">maxsplit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Regex.bytes.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the receiving bytes by occurrences of the passed regular
expression by calling <a class="reference internal" href="#Regex.regex.split" title="Regex.regex.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regex.split</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sep</strong> – the regular expression to use to split</p></li>
<li><p><strong>maxsplit</strong> – if nonzero, the maximum number of splits to do</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>each split portion, one at a time</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.fileReader.readThrough">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">regex(?t)</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><a class="headerlink" href="#Regex.fileReader.readThrough" title="Permalink to this definition">¶</a></dt>
<dd><p>Read until a match with the given separator is found, returning the contents of
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> through that point.</p>
<p>If a match is found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is left immediately
after it. If the separator could not be found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>
codepoints/bytes, a <code class="docutils literal notranslate"><span class="pre">BadFormatError</span></code> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s
position is not changed. If EOF is reached before finding the separator, the
remainder of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s contents are returned and the position is
left at EOF.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The <a class="reference internal" href="#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator to match with.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints/bytes to read. For the default
value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned
<code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.  If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the returned value will not
include the captured separator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
up to (and possibly including) the match.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>
bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">regex(string)</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until a match with the given separator is found, returning the contents of
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> through that point.</p>
<p>See the above <a class="reference internal" href="#Regex.fileReader.readThrough" title="Regex.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The <a class="reference internal" href="#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned
<code class="docutils literal notranslate"><span class="pre">string</span></code>.  If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the captured separator will be removed from <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>
bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">regex(bytes)</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until a match with the given separator is found, returning the contents of
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> through that point.</p>
<p>See the above <a class="reference internal" href="#Regex.fileReader.readThrough" title="Regex.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The <a class="reference internal" href="#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value of
<code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>.  If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the captured separator will be removed from <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>
bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="Regex.fileReader.readTo">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">regex(?t)</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><a class="headerlink" href="#Regex.fileReader.readTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read until a match with the given separator is found, returning the
contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> up to that point.</p>
<p>If a match is found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is left immediately
before it. If the separator could not be found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>
codepoints/bytes, a <code class="docutils literal notranslate"><span class="pre">BadFormatError</span></code> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s
position is not changed. If EOF is reached before finding the separator,
the remainder of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s contents are returned and the
position is left at EOF.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The <a class="reference internal" href="#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator to match with.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default
value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the channel up to
the <code class="docutils literal notranslate"><span class="pre">separator</span></code>.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<cite>maxSize</cite> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">regex(string)</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until a match with the given separator is found, returning the
contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> up to that point.</p>
<p>See the above <a class="reference internal" href="#Regex.fileReader.readTo" title="Regex.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The <a class="reference internal" href="#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<cite>maxSize</cite> codepoints. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">regex(bytes)</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until a match with the given separator is found, returning the
contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> up to that point.</p>
<p>See the above <a class="reference internal" href="#Regex.fileReader.readTo" title="Regex.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The <a class="reference internal" href="#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator to match with.</p></li>
<li><p><strong>b</strong> – The <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<cite>maxSize</cite> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> position is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Help.html" class="btn btn-neutral float-left" title="Help" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Time.html" class="btn btn-neutral float-right" title="Time" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>