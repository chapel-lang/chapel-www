.. default-domain:: chpl

.. module:: IO
   :synopsis: Support for a variety of kinds of input and output.

IO
==
**Usage**

.. code-block:: chapel

   use IO;


or

.. code-block:: chapel

   import IO;

**Submodules**

.. toctree::
   :maxdepth: 1
   :glob:

   IO/*




Support for a variety of kinds of input and output.

.. note:: All Chapel programs automatically include :proc:`~ChapelIO.write`,
          :proc:`~ChapelIO.writeln` and :proc:`~ChapelIO.writef`.  These symbols
          can also be accessed using ``IO.`` as their qualified access prefix.

Input/output (I/O) facilities in Chapel include the types :record:`file`,
:record:`fileReader` and :record:`fileWriter`; the constants :record:`stdin`,
:record:`stdout` and :record:`stderr`; the functions :proc:`open`,
:proc:`file.close`, :proc:`file.reader`, :proc:`file.writer`,
:proc:`fileReader.read`, :proc:`fileWriter.write`, and many others.

.. warning::
  Please be aware, the IO Module documentation is under development and
  currently contains some minor inconsistencies.

.. _about-io-overview:

I/O Overview
------------

A :record:`file` in Chapel identifies a file in the underlying operating system.
Reads to a file are done via one or more fileReaders associated with the file
and writes to a file are done via one or more fileWriters.  Each
:record:`fileReader` or :record:`fileWriter` uses a buffer to provide sequential
read or write access to its file, optionally starting at an offset.

For example, the following program opens a file and writes an integer to it:

.. code-block:: chapel

  try {
    // open the file "test-file.txt" for writing, creating it if
    // it does not exist yet.
    var myFile = open("test-file.txt", ioMode.cw);

    // create a fileWriter starting at file offset 0
    // (start and end offsets can be specified when creating the
    // fileWriter)
    var myFileWriter = myFile.writer();

    var x: int = 17;

    // This function will write the human-readable text version of x;
    // binary I/O is also possible.
    myFileWriter.write(x);

    // Now test-file.txt contains:
    // 17

  } catch e: Error {
    // Generally speaking, the I/O functions throw errors.  Handling these
    // errors is application-dependent and is left out of this example for
    // brevity.  Please see the documentation for individual functions for more
    // details about errors that they can throw.
  }

Then, the following program can be used to read the integer:

.. code-block:: chapel

  try {
    // open the file "test-file.txt" for reading only
    var myFile = open("test-file.txt", ioMode.r);

    // create a fileReader starting at file offset 0
    // (start and end offsets can be specified when creating the
    // fileReader)
    var myFileReader = myFile.reader();

    var x: int;

    // Now read a textual integer. Note that the
    // fileReader.read function returns a bool to indicate
    // if it read something or if the end of the file
    // was reached before something could be read.
    var readSomething = myFileReader.read(x);

    writeln("Read integer ", x);
    // prints out:
    // Read integer 17

  } catch e: Error {
    // Generally speaking, the I/O functions throw errors.  Handling these
    // errors is application-dependent and is left out of this example for
    // brevity.  Please see the documentation for individual functions for more
    // details about errors that they can throw.
  }

The :proc:`~IO.read` functions allow one to read values into variables as
the following example demonstrates. It shows three ways to read values into
a pair of variables ``x`` and ``y``.

.. code-block:: chapel

  var x: int;
  var y: real;
  /* reading into variable expressions, returning
     true if the values were read, false on EOF */
  var ok:bool = read(x, y);

  /* reading via a single type argument */
  x = read(int);
  y = read(real);

  /* reading via multiple type arguments */
  (x, y) = read(int, real);

Design Rationale
----------------

Since fileReaders and fileWriters operate independently, concurrent I/O to the
same open file is possible without contending for locks.  Furthermore, since the
fileReader or fileWriter (and not the file) stores the current file offset, it
is straightforward to create programs that access the same open file in
parallel. Note that such parallel access is not possible in C when multiple
threads are using the same ``FILE*`` to write to different regions of a file
because of the race condition between ``fseek`` and ``fwrite``. Because of these
issues, Chapel programmers wishing to perform I/O will need to know how to open
files as well as create fileReaders and fileWriters.


.. _about-io-styles:

I/O Styles
----------

.. warning::

   :record:`iostyle` is now unstable.
   We are working on creating a full-featured replacement for it
   but in the meantime the :ref:`about-io-formatted-io` facilities are still
   available to control formatting.

Reading and writing of Chapel's basic types is regulated by an applicable
:record:`iostyle`.  In particular, the I/O style controls whether binary or text
I/O should be performed. For binary I/O it specifies, for example, byte order
and string encoding. For text I/O it specifies string representation; the base,
field width and precision for numeric types; and so on.  Each fileReader or
fileWriter has an associated I/O style.  It applies to all read/write operations
on that fileReader or fileWriter, except when the program specifies explicitly
an I/O style for a particular read or write.

See the definition for the :record:`iostyle` type. This type represents I/O
styles and provides details on formatting and other representation choices.

The default value of the :record:`iostyle` type is undefined.  However, the
compiler-generated constructor is available.  It can be used to generate the
default I/O style, with or without modifications. In addition, the function
:proc:`defaultIOStyle` will return the default I/O style just as ``new
iostyle()`` will.

The I/O style for an I/O operation can be provided through an optional
``style=`` argument in a variety of places:

 * when performing the I/O, e.g. in calls to :proc:`fileWriter.write` or
   :proc:`fileReader.read`
 * when creating the fileReader with :proc:`file.reader`
 * when creating the fileWriter :proc:`file.writer`
 * or when creating the file with e.g. :proc:`open`

Note that :proc:`file.reader`, or :proc:`file.writer` will copy the file's I/O
style if a ``style=`` argument is not provided. Also note that I/O functions on
fileReaders and fileWriters will by default use the I/O style stored with that
fileReader or fileWriter.

A fileReader's I/O style may be retrieved using :proc:`fileReader._style` and
set using :proc:`fileReader._set_style`. A fileWriter's I/O style may be
retrieved using :proc:`fileWriter._style` and set using
:proc:`fileWriter._set_style`. These functions should only be called while the
fileReader's or fileWriter's lock is held, however. See
:ref:`about-io-filereader-filewriter-synchronization` for more information on
fileReader and fileWriter locks.

As an example for specifying an I/O style, the code below specifies the minimum
width for writing numbers so array elements are aligned in the output:

.. code-block:: chapel

  stdout.writeln(MyArray, new iostyle(min_width=10));


I/O facilities in Chapel also include several other ways to control I/O
formatting. There is support for :ref:`formatted I/O <about-io-formatted-io>`
with :proc:`FormattedIO.fileReader.readf` and
:proc:`FormattedIO.fileWriter.writef`.  Also note that record or class
implementations can provide custom functions implementing read or write
operations for that type (see :ref:`readThis-writeThis`).

.. _about-io-files:

Files
-----

There are several functions that open a file and return a :record:`file`
including :proc:`open`, :proc:`openTempFile`, :proc:`openMemFile`, the
:record:`file` initializer that takes an ``int`` argument, and the
:record:`file` initializer that takes a :type:`~CTypes.c_FILE` argument.

Once a file is open, it is necessary to create associated fileReader(s) and/or
fileWriter(s) - see :proc:`file.reader` and :proc:`file.writer` - to read from
and/or write to the file.

Use the :proc:`file.fsync` function to explicitly synchronize the file to
ensure that file data is committed to the file's underlying device for
persistence.

Files, fileReaders, and fileWriters will be kept alive while there are variables
referring to them and closed when all variables referring to them have gone out
of scope.  However, each can be closed explicitly with ``close`` methods.  Note
that :proc:`file.close` will not work if the file has open fileReaders and/or
fileWriters.

 .. note::

    :ref:`Escaped strings <string.nonunicode>` can be used for paths on systems
    where UTF-8 file names are not enforced.


.. _about-io-filereader-filewriter-creation:

Functions for fileReader and fileWriter Creation
------------------------------------------------

:proc:`file.writer` creates a :record:`fileWriter` for writing to a file, and
:proc:`file.reader` creates a :record:`fileReader` for reading from a file.

The helper functions :proc:`openReader` and :proc:`openWriter` can also be used
to open a file and create a ``fileReader`` or ``fileWriter`` to it in a
single step.

.. _about-io-filereader-filewriter-synchronization:

Synchronization of fileReader and fileWriter Data and Avoiding Data Races
-------------------------------------------------------------------------

FileReaders and fileWriters (and files) contain locks in order to keep their
operation safe for multiple tasks. When creating a fileReader or fileWriter, it
is possible to disable the lock (for performance reasons) by passing
``locking=false`` to e.g.  file.writer().  Some ``fileReader`` and ``fileWriter``
methods - in particular those beginning with the underscore - should only be
called on locked fileReaders or fileWriters.  With these methods, it is possible
to get or set the fileReader or fileWriter style, or perform I/O "transactions"
(see :proc:`fileWriter.mark`, e.g.). To use these methods, e.g., first lock the
fileWriter with :proc:`fileWriter.lock`, call the methods you need, then unlock
the fileWriter with :proc:`fileWriter.unlock`. Note that in the future, we may
move to alternative ways of calling these functions that guarantee that they
are not called on a fileReader or fileWriter without the appropriate locking.

Besides data races that can occur if locking is not used in fileWriters when it
should be, it is also possible for there to be data races on file data that is
buffered simultaneously in multiple fileReader/fileWriter combinations.  The
main way to avoid such data races is the :proc:`fileWriter.flush`
synchronization operation.  :proc:`fileWriter.flush` will make all writes to the
fileWriter, if any, available to concurrent viewers of its associated file, such
as other fileWriters, fileReaders or other applications accessing this file
concurrently. See the note below for more details on the situation in which this
kind of data race can occur.

.. note::

  Since fileWriters can buffer data until :proc:`fileWriter.flush` is called, it
  is possible to write programs that have undefined behavior because of race
  conditions on fileWriter buffers. In particular, the problem comes up for
  programs that make:

   * concurrent operations on multiple fileWriters and/or fileReaders that
     operate on overlapping regions of a file
   * where at least one fileWriter is used along with other fileWriters or
     fileReaders
   * and where data could be stored in more than one of the overlapping
     fileWriter's buffers at the same time (i.e., write and read ordering are
     not enforced through :proc:`fileWriter.flush` and other means such as
     sync variables).

  Note that it is possible in some cases to create a :record:`file` that does
  not allow multiple fileWriters and/or fileReaders at different
  offsets. FileWriters created on such files will not change the file's offset
  based on a ``start=`` offset arguments. Instead, each read or write operation
  will use the file descriptor's current offset. Therefore, only one
  fileWriter or fileReader should be created for files created in the following
  situations:

    * with the file initializer that takes a :type:`~CTypes.c_FILE` argument
    * with the file initializer that takes an ``int`` argument, where the
      ``int`` represents a non-seekable system file descriptor


Performing I/O with FileReaders and FileWriters
-----------------------------------------------

FileReaders have a variety of read methods and fileWriters have a variety of
write methods. The most common variety of these are generic methods that can
read or write values of any type. For non-primitive types, the relevant
``readThis`` or ``writeThis`` method is used to control the I/O formatting; see
:ref:`readThis-writeThis`. These functions generally take any number of
arguments and `throw` if there was an error:

 * :proc:`fileWriter.write`
 * :proc:`fileWriter.writeln`
 * :proc:`FormattedIO.fileWriter.writef` (see also :ref:`about-io-formatted-io`)
 * :proc:`fileReader.read`
 * :proc:`fileReader.readln`
 * :proc:`FormattedIO.fileReader.readf` (see also :ref:`about-io-formatted-io`)

The ``fileWriter`` type also has the following methods for executing write
operations with more specific types. These methods can provide finer control
over the ``fileWriter``'s behavior as well as some performance advantages over
the generic `write` methods:

 * :proc:`fileWriter.writeBits`
 * :proc:`fileWriter.writeCodepoint`
 * :proc:`fileWriter.writeByte`
 * :proc:`fileWriter.writeString`
 * :proc:`fileWriter.writeBytes`
 * :proc:`fileWriter.writeBinary`

The ``fileReader`` type has similar methods for executing read operations with
more specific types, where the goal of these methods is also to provide finer
control over the ``fileReader``'s behavior and the potential for performance
advantages:

 * :proc:`fileReader.readBits`
 * :proc:`fileReader.readCodepoint`
 * :proc:`fileReader.readByte`
 * :proc:`fileReader.readString`
 * :proc:`fileReader.readBytes`
 * :proc:`fileReader.readBinary`

Additionally, the ``fileReader`` has the following methods which read arbitrary
amounts of data from the file until some stop condition is met. These methods
generally have multiple overloads for reading into values of different types:

 * :proc:`fileReader.readLine`
 * :proc:`fileReader.lines`
 * :proc:`fileReader.readThrough`
 * :proc:`fileReader.readTo`
 * :proc:`fileReader.readAll`

Sometimes it's important to flush the buffer in a fileWriter - to do that, use
the :proc:`fileWriter.flush()` method. Flushing the buffer will make all writes
available to other applications or other views of the file (e.g., it will call
the OS call ``pwrite()``).  It is also possible to close a fileWriter, which
will implicitly flush it and release any buffer memory used by the fileWriter.
Note that if you need to ensure that data from a fileWriter is on disk, you'll
have to call :proc:`fileWriter.flush` or :proc:`fileWriter.close` and then
:proc:`file.fsync` on the related file.

.. _about-io-closing-filereader-filewriter:

Functions for Closing FileReaders and FileWriters
-------------------------------------------------

A fileReader or fileWriter must be closed in order to free the resources
allocated for it, to ensure that data written to it is visible to other
fileReaders, or to allow the associated file to be closed.

See :proc:`fileReader.close` and :proc:`fileWriter.close`.

It is an error to perform any I/O operations on a fileReader or fileWriter
that has been closed.
It is an error to close a file when it has fileReaders and/or fileWriters that
have not been closed.

Files, fileReaders and fileWriters are reference counted. Each file, fileReader
and fileWriter is closed automatically when no references to it remain. For
example, if a local variable is the only reference to a fileReader, the
fileReader will be closed when that variable goes out of scope.  Programs may
also close a file, fileReader or fileWriter explicitly.

.. _stdin-stdout-stderr:

The ``stdin`` fileReader, and ``stdout`` and ``stderr`` fileWriters
-------------------------------------------------------------------

Chapel provides the predefined fileReader :var:`stdin`, and the predefined
fileWriters :var:`stdout`, and :var:`stderr` to access the corresponding
operating system streams standard input, standard output, and standard error.

:var:`stdin` supports reading;
:var:`stdout` and :var:`stderr` support writing.

All three are safe to use concurrently.
Their types' ``kind`` argument is ``dynamic``.

.. _about-io-error-handling:

Error Handling
--------------

Most I/O routines throw a :class:`~OS.SystemError`, which can be handled
appropriately with ``try`` and ``catch`` (see the
:ref:`documentation<Complete_handling>` for more detail).

Additionally, some subclasses of :class:`~Errors.Error` are commonly used within
the I/O implementation. These are:

 * :class:`OS.EofError` - the end of file was reached
 * :class:`OS.UnexpectedEofError` - a read or write only returned part of the requested data
 * :class:`OS.BadFormatError` - data read did not adhere to the requested format

.. _io-general-sys-error:

**System Errors:**

For other error cases, a general :class:`~OS.SystemError` is typically thrown.
These errors are often produced by less predictable circumstances that are
more challenging to recover from. For example, a :record:`fileReader` could run
out of memory when attempting to allocate more buffer space.

As such, it is typically recommended that more specific errors are caught and
recovered from separately from a ``SystemError``. See the following example:

.. code-block:: chapel

  const r = openReader("test.txt");

  try {
    var i = r.read(int);
    // ...
  } catch e: EofError {
    writeln("r is at EOF");
    // we're done reading

  } catch e: UnexpectedEofError {
    writeln("unable to read an 'int'");
    // try to read something else? ...

  } catch e: SystemError {
    writeln("system error in IO implementation: ", e);
    // try to recover from the error? ...

  } catch e: Error {
    writeln("something else went wrong...");
  }


.. _io-transactions:

I/O Transactions
----------------

An *I/O transaction* is a common pattern afforded by the IO interface that
provides the ability to temporarily hold a particular region of a file in a
:record:`fileReader` or :record:`fileWriter`'s buffer. This allows I/O
operations within that region of the file to easily be undone in the event
of some unexpected data or other errors.

To support *I/O transactions*, each ``fileReader`` and ``fileWriter`` is fitted
with a *mark stack* which contains a series of file offsets. The region of the
file between the minimum and maximum offset on the *mark stack* will always be
retained in the buffer.

The steps of a typical *I/O transaction* are as follows:

* ``mark`` the current file offset with :proc:`fileReader.mark` or
  :proc:`fileWriter.mark`. This pushes the current offset onto the *mark stack*
* do a speculative I/O operation:
    * reading example: read 200 bytes followed by a `b`.
    * writing example: write 200 bytes without exceeding the ``fileWriter``'s region.
* if the operation fails, ``revert`` the operation by calling :proc:`fileReader.revert`
  or :proc:`fileWriter.revert`. Subsequent operations will continue from the
  originally marked offset as if nothing happened.
* if the operation is successful, call :proc:`fileReader.commit` or
  :proc:`fileWriter.commit` to pop the value from the *mark stack* and continue
  performing I/O operations from the current offset.

Note that when the mark stack is emptied, a ``fileWriter`` is allowed to flush
any portion of its buffer to its file and a ``fileReader`` is allowed to discard
any portion of its buffer.

See the following example of a simple I/O transaction:

.. code-block:: chapel

  use IO;

  var fr = openReader("file.txt");

  // mark the current channel position
  fr.mark();

  // read an array of bytes
  var a: [0..<200] uint(8);
  fr.read(a);

  // try to match a pattern
  if fr.matchLiteral("b") {
    fr.commit(); // "b" was found, continue reading from the current offset
  } else {
    fr.revert(); // "b" was't found, revert back to the marked position

    // try to read something else from the file, throw an error, etc.
  }

.. _filereader-filewriter-regions:

Specifying the region of a FileReader or FileWriter
---------------------------------------------------

The :record:`fileReader` and :record:`fileWriter` types can be configured to
own a specific *region* of their associated file.

When a ``fileReader`` or ``fileWriter`` is initialized using one of the
following routines, the optional ``region`` argument can be set to designate
some region of the file (a zero-based :ref:`range<Chapter-Ranges>` of integers
in bytes) that can be read from or written to:

* :proc:`file.reader`
* :proc:`file.writer`
* :proc:`openReader`

I/O operations that fall outside of the *region* are illegal. The ``region``
argument defaults to ``0..``, meaning that the owned region starts at the 0th
byte, and extends indefinitely.

Note that :proc:`fileReader.seek` and :proc:`fileWriter.seek` can be used to
adjust a ``fileReader`` or ``fileWriter``'s region after initialization.

Creating a ``fileReader`` or ``fileWriter`` that points to a sub-region of
a file can be useful for concurrently reading from or writing to multiple
portions of a file from separate tasks. See the following example, which
uses multiple tasks to concurrently read bytes from a binary file into an
array of bytes:

.. code-block:: chapel

  use IO;

  // the number of tasks to use
  config const nWorkers = 8;

  // open a (large) binary file
  var f = open("file.dat", ioMode.r);

  // compute how many bytes each worker will read
  const nBytes = f.size,
        nPerLoc = nBytes/ nWorkers;

  // create an array to hold the file contents
  var a: [0..<nBytes] uint(8);

  // concurrently read each worker's region into 'a'
  coforall w in 0..<nWorkers {
    const myRegion = (w*nPerLoc)..<((w+1) * nPerLoc),
          fr = f.reader(region=myRegion, locking=false);

    fr.readBinary(a[myRegion]);
  }


.. _locking-filereaders-and-filewriters:

Locking Behavior of FileReaders and FileWriters
-----------------------------------------------

The :record:`fileReader` and :record:`fileWriter` types can be configured to
lock access to their file when executing I/O operations to avoid race conditions
with other ``fileReader`` or ``fileWriter`` instances that may be accessing the
same file.

The ``locking`` field is a ``param`` and is thus part of the ``fileReader``
and ``fileWriter`` type. As such, it is possible to use type constraints to
designate whether a reader or writer is locking. For example this could be
useful in a procedure that relies on a ``reader`` argument being locking:

.. code-block:: chapel

  use IO;

  proc readSomething(reader: fileReader(locking=true, ?)) {
    // use 'reader' concurrently with another fileReader/fileWriter   ...
  }

By default, a ``fileReader`` or ``fileWriter`` will lock. A non-locking reader
or writer can be created by setting ``locking=false`` in one of the following
routines:

* :proc:`file.reader`
* :proc:`file.writer`
* :proc:`openReader`
* :proc:`openWriter`

With a locking ``fileReader`` or ``fileWriter``, one can obtain a lock manually
by calling :proc:`fileReader.lock` or :proc:`fileWriter.lock`, and then release a
lock by calling :proc:`fileReader.unlock` or :proc:`fileWriter.unlock`.

.. note::
  The following methods will not automatically acquire/release a lock for
  ``locking=true``:

  * :proc:`fileReader.mark`
  * :proc:`fileWriter.mark`
  * :proc:`fileReader.commit`
  * :proc:`fileWriter.commit`
  * :proc:`fileReader.revert`
  * :proc:`fileWriter.revert`
  * :proc:`fileReader.offset`
  * :proc:`fileWriter.offset`


.. _about-io-ensuring-successful-io:

Ensuring Successful I/O
-----------------------

It is possible - in some situations - for I/O to fail without returning an
error. In cases where a programmer wants to be sure that there was no error
writing the data to disk, it is important to call :proc:`file.fsync` to make
sure that data has arrived on disk without an error. Many errors can be
reported with a typical operation, but some errors can only be reported by the
system during :proc:`file.close` or even :proc:`file.fsync`.

When a file (or fileWriter) is closed, data written to that file will be written
to disk eventually by the operating system. If an application needs to be sure
that the data is immediately written to persistent storage, it should use
:proc:`file.fsync` prior to closing the file.

Correspondence with C I/O
-------------------------

It is not possible to seek, read, or write to a file directly; fileReaders
and/or fileWriters must be created and used.

:proc:`fileWriter.flush` in Chapel has the same conceptual meaning as
``fflush()`` in C.  However, ``fflush()`` is not necessarily called in
:proc:`fileWriter.flush()`, unlike ``fsync()``, which is actually called by
:proc:`file.fsync()` in Chapel.

IO Functions and Types
----------------------

 

.. enum:: enum ioMode { r = 1, cw = 2, rw = 3, cwr = 4, a = 5 }

   
   The :type:`ioMode` type is an enum. When used as arguments when opening files, its
   constants have the same meaning as the listed strings passed to ``fopen()`` in C.
   However, :proc:`open()` in Chapel does not necessarily invoke ``fopen()`` in C.

   .. enumconstant:: enum constant r = 1

      
      Open an existing file for reading.
      (``fopen()`` string is "r")
      

   .. enumconstant:: enum constant cw = 2

      
      Create a new file for writing.
      If the file already exists, its contents are truncated.
      (``fopen()`` string is "w")
      

   .. enumconstant:: enum constant rw = 3

      
      Open an existing file for reading and writing.
      (``fopen()`` string is "r+")
      

   .. enumconstant:: enum constant cwr = 4

      
      Same as :enumconstant:`ioMode.cw`, but reading from the file is also allowed.
      (``fopen()`` string is "w+")
      

   .. enumconstant:: enum constant a = 5

      .. warning::

         :enumconstant:`ioMode.a` is unstable and subject to change. It currently only supports one :record:`fileWriter` at a time.

      
      Open a file for appending, creating it if it does not exist.
      (``fopen()`` string is "a")
      

.. type:: type iokind = _iokind

   .. warning::

      'iokind' is deprecated, please use Serializers or Deserializers that support endianness instead

   
   
   The :type:`iokind` type is an enum. When used as arguments to the
   :record:`fileReader` or :record:`fileWriter` type, its constants have the
   following meaning:
   
   * ``iokind.dynamic`` means that the applicable I/O style has full effect
     and as a result the kind varies at runtime.
   
   * ``iokind.native`` means binary I/O in native byte order
     (similar to ``iokind.big`` but with the byte order that is native
     to the target platform).
   
   * ``iokind.big`` means binary I/O with big-endian byte order is performed
     when writing basic types to the fileWriter or reading basic types from the
     fileReader.
   
   * ``iokind.little`` means binary I/O with little-endian byte order
     (similar to ``iokind.big`` but with little-endian byte order).
   
   In the case of ``iokind.big``, ``iokind.little``, and
   ``iokind.native`` the applicable :record:`iostyle` is consulted when
   writing/reading strings, but not for other basic types.
   
   There are synonyms available for these values:
   
   * :proc:`iodynamic` = ``iokind.dynamic``
   * :proc:`ionative` = ``iokind.native``
   * :proc:`iobig` = ``iokind.big``
   * :proc:`iolittle` = ``iokind.little``
   

.. data:: param iodynamic = _iokind.dynamic

   .. warning::

      'iodynamic' is deprecated, please use Serializers or Deserializers that support endianness instead

   A synonym for ``iokind.dynamic``; see :type:`iokind` 

.. data:: param ionative = _iokind.native

   .. warning::

      'ionative' is deprecated, please use Serializers or Deserializers that support endianness instead

   A synonym for ``iokind.native``; see :type:`iokind` 

.. data:: param iobig = _iokind.big

   .. warning::

      'iobig' is deprecated, please use Serializers or Deserializers that support endianness instead

   A synonym for ``iokind.big``; see :type:`iokind` 

.. data:: param iolittle = _iokind.little

   .. warning::

      'iolittle' is deprecated, please use Serializers or Deserializers that support endianness instead

   A synonym for ``iokind.little``; see :type:`iokind` 

.. enum:: enum endianness { native = 0, big = 1, little = 2 }

   
   The :type:`endianness` type is an enum. When used as an argument to the
   :record:`fileReader` or :record:`fileWriter` methods, its constants have the
   following meanings:

   .. enumconstant:: enum constant native = 0

      ``native`` means binary I/O is performed in the byte order that is native
      to the target platform. 

   .. enumconstant:: enum constant big = 1

      ``big`` means binary I/O is performed in big-endian byte order.

   .. enumconstant:: enum constant little = 2

      ``little`` means binary I/O is performed in little-endian byte order. 

.. type:: type ioendian = endianness

   .. warning::

      :enum: ioendian is deprecated; please use :enum: endianness instead

.. enum:: enum iostringstyle { len1b_data = -1, len2b_data = -2, len4b_data = -4, len8b_data = -8, lenVb_data = -10, data_toeof = -0xff00, data_null = -0x0100 }

   .. warning::

      iostringstyle is deprecated, please use Serializers or Deserializers instead

   
   
   This enum contains values used to control binary I/O with strings
   via the ``str_style`` field in :record:`iostyle`.
   
   * ``iostringstyle.len1b_data`` indicates a string format of 1 byte of
     length followed by length bytes of string data.
   * ``iostringstyle.len2b_data`` indicates a string format of 2 bytes of
     length followed by length bytes of string data.
   * ``iostringstyle.len4b_data`` indicates a string format of 4 bytes of
     length followed by length bytes of string data.
   * ``iostringstyle.len8b_data`` indicates a string format of 8 bytes of
     length followed by length bytes of string data.
   * ``iostringstyle.lenVb_data`` indicates a string format of a variable
     number of bytes of length, encoded with high-bit meaning more bytes
     of length follow, and where the 7-bits of length from each byte store
     the 7-bit portions of the length in order from least-significant to
     most-significant. This way of encoding a variable-byte length  matches
     `Google Protocol Buffers <https://github.com/protocolbuffers/protobuf>`_.
   * ``iostringstyle.data_toeof`` indicates a string format that contains
     only the string data without any length or terminator. When reading,
     this format will read a string until the end of the file is reached.
   * ``iostringstyle.data_null`` indicates a string that is terminated
     by a zero byte. It can be combined with other numeric
     values to indicate a string terminated by a particular byte. For example,
     to indicate a string terminated by ``$`` (which in ASCII has byte value 0x24),
     one would use the value ``iostringstyle.data_null|0x24``.
   * A positive and nonzero value indicates that a string of exactly that many
     bytes should be read or written.
   

   .. enumconstant:: enum constant len1b_data = -1

   .. enumconstant:: enum constant len2b_data = -2

   .. enumconstant:: enum constant len4b_data = -4

   .. enumconstant:: enum constant len8b_data = -8

   .. enumconstant:: enum constant lenVb_data = -10

   .. enumconstant:: enum constant data_toeof = -0xff00

   .. enumconstant:: enum constant data_null = -0x0100

.. enum:: enum iostringformat { word = 0, basic = 1, chpl = 2, json = 3, toend = 4, toeof = 5 }

   .. warning::

      iostringformat is deprecated, please use Serializers or Deserializers instead

   
   
   This enum contains values used to control text I/O with strings
   via the ``string_format`` field in :record:`iostyle`.
   
     * ``iostringformat.word`` means string is as-is;
       reading reads until whitespace. This is the default.
     * ``iostringformat.basic`` means only escape *string_end* and ``\``
       with ``\``
     * ``iostringformat.chpl`` means  escape *string_end*
       ``\`` ``'`` ``"`` ``\n`` with ``\`` and
       nonprinting characters ``c = 0xXY`` with ``\xXY``
     * ``iostringformat.json`` means  escape *string_end* ``"`` and ``\``
       with ``\``, and nonprinting characters ``c = \uABCD``
     * ``iostringformat.toend`` means string is as-is; reading reads until
       *string_end*
     * ``iostringformat.toeof`` means string is as-is; reading reads until
       end of file

   .. enumconstant:: enum constant word = 0

   .. enumconstant:: enum constant basic = 1

   .. enumconstant:: enum constant chpl = 2

   .. enumconstant:: enum constant json = 3

   .. enumconstant:: enum constant toend = 4

   .. enumconstant:: enum constant toeof = 5

.. function:: proc stringStyleTerminated(terminator: uint(8))

   .. warning::

      stringStyleTerminated is deprecated following the deprecation of 'iostyle', please use Serializers or Deserializers instead

   
   
   This method returns the appropriate :record:`iostyle` ``str_style`` value
   to indicate a string format where strings are terminated by a
   particular byte.
   
   :arg terminator: a byte value that the strings will be terminated by
   :returns: a value that indicates a string format where strings
             are terminated by the terminator byte. This value is appropriate
             to store in iostyle.str_style.
   

.. function:: proc stringStyleNullTerminated()

   .. warning::

      stringStyleNullTerminated is deprecated following the deprecation of 'iostyle', please use Serializers or Deserializers instead

   
   This method returns the appropriate :record:`iostyle` ``str_style`` value
   to indicate a string format where strings are terminated by a
   zero byte.
   

.. function:: proc stringStyleWithLength(lengthBytes: int) throws

   .. warning::

      stringStyleWithLength is deprecated following the deprecation of 'iostyle', please use Serializers or Deserializers instead

   
   Return the appropriate :record:`iostyle` ``str_style`` value
   to indicate a string format where string data is preceded by a
   `lengthBytes` of length. Only lengths of 1, 2, 4, or 8 are supported.
   When `lengthBytes` is 0, the returned value indicates variable-byte length.
   
   :throws SystemError: Thrown for an unsupported value of `lengthBytes`.
   

.. type:: type iostyle = iostyleInternal

   .. warning::

      iostyle is deprecated; please use Serializers or Deserializers instead

.. function:: proc defaultIOStyle(): iostyle

   .. warning::

      defaultIOStyle is deprecated due to returning the deprecated type 'iostyle'

   
   :returns: the default I/O style. See :record:`iostyle`
             and :ref:`about-io-styles`
   
   

.. record:: ioHintSet

   A value of the :record:`ioHintSet` type defines a set of hints to provide
   information about the operations that a :record:`file`, :record:`fileReader`
   or :record:`fileWriter` will perform. These hints may be used by the
   implementation to select optimized versions of the I/O operations.
   
   Most hints have POSIX equivalents associated with posix_fadvise() and
   posix_madvise().
   
   This example depicts how an ``ioHintSet`` might be used.
   
   .. code-block:: chapel
   
     use IO;
   
     // define a set of hints using a union operation
     var hints = ioHintSet.sequential | ioHintSet.prefetch;
   
     // open a file using the hints
     var f: file;
     try! {
       f = open("path/to/my/file.txt", ioMode.r, hints=hints);
     }

   .. method:: proc type empty

      Defines an empty set, which provides no hints.
      Corresponds to 'POSIX_*_NORMAL'.
      

   .. method:: proc type sequential

      Suggests that the file will be accessed sequentially.
      Corresponds to 'POSIX_*_SEQUENTIAL'
      

   .. method:: proc type random

      Suggests that the file will be accessed randomly.
      Corresponds to 'POSIX_*_RANDOM'.
      

   .. method:: proc type prefetch

      Suggests that the runtime/OS should immediately begin prefetching the file contents.
      Corresponds to 'POSIX_*_WILLNEED'.
      

   .. method:: proc type mmap(useMmap = true)

      
      Suggests whether or not 'mmap' should be used to access the file contents.
      
       * when ``useMmap`` is ``true``, suggests that 'mmap' should be used
       * when ``useMmap`` is ``false``, suggests that 'mmap' should not be used and 'pread'/'pwrite' should be used instead
      
      

   .. method:: proc type noMmap

      .. warning::

         `ioHintSet.noMmap` is deprecated; please use `ioHintSet.mmap(false)` instead

      Suggests that 'mmap' should not be used to access the file contents.
      Instead, pread/pwrite are used.
      

.. method:: operator ioHintSet.|(lhs: ioHintSet, rhs: ioHintSet)

   Compute the union of two hint sets

.. method:: operator ioHintSet.&(lhs: ioHintSet, rhs: ioHintSet)

   Compute the intersection of two hint sets

.. method:: operator ioHintSet.==(lhs: ioHintSet, rhs: ioHintSet)

   Compare two hint sets for equality

.. method:: operator ioHintSet.!=(lhs: ioHintSet, rhs: ioHintSet)

   Compare two hint sets for inequality

.. record:: file

   
   The :record:`file` type is implementation-defined.  A value of the
   :record:`file` type refers to the state that is used by the implementation to
   identify and interact with the OS file.
   
   When a :record:`file` formal argument has default intent, the actual is passed
   by ``const ref`` to the formal upon a function call, and the formal
   cannot be assigned within the function.
   
   The default value of the :record:`file` type does not represent any OS file.
   It is illegal to perform any I/O operations on the default value.
   

.. method:: proc file.init(fp: c_ptr(c_FILE), hints = ioHintSet.empty, style: iostyle, own = false) throws

   .. warning::

      initializing a file with a 'style' argument is deprecated

.. method:: proc file.init(fp: c_ptr(c_FILE), hints = ioHintSet.empty, own = false) throws

   
   Create a Chapel :record:`file` that wraps around an open C file. A pointer to
   a C ``FILE`` object can be obtained via Chapel's
   :ref:`C Interoperability <primers-C-interop-using-C>` functionality.
   
   .. note::
   
     This is an alternative way to create a :record:`file`.  The main way to do so
     is via the :proc:`open` function.
   
   Once the Chapel file is created, you will need to use a :proc:`file.reader` to
   create a fileReader or :proc:`file.writer` to create a fileWriter to perform I/O
   operations on the C file.
   
   .. note::
   
     The resulting file value should only be used with one :record:`fileReader` or
     :record:`fileWriter` at a time. The I/O system will ignore the offsets when
     reading or writing to a file opened using this initializer.
   
   
   :arg fp: a pointer to a C ``FILE``. See :type:`~CTypes.c_FILE`.
   :arg hints: optional argument to specify any hints to the I/O system about
               this file. See :record:`ioHintSet`.
   :arg own: set to indicate if the :type:`~CTypes.c_FILE` provided should be
             cleaned up when the ``file`` is closed.  Defaults to ``false``
   
   :throws SystemError: Thrown if the C file could not be retrieved.

.. method:: proc file.init(fileDescriptor: int, hints = ioHintSet.empty, style: iostyle, own = false) throws

   .. warning::

      initializing a file with a 'style' argument is deprecated

.. method:: proc file.init(fileDescriptor: int, hints = ioHintSet.empty, own = false) throws

   
   
   Create a Chapel file that works with a system file descriptor.  Note that once
   the file is open, you will need to use a :proc:`file.reader` to create a
   fileReader or :proc:`file.writer` to create a fileWriter to actually perform I/O
   operations
   
   .. note::
   
     This is an alternative way to create a :record:`file`.  The main way to do so
     is via the :proc:`open` function.
   
   The system file descriptor will be closed when the Chapel file is closed.
   
   .. note::
   
     This function can be used to create Chapel files that refer to system file
     descriptors that do not support the ``seek`` functionality. For example, file
     descriptors that represent pipes or open socket connections have this
     property. In that case, the resulting file value should only be used with one
     :record:`fileReader` or :record:`fileWriter` at a time.  The I/O system will
     ignore the fileReader offsets when reading (or the fileWriter offsets when
     writing) to files backed by non-seekable file descriptors.
   
   
   :arg fileDescriptor: a system file descriptor.
   :arg hints: optional argument to specify any hints to the I/O system about
               this file. See :record:`ioHintSet`.
   :arg own: set to indicate if the `fileDescriptor` provided should be cleaned up
             when the ``file`` is closed.  Defaults to ``false``
   
   :throws SystemError: Thrown if the file descriptor could not be retrieved.

.. method:: proc file.isOpen(): bool

   Indicates if the file is currently open.  Will return ``false`` for both
   closed and invalid files

.. method:: proc file.close() throws

   Close a file.
   
   In order to free the resources allocated for a file, it
   must be closed using this method.
   
   Closing a file does not guarantee immediate persistence of the performed
   updates, if any. In cases where immediate persistence is important,
   :proc:`file.fsync` should be used for that purpose prior to closing the file.
   In particular, even though closing the file might complete without errors,
   the data written might not persist in the event of a severe error like
   running out of storage space or power loss. See also
   :ref:`about-io-ensuring-successful-io`.
   
   Files are automatically closed when the file variable goes out of scope and
   all fileReaders and fileWriters using that file are closed. Programs may also
   explicitly close a file using this method.
   
   It is an error to perform any I/O operations on a file that has been closed.
   It is an error to close a file when it has fileReaders and/or fileWriters
   that have not been closed.
   
   :throws SystemError: Thrown if the file could not be closed.
   

.. method:: proc file.fsync() throws

   
   
   Sync a file to disk.
   
   Commits file data to the device associated with this file.
   Data written to the file by a fileWriter will only be guaranteed
   committed if the fileWriter has been closed or flushed.
   
   This function will typically call the ``fsync`` system call.
   
   :throws SystemError: Thrown if the file could not be synced.
    

.. method:: proc file.path: string throws

   
   
   Get the absolute path to an open file.
   
   Note that not all files have a path (e.g. files opened with :proc:`openMemFile`),
   and that this procedure may not work on all operating systems.
   
   The function :proc:`Path.realPath` is an alternative way
   to get the path to a file.
   
   :returns: the absolute path to the file
   :rtype: ``string``
   
   :throws SystemError: Thrown if the path could not be retrieved.
    

.. method:: proc file.size: int throws

   
   
   Get the current size of an open file. Note that the size can always
   change if other fileWriters, tasks or programs are writing to the file.
   
   :returns: the current file size
   
   :throws SystemError: Thrown if the size could not be retrieved.

.. function:: proc open(path: string, mode: ioMode, hints = ioHintSet.empty): file throws

   
   
   Open a file on a filesystem. Note that once the file is open, you will need to
   use a :proc:`file.reader` to create a fileReader or :proc:`file.writer` to
   create a fileWriter to actually perform I/O operations
   
   :arg path: which file to open (for example, "some/file.txt").
   :arg mode: specify whether to open the file for reading or writing and
                whether or not to create the file if it doesn't exist.
                See :type:`ioMode`.
   :arg hints: optional argument to specify any hints to the I/O system about
               this file. See :record:`ioHintSet`.
   :returns: an open file to the requested resource.
   
   :throws FileNotFoundError: Thrown if part of the provided path did not exist
   :throws PermissionError: Thrown if part of the provided path had inappropriate
                            permissions
   :throws NotADirectoryError: Thrown if part of the provided path was expected to
                               be a directory but was not
   :throws SystemError: Thrown if the file could not be opened.

.. function:: proc open(path: string, mode: ioMode, hints = ioHintSet.empty, style: iostyle): file throws

   .. warning::

      open with a 'style' argument is deprecated

.. function:: proc openTempFile(hints = ioHintSet.empty, style: iostyle): file throws

   .. warning::

      openTempFile with a 'style' argument is deprecated

.. function:: proc openTempFile(hints = ioHintSet.empty): file throws

   
   
   Open a temporary file. Note that once the file is open, you will need to use a
   :proc:`file.reader` to create a fileReader or :proc:`file.writer` to create a
   fileWriter to actually perform I/O operations.
   
   The temporary file will be created in an OS-dependent temporary directory,
   for example "/tmp" is the typical location. The temporary file will be
   deleted upon closing.
   
   Temporary files are opened with :type:`ioMode` ``ioMode.cwr``; that is, a new
   file is created that supports both writing and reading.  When possible, it may
   be opened using OS support for temporary files in order to make sure that a new
   file is created only for use by the current application.
   
   :arg hints: optional argument to specify any hints to the I/O system about
               this file. See :record:`ioHintSet`.
   :returns: an open temporary file.
   
   :throws SystemError: Thrown if the temporary file could not be opened.

.. function:: proc openMemFile(style: iostyle): file throws

   .. warning::

      openMemFile with a 'style' argument is deprecated

.. function:: proc openMemFile(): file throws

   
   
   Open a file that is backed by a buffer in memory that will not persist when the
   file is closed.  Note that once the file is open, you will need to use a
   :proc:`file.reader` to create a fileReader or :proc:`file.writer` to create a
   fileWriter to actually perform I/O operations.
   
   The resulting file supports both reading and writing.
   
   :returns: an open memory file.
   
   :throws SystemError: Thrown if the memory buffered file could not be opened.

.. record:: fileReader

   
   
   A ``fileReader`` supports sequential reading from an underlying :record:`file`
   object. It can buffer data. Read operations on it might return old data.
   
   The :record:`fileReader` type is implementation-defined.
   A value of the :record:`fileReader` type refers to the state that is used
   to implement the reading operations.
   
   When a :record:`fileReader` formal argument has default intent, the actual is
   passed by ``const ref`` to the formal upon a function call, and the formal
   cannot be assigned within the function.
   
   The default value of the :record:`fileReader` type is not associated
   with any file, and so cannot be used to perform I/O.
   
   The :record:`fileReader` type is generic.

   .. attribute:: param kind: iokind = iokind.dynamic

      .. warning::

         'fileReader.kind' is deprecated, please use Deserializers to configure endianness instead

      
      kind is an enum :type:`iokind` that allows narrowing
      this fileReader's I/O style for more efficient binary I/O.
      

   .. attribute:: param locking: bool

      
      locking is a boolean indicating whether it is safe to use this
      fileReader concurrently (when `true`).
      

   .. attribute:: type deserializerType = defaultSerializeType(false, kind)

      
      deserializerType indicates the type of the deserializer that this
      fileReader will use to deserialize data.
      

.. method:: proc fileReader.writing param: bool

   .. warning::

      'fileReader.writing' is deprecated and will be removed in a future release

   Returns a bool indicating whether the fileReader is used for writing.  It is
   always ``false`` 

.. method:: proc fileReader.deserializer ref: deserializerType

   
   Return a mutable reference to this fileReader's deserializer.

.. record:: fileWriter

   
   
   A ``fileWriter`` supports sequential writing to an underlying :record:`file`
   object. A ``fileWriter`` can buffer data. Write operations might not have an
   immediate effect. Use :proc:`fileWriter.flush` to control this buffering.
   
   The :record:`fileWriter` type is implementation-defined.
   A value of the :record:`fileWriter` type refers to the state that is used
   to implement the writing operations.
   
   When a :record:`fileWriter` formal argument has default intent, the actual is
   passed by ``const ref`` to the formal upon a function call, and the formal
   cannot be assigned within the function.
   
   The default value of the :record:`fileWriter` type is not associated with any
   file, and so cannot be used to perform I/O.
   
   The :record:`fileWriter` type is generic.

   .. attribute:: param kind: iokind = iokind.dynamic

      .. warning::

         'fileWriter.kind' is deprecated, please use Serializers to configure endianness instead

      
      kind is an enum :type:`iokind` that allows narrowing
      this fileWriter's I/O style for more efficient binary I/O.
      

   .. attribute:: param locking: bool

      
      locking is a boolean indicating whether it is safe to use this
      fileWriter concurrently (when `true`).
      

   .. attribute:: type serializerType = defaultSerializeType(true, kind)

      
      serializerType indicates the type of the serializer that this fileWriter
      will use to serialize data.
      

.. method:: proc fileWriter.writing param: bool

   .. warning::

      'fileWriter.writing' is deprecated and will be removed in a future release

   Returns a bool indicating whether the fileWriter is used for writing.  It is
   always ``true`` 

.. method:: proc fileWriter.serializer ref: serializerType

   
   Return a mutable reference to this fileWriter's serializer.

.. record:: defaultSerializer

   
   The default Serializer used by ``fileWriter``.
   
   See :ref:`the serializers technote<ioSerializers>` for a general overview
   of Serializers and their usage.
   
   Otherwise, please refer to the individual methods in this type for a
   description of the default IO format.

   .. method:: proc ref serializeValue(writer: fileWriter, const val: ?t): void throws

      
      Serialize ``val`` with ``writer``.
      
      Numeric values are serialized as though they were written with the format
      as ``%i`` for integers and ``%r`` for ``real`` numbers. Complex numbers are
      serialized as ``%z``. Please refer to :ref:`the section on Formatted
      IO<about-io-formatted-io>` for more information.
      
      Booleans are serialized as the literal strings ``true`` or ``false``.
      
      ``string`` values are serialized using the same format as ``%s``  that is,
      literally and without quotes. ``bytes`` values are also serialized
      literally without extra formatting.
      
      Enums are serialized using the name of the corresponding value. For example
      with an enum like ``enum colors {red, green blue}``, the value ``red``
      would simply be serialized as ``red``.
      
      The ``nil`` value and nilable class variables storing ``nil`` will be
      serialized as the text ``nil``.
      
      Classes and records will have their ``serialize`` method invoked, passing
      in ``writer`` and this Serializer as arguments. Please see the
      :ref:`serializers technote<ioSerializers>` for more.
      
      Classes and records are expected to implement the ``writeSerializable``
      or ``serializable`` interface.
      
      :arg writer: The ``fileWriter`` used to write serialized output.
      :arg val: The value to be serialized.
      

   .. method:: proc startClass(writer: fileWriter, name: string, size: int) throws

      
      Start serializing a class by writing the character ``{``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg name: The name of the class type.
      :arg size: The number of fields in the class.
      
      :returns: A new :type:`AggregateSerializer`
      

   .. method:: proc startRecord(writer: fileWriter, name: string, size: int) throws

      
      Start serializing a record by writing the character ``(``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg name: The name of the record type.
      :arg size: The number of fields in the record.
      
      :returns: A new AggregateSerializer
      

   .. record:: AggregateSerializer

      
      Returned by ``startClass`` or ``startRecord`` to provide the API for
      serializing classes or records.
      
      A ``class`` with integer fields 'x' and 'y' with values '0' and '5' would
      be serialized as:
      
      .. code-block:: text
      
        {x = 0, y = 5}
      
      A ``record`` with matching fields would be serialized in the same way, but
      would use ``(`` and ``)`` instead of ``{`` and ``}``.
      

      .. method:: proc ref writeField(name: string, const field: ?) throws

      
      Serialize ``field`` named ``name``.
      
      Serializes fields in the form '<name> = <field>'. Adds a comma before the
      name if this is not the first field.
      

      .. method:: proc ref startClass(writer: fileWriter, name: string, size: int) throws

      
      Start serializing a nested class inside the current class. In this format
      inheritance is not represented and parent fields are printed before child
      fields. For example, the following classes with values
      ``x=5`` and ``y=2.0``:
      
      .. code-block:: chapel
      
        class Parent {
          var x : int;
        }
      
        class Child: Parent {
          var y : real;
        }
      
      would be serialized as:
      
      .. code-block:: text
      
        {x = 5, y = 2.0}
      
      :arg writer: The ``fileWriter`` to be used when serializing. Must match
        the writer used to create current AggregateSerializer.
      :arg name: The name of the class type.
      :arg size: The number of fields in the class.
      
      :returns: A new AggregateSerializer
      

      .. method:: proc endClass() throws

      
      Ends serialization of the current class by writing the character ``}``
      
      .. note:: It is an error to call methods on an AggregateSerializer after
                invoking 'endClass'.
      

      .. method:: proc endRecord() throws

      
      Ends serialization of the current record by writing the character ``)``
      
      .. note:: It is an error to call methods on an AggregateSerializer after
                invoking 'endRecord'.
      

   .. method:: proc startTuple(writer: fileWriter, size: int) throws

      
      Start serializing a tuple by writing the character ``(``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of elements in the tuple.
      
      :returns: A new TupleSerializer
      

   .. record:: TupleSerializer

      
      Returned by ``startTuple`` to provide the API for serializing tuples.
      
      A tuple will be serialized as a comma-separated list between two
      parentheses. For example, the tuple literal ``(1, 2, 3)`` would be
      serialized as:
      
      .. code-block::
      
        (1, 2, 3)
      
      A 1-tuple will be serialized with a trailing comma. For example, the literal
      ``(4,)`` would be serialized as ``(4,)``.
      
      

      .. method:: proc ref writeElement(const element: ?) throws

      
      Serialize ``element``.
      
      Writes a leading comma before serializing the element if this is not the
      first element in the tuple.
      

      .. method:: proc endTuple() throws

      
      Ends serialization of the current tuple by writing the character ``)``.
      
      Adds a comma between the last value and ``)`` if there was only one
      element.
      

   .. method:: proc startList(writer: fileWriter, size: int) throws

      
      Start serializing a list by writing the character ``[``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of elements in the list.
      
      :returns: A new ListSerializer
      

   .. record:: ListSerializer

      
      Returned by ``startList`` to provide the API for serializing lists.
      
      A list will be serialized as a comma-separated series of serialized
      elements between two square brackets. For example, serializing a list
      with elements ``1``, ``2``, and ``3`` will produce the text:
      
      .. code-block:: text
      
        [1, 2, 3]
      
      Empty lists will be serialized as ``[]``.
      

      .. method:: proc ref writeElement(const element: ?) throws

      
      Serialize ``element``.
      
      Writes a leading comma before serializing the element if this is not the
      first element in the list.
      

      .. method:: proc endList() throws

      
      Ends serialization of the current list by writing the character ``]``.
      

   .. method:: proc startArray(writer: fileWriter, size: int) throws

      
      Start serializing an array.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of elements in the array.
      
      :returns: A new ArraySerializer
      

   .. record:: ArraySerializer

      
      Returned by ``startArray`` to provide the API for serializing arrays.
      
      In the default format, an array will be serialized as a
      whitespace-separated series of serialized elements.
      
      A 1D array is serialized simply using spaces:
      
      ::
      
        1 2 3 4
      
      A 2D array is serialized using spaces between elements in a row, and
      prints newlines for new rows:
      
      ::
      
        1 2 3
        4 5 6
        7 8 9
      
      Arrays with three or more dimensions will be serialized as a series of
      2D "panes", with multiple newlines separating new dimensions:
      
      ::
      
        1 2 3
        4 5 6
        7 8 9
      
        10 11 12
        13 14 15
        16 17 18
      
        19 20 21
        22 23 24
        25 26 27
      
      Empty arrays result in no output to the ``fileWriter``.
      

      .. method:: proc ref startDim(size: int) throws

      
      Inform the ``ArraySerializer`` to start serializing a new dimension of
      size ``size``.
      

      .. method:: proc ref endDim() throws

      
      End the current dimension.
      

      .. method:: proc ref writeElement(const element: ?) throws

      
      Serialize ``element``.
      
      Adds a space if this is not the first element in the row.
      

      .. method:: proc endArray() throws

      
      Ends serialization of the current array.
      

   .. method:: proc startMap(writer: fileWriter, size: int) throws

      
      Start serializing a map by writing the character ``{``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of entries in the map.
      
      :returns: A new MapSerializer
      

   .. record:: MapSerializer

      
      Returned by ``startMap`` to provide the API for serializing maps.
      
      Maps are serialized as a comma-separated series of pairs between curly
      braces. Pairs are serialized with a ``:`` separating the key and value. For
      example, the keys ``1``, ``2``, and ``3`` with values corresponding to
      their squares would be serialized as:
      
      ::
      
        {1: 1, 2: 4, 3: 9}
      
      Empty maps will be serialized as ``{}``.
      

      .. method:: proc ref writeKey(const key: ?) throws

      
      Serialize ``key``.
      
      Adds a leading comma if this is not the first pair in the map.
      

      .. method:: proc writeValue(const val: ?) throws

      
      Serialize ``val``, preceded by the character ``:``.
      

      .. method:: proc endMap() throws

      
      Ends serialization of the current map by writing the character ``}``
      

.. type:: type DefaultSerializer = defaultSerializer

   .. warning::

      'DefaultSerializer' is deprecated; please use 'defaultSerializer' instead

.. record:: defaultDeserializer

   
   The default Deserializer used by ``fileReader``.
   
   See :ref:`the serializers technote<ioSerializers>` for a general overview
   of Deserializers and their usage.
   
   Otherwise, please refer to :type:`defaultSerializer` for a description
   of the default IO format. Individual methods on this type may clarify
   behavior specific to deserialization.
   
   .. note::
   
     Prior to the 1.32 release and the advent of the 'serializers' feature, the
     default implementation for reading classes and records permitted reading
     fields out of order. This functionality is not supported by the
     ``defaultDeserializer``.
   
     For an unspecified amount of time this module will retain the ability to
     disable automatic use of the ``defaultDeserializer`` by recompiling
     programs with the config-param ``useIOSerializers`` set to ``false``.
   
     Eventually, however, users must update their programs to account for
     reading fields out of order.

   .. method:: proc ref deserializeType(reader: fileReader, type readType): readType throws

      
      Deserialize type ``readType`` with ``reader``.
      
      Classes and records will be deserialized using an appropriate initializer,
      passing in ``reader`` and this Deserializer as arguments. If an
      initializer is unavailable, this method may invoke the class or record's
      ``deserialize`` method. Please see the :ref:`serializers technote<ioSerializers>` for more.
      
      Classes and records are expected to implement either the
      ``initDeserializable`` or ``readDeserializable`` interfaces (or both).
      Alternatively, types implementing the entire ``serializable`` interface
      are also accepted.
      
      :arg reader: The ``fileReader`` from which types are deserialized.
      :arg readType: The type to be deserialized.
      
      :returns: A value of type ``readType``.
      

   .. method:: proc ref deserializeValue(reader: fileReader, ref val: ?readType): void throws

      
      Deserialize from ``reader`` directly into ``val``.
      
      Like :proc:`deserializeType`, but reads into an initialized value rather
      than creating a new value. For classes and records, this method will first
      attempt to invoke a ``deserialize`` method. If the ``deserialize`` method
      is unavailable, this method may fall back on invoking a suitable
      initializer and assigning the resulting value into ``val``.. Please see the
      :ref:`serializers technote<ioSerializers>` for more.
      
      Classes and records are expected to implement either the
      ``initDeserializable`` or ``readDeserializable`` interfaces (or both).
      Alternatively, types implementing the entire ``serializable`` interface
      are also accepted.
      
      :arg reader: The ``fileReader`` from which values are deserialized.
      :arg val: The value into which this Deserializer will deserialize.
      

   .. method:: proc startClass(reader: fileReader, name: string) throws

      
      Start deserializing a class by reading the character ``{``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      :arg name: The name of the class type
      
      :returns: A new :type:`AggregateDeserializer`
      

   .. method:: proc startRecord(reader: fileReader, name: string) throws

      
      Start deserializing a record by reading the character ``(``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      :arg name: The name of the record type
      
      :returns: A new :type:`AggregateDeserializer`
      

   .. record:: AggregateDeserializer

      
      Returned by ``startClass`` or ``startRecord`` to provide the API for
      deserializing classes or records.
      
      See :type:`~IO.defaultSerializer.AggregateSerializer` for details of the
      default format for classes and records.
      

      .. method:: proc readField(name: string, type fieldType): fieldType throws

      
      Deserialize a field named ``name`` of type ``fieldType``.
      
      :returns: A deserialized value of type ``fieldType``.
      

      .. method:: proc readField(name: string, ref field) throws

      
      Deserialize a field named ``name`` in-place.
      

      .. method:: proc startClass(reader: fileReader, name: string) throws

      
      Start deserializing a nested class inside the current class.
      
      See ``defaultSerializer.AggregateSerializer.startClass`` for details
      on inheritance on the default format.
      
      :returns: A new AggregateDeserializer
      

      .. method:: proc endClass() throws

      
      End deserialization of the current class by reading the character ``}``.
      

      .. method:: proc endRecord() throws

      
      End deserialization of the current record by reading the character ``)``.
      

   .. method:: proc startTuple(reader: fileReader) throws

      
      Start deserializing a tuple by reading the character ``(``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`TupleDeserializer`
      

   .. record:: TupleDeserializer

      
      Returned by ``startTuple`` to provide the API for deserializing tuples.
      
      See ``defaultSerializer.TupleSerializer`` for details of the default format
      for tuples.
      

      .. method:: proc readElement(type eltType): eltType throws

      
      Deserialize an element of the tuple.
      
      :returns: A deserialized value of type ``eltType``.
      

      .. method:: proc readElement(ref element) throws

      
      Deserialize ``element`` in-place as an element of the tuple.
      

      .. method:: proc endTuple() throws

      
      End deserialization of the current tuple by reading the character ``)``.
      

   .. method:: proc ref startList(reader: fileReader) throws

      
      Start deserializing a list by reading the character ``[``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`ListDeserializer`
      

   .. record:: ListDeserializer

      
      Returned by ``startList`` to provide the API for deserializing lists.
      
      See ``defaultSerializer.ListSerializer`` for details of the default format
      for lists.
      

      .. method:: proc ref readElement(type eltType): eltType throws

      
      Deserialize an element of the list.
      
      :returns: A deserialized value of type ``eltType``.
      

      .. method:: proc ref readElement(ref element) throws

      
      Deserialize ``element`` in-place as an element of the list.
      

      .. method:: proc endList() throws

      
      End deserialization of the current list by reading the character ``]``.
      

      .. method:: proc hasMore(): bool throws

      
      :returns: Returns ``true`` if there are more elements to read.
      

   .. method:: proc startArray(reader: fileReader) throws

      
      Start deserializing an array.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`ArrayDeserializer`
      

   .. record:: ArrayDeserializer

      
      Returned by ``startArray`` to provide the API for deserializing arrays.
      
      See ``defaultSerializer.ArraySerializer`` for details of the default format
      for arrays.
      

      .. method:: proc ref startDim() throws

      
      Inform the ``ArrayDeserializer`` to start deserializing a new dimension.
      

      .. method:: proc ref endDim() throws

      
      End deserialization of the current dimension.
      

      .. method:: proc ref readElement(type eltType): eltType throws

      
      Deserialize an element of the array.
      
      :returns: A deserialized value of type ``eltType``.
      

      .. method:: proc ref readElement(ref element) throws

      
      Deserialize ``element`` in-place as an element of the array.
      

      .. method:: proc endArray() throws

      
      End deserialization of the current array.
      

   .. method:: proc startMap(reader: fileReader) throws

      
      Start deserializing a map by reading the character ``{``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`MapDeserializer`
      

   .. record:: MapDeserializer

      
      Returned by ``startMap`` to provide the API for deserializing maps.
      
      See ``defaultSerializer.MapSerializer`` for details of the default
      format for map.
      

      .. method:: proc ref readKey(type keyType): keyType throws

      
      Deserialize and return a key of type ``keyType``.
      

      .. method:: proc ref readKey(ref key) throws

      
      Deserialize ``key`` in-place as a key of the map.
      

      .. method:: proc readValue(type valType): valType throws

      
      Deserialize and return a value of type ``valType``.
      

      .. method:: proc readValue(ref value) throws

      
      Deserialize ``value`` in-place as a value of the map.
      

      .. method:: proc endMap() throws

      
      End deserialization of the current map by reading the character ``}``.
      

      .. method:: proc hasMore(): bool throws

      
      :returns: Returns ``true`` if there are more elements to read.
      
      .. warning::
      
        Behavior of 'hasMore' is undefined when called between ``readKey`` and
        ``readValue``.
      

.. type:: type DefaultDeserializer = defaultDeserializer

   .. warning::

      'DefaultDeserializer' is deprecated; please use 'defaultDeserializer' instead

.. data:: config param warnBinaryStructured: bool = true

   .. warning::

      This config param is unstable and may be removed without advance notice

   
   This config param allows users to disable a warning for reading and writing
   classes and strings with ``binarySerializer`` and ``binaryDeserializer``
   following a format change in the 1.33 release.

.. record:: binarySerializer

   
   A binary Serializer that implements a simple binary format.
   
   This Serializer supports an ``endian`` field which may be configured at
   execution time.
   
   See :ref:`the serializers technote<ioSerializers>` for a general overview
   of Serializers and their usage.
   
   .. warning::
   
     In the 1.32 release this format included bytes representing the length of
     a string. Also, classes were serialized beginning with a single byte to
     indicate whether the class value was ``nil``. This behavior was changed
     in the subsequent release to provide users with a more flexible
     serializer that did not insert bytes that the user did not request. A
     compile-time warning will be issued to indicate that this behavior has
     changed. Users can recompile with ``-swarnBinaryStructured=false`` to
     silence the warning.
   
     To mimic the old behavior, please use the unstable
     :mod:`ObjectSerialization` module.

   .. attribute:: const endian: endianness = endianness.native

      
      'endian' represents the endianness of the binary output produced by this
      Serializer.
      

   .. method:: proc ref serializeValue(writer: fileWriter(serializerType = binarySerializer, locking = false, ?), const val: ?t) throws

      
      Serialize ``val`` with ``writer``.
      
      Numeric values like integers, real numbers, and complex numbers are
      serialized directly to the associated ``fileWriter`` as binary data in the
      specified endianness.
      
      Booleans are serialized as single byte unsigned values of either ``0`` or
      ``1``.
      
      ``string`` values are serialized as a raw sequence of bytes that does not
      include a null terminator, nor any bytes representing length. This means
      that ``string`` values cannot be deserialized without manual intervention
      by users to decide how their strings should be stored such that they can
      be deserialized.
      
      The ``nil`` value is serialized as a single unsigned byte of value ``0``.
      
      Classes and records will have their ``serialize`` method invoked, passing
      in ``writer`` and this Serializer as arguments. Please see the
      :ref:`serializers technote<ioSerializers>` for more on the ``serialize``
      method.
      
      Classes and records are expected to implement the ``writeSerializable``
      interface. The ``serializable`` interface is also acceptable.
      
      .. note::
      
        Serializing and deserializing enums is not stable in this format.
      
      :arg writer: The ``fileWriter`` used to write serialized output.
      :arg val: The value to be serialized.
      

   .. method:: proc startClass(writer: fileWriter(?), name: string, size: int) throws

      
      Start serializing a class and return a new ``AggregateSerializer``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg name: The name of the class type.
      :arg size: The number of fields in the class.
      
      :returns: A new :type:`AggregateSerializer`
      

   .. method:: proc startRecord(writer: fileWriter(?), name: string, size: int) throws

      
      Start serializing a record and return a new ``AggregateSerializer``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg name: The name of the record type.
      :arg size: The number of fields in the class.
      
      :returns: A new :type:`AggregateSerializer`
      

   .. record:: AggregateSerializer

      
      Returned by ``startClass`` or ``startRecord`` to provide the API for
      serializing classes or records.
      
      In this simple binary format, classes and records do not begin or end with
      any bytes indicating size, and instead serialize their field values in
      ``binarySerializer``'s format.
      
      For example, a record with two ``uint(8)`` fields with values ``1`` and
      ``2`` would be serialized as ``0x01`` followed by ``0x02`` (in raw binary).
      

      .. method:: proc writeField(name: string, const field: ?T) throws

      
      Serialize ``field`` in ``binarySerializer``'s format.
      

      .. method:: proc startClass(writer, name: string, size: int) throws

      
      Start serializing a nested class inside the current class. In this
      binary format, this has no impact on the serialized output.
      

      .. method:: proc endClass() throws

      
      End deserialization of this class.
      

      .. method:: proc endRecord() throws

      
      End deserialization of this record.
      

   .. method:: proc startTuple(writer: fileWriter(?), size: int) throws

      
      Start serializing a tuple and return a new ``TupleSerializer``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of elements in the tuple.
      
      :returns: A new TupleSerializer
      

   .. record:: TupleSerializer

      
      Returned by ``startTuple`` to provide the API for serializing tuples.
      
      In this simple binary format, tuples do not begin or end with any bytes
      indicating size, and instead serialize their elements sequentially in
      ``binarySerializer``'s format.
      

      .. method:: proc writeElement(const element: ?T) throws

      
      Serialize ``element`` in ``binarySerializer``'s format.
      

      .. method:: proc endTuple() throws

      
      Ends serialization of the current tuple.
      

   .. method:: proc startList(writer: fileWriter(?), size: int) throws

      
      Start serializing a list by serializing ``size``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of elements in the list.
      
      :returns: A new ListSerializer
      

   .. record:: ListSerializer

      
      Returned by ``startList`` to provide the API for serializing lists.
      
      In this simple binary format, lists begin with the serialization of an
      ``int`` representing the size of the list. This data is then followed by
      the binary serialization of the specified number of elements.
      

      .. method:: proc writeElement(const element: ?) throws

      
      Serialize ``element`` in ``binarySerializer``'s format.
      

      .. method:: proc endList() throws

      
      Ends serialization of  the current list.
      

   .. method:: proc startArray(writer: fileWriter(?), size: int) throws

      
      Start serializing an array and return a new ``ArraySerializer``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of elements in the array.
      
      :returns: A new ArraySerializer
      

   .. record:: ArraySerializer

      
      Returned by ``startArray`` to provide the API for serializing arrays.
      
      In this simple binary format, arrays are serialized element by element
      in the order indicated by the caller of ``writeElement``. Dimensions and
      the start or end of the array are not represented.
      

      .. method:: proc startDim(size: int) throws

      
      Start serializing a new dimension of the array.
      

      .. method:: proc endDim() throws

      
      Ends serialization of this dimension.
      

      .. method:: proc writeElement(const element: ?) throws

      
      Serialize ``element`` in ``binarySerializer``'s format.
      

      .. method:: proc writeBulkElements(data: c_ptr(?eltType), numElements: int) throws where isNumericType(eltType)

      
      Serialize ``numElements`` number of elements in ``data``, provided that
      the element type of ``data`` is a numeric type.
      
      This performance-motivated implementation of the optional
      ``writeBulkElements`` will write the elements of ``data`` in the order
      in which they are represented in memory.
      
      .. note::
      
        This method is only optimized for the case where the
        ``binarySerializer`` has been configured for ``native`` endianness.
      

      .. method:: proc endArray() throws

      
      Ends serialization of the current array.
      

   .. method:: proc startMap(writer: fileWriter(?), size: int) throws

      
      Start serializing a map by serializing ``size``.
      
      :arg writer: The ``fileWriter`` to be used when serializing.
      :arg size: The number of entries in the map.
      
      :returns: A new MapSerializer
      

   .. record:: MapSerializer

      
      Returned by ``startMap`` to provide the API for serializing maps.
      
      In this simple binary format, maps begin with the serialization of an
      ``int`` representing the size of the map. This data is then followed by the
      binary serialization of the specified number of key-value pairs. The binary
      serialization of a key-value pair has no structure, and simply consists of
      the serialization of the key followed by the serialization of the value.
      

      .. method:: proc writeKey(const key: ?) throws

      
      Serialize ``key`` in ``binarySerializer``'s format.
      

      .. method:: proc writeValue(const val: ?) throws

      
      Serialize ``val`` in ``binarySerializer``'s format.
      

      .. method:: proc endMap() throws

      
      Ends serialization of the current map.
      

.. type:: type BinarySerializer = binarySerializer

   .. warning::

      'BinarySerializer' is deprecated; please use 'binarySerializer' instead

.. record:: binaryDeserializer

   
   A binary Deserializer that implements a simple binary format.
   
   This Deserializer supports an ``endian`` field which may be configured at
   execution time.
   
   See :ref:`the serializers technote<ioSerializers>` for a general overview
   of Deserializers and their usage.
   
   Otherwise, please refer to :type:`binarySerializer` for a description of the
   binary format. Individual methods on this type may clarify relevant behavior
   specific to deserialization
   
   .. note::
   
     Deserializing ``string`` or ``bytes`` types will result in an
     IllegalArgumentError because these types cannot currently be deserialized
     with the raw nature of the format.
   
   .. warning::
   
     In the 1.32 release this format included bytes representing the length of
     a string. Also, classes were serialized beginning with a single byte to
     indicate whether the class value was ``nil``. This behavior was changed
     in the subsequent release to provide users with a more flexible
     deserializer that did not read bytes that the user did not request. A
     compile-time warning will be issued to indicate that this behavior has
     changed. Users can recompile with ``-swarnBinaryStructured=false`` to
     silence the warning.
   
     To mimic the old behavior, please use the unstable
     :mod:`ObjectSerialization` module.
   

   .. attribute:: const endian: IO.endianness = IO.endianness.native

      
      'endian' represents the endianness that this Deserializer should use when
      deserializing input.
      

   .. method:: proc ref deserializeType(reader: fileReader(?), type readType): readType throws

      
      Deserialize type ``readType`` with ``reader``.
      
      Classes and records will be deserialized using an appropriate initializer,
      passing in ``reader`` and this Deserializer as arguments. If an
      initializer is unavailable, this method may invoke the class or record's
      ``deserialize`` method. Please see the :ref:`serializers technote<ioSerializers>` for more.
      
      Classes and records are expected to implement either the
      ``initDeserializable`` or ``readDeserializable`` interfaces (or both). The
      ``serializable`` interface is also acceptable.
      
      :arg reader: The ``fileReader`` from which types are deserialized.
      :arg readType: The type to be deserialized.
      
      :returns: A value of type ``readType``.
      

   .. method:: proc ref deserializeValue(reader: fileReader(?), ref val: ?readType): void throws

      
      Deserialize from ``reader`` directly into ``val``.
      
      Like :proc:`deserializeType`, but reads into an initialized value rather
      than creating a new value. For classes and records, this method will first
      attempt to invoke a ``deserialize`` method. If the ``deserialize`` method
      is unavailable, this method may fall back on invoking a suitable
      initializer and assigning the resulting value into ``val``.. Please see the
      :ref:`serializers technote<ioSerializers>` for more.
      
      Classes and records are expected to implement either the
      ``readDeserializable`` or ``initDeserializable`` interfaces (or both). The
      ``serializable`` interface is also acceptable.
      
      :arg reader: The ``fileReader`` from which values are deserialized.
      :arg val: The value into which this Deserializer will deserialize.
      

   .. method:: proc startClass(reader: fileReader(?), name: string) throws

      
      Start deserializing a class by returning an ``AggregateDeserializer``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      :arg name: The name of the class type.
      
      :returns: A new :type:`AggregateDeserializer`
      

   .. method:: proc startRecord(reader: fileReader(?), name: string) throws

      
      Start deserializing a record by returning an ``AggregateDeserializer``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      :arg name: The name of the record type.
      
      :returns: A new :type:`AggregateDeserializer`
      

   .. record:: AggregateDeserializer

      
      Returned by ``startClass`` or ``startRecord`` to provide the API for
      deserializing classes or records.
      
      See ``binarySerializer.AggregateSerializer`` for details of the
      binary format for classes and records.
      

      .. method:: proc readField(name: string, type fieldType): fieldType throws

      
      Deserialize and return a value of type ``fieldType``.
      

      .. method:: proc readField(name: string, ref field) throws

      
      Deserialize ``field`` in-place.
      

      .. method:: proc startClass(reader, name: string) throws

      
      Start deserializing a nested class inside the current class.
      
      See ``binarySerializer.AggregateSerializer.startClass`` for details
      on inheritance on the binary format.
      
      :returns: A new AggregateDeserializer
      

      .. method:: proc endClass() throws

      
      End deserialization of the current class.
      

      .. method:: proc endRecord() throws

      
      End deserialization of the current record.
      

   .. method:: proc startTuple(reader: fileReader(?)) throws

      
      Start deserializing a tuple by returning a ``TupleDeserializer``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`TupleDeserializer`
      

   .. record:: TupleDeserializer

      
      Returned by ``startTuple`` to provide the API for deserializing tuples.
      
      See ``binarySerializer.TupleSerializer`` for details of the binary format
      for tuples.
      

      .. method:: proc readElement(type eltType): eltType throws

      
      Deserialize an element of the tuple.
      
      :returns: A deserialized value of type ``eltType``.
      

      .. method:: proc readElement(ref element) throws

      
      Deserialize ``element`` in-place as an element of the tuple.
      

      .. method:: proc endTuple() throws

      
      End deserialization of the current tuple.
      

   .. method:: proc startList(reader: fileReader(?)) throws

      
      Start deserializing a list by returning a ``ListDeserializer``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`ListDeserializer`
      

   .. record:: ListDeserializer

      
      Returned by ``startList`` to provide the API for deserializing lists.
      
      See ``binarySerializer.ListSerializer`` for details of the binary format
      for lists.
      

      .. method:: proc ref readElement(type eltType): eltType throws

      
      Deserialize an element of the list.
      
      :returns: A deserialized value of type ``eltType``.
      

      .. method:: proc ref readElement(ref element) throws

      
      Deserialize ``element`` in-place as an element of the list.
      

      .. method:: proc endList() throws

      
      End deserialization of the current list.
      
      :throws: A ``BadFormatError`` if there are remaining elements.
      

      .. method:: proc hasMore(): bool throws

      
      :returns: Returns ``true`` if there are more elements to read.
      

   .. method:: proc startArray(reader: fileReader(?)) throws

      
      Start deserializing an array by returning an ``ArrayDeserializer``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`ArrayDeserializer`
      

   .. record:: ArrayDeserializer

      
      Returned by ``startArray`` to provide the API for deserializing arrays.
      
      See ``binarySerializer.ArraySerializer`` for details of the binary format
      for arrays.
      

      .. method:: proc startDim() throws

      
      Inform the ``ArrayDeserializer`` to start deserializing a new dimension.
      

      .. method:: proc endDim() throws

      
      End deserialization of the current dimension.
      

      .. method:: proc readElement(type eltType): eltType throws

      
      Deserialize an element of the list.
      
      :returns: A deserialized value of type ``eltType``.
      

      .. method:: proc readElement(ref element) throws

      
      Deserialize ``element`` in-place as an element of the array.
      

      .. method:: proc readBulkElements(data: c_ptr(?eltType), numElements: int) throws where isNumericType(eltType)

      
      Deserialize ``numElements`` number of elements into ``data``, provided
      that the element type of ``data`` is a numeric type.
      
      This performance-motivated implementation of the optional
      ``readBulkElements`` will read the elements of ``data`` in the order in
      which they are represented in memory.
      
      .. note::
      
        This method is only optimized for the case where the
        ``binaryDeserializer`` has been configured for ``native`` endianness.
      

      .. method:: proc endArray() throws

      
      End deserialization of the current array.
      

   .. method:: proc startMap(reader: fileReader(?)) throws

      
      Start deserializing a map by returning a ``MapDeserializer``.
      
      :arg reader: The ``fileReader`` to use when deserializing.
      
      :returns: A new :type:`MapDeserializer`
      

   .. record:: MapDeserializer

      
      Returned by ``startMap`` to provide the API for deserializing maps.
      
      See ``binarySerializer.MapSerializer`` for details of the binary
      format for map.
      

      .. method:: proc ref readKey(type keyType): keyType throws

      
      Deserialize and return a key of type ``keyType``.
      

      .. method:: proc ref readKey(ref key) throws

      
      Deserialize ``key`` in-place as a key of the map.
      

      .. method:: proc readValue(type valType): valType throws

      
      Deserialize and return a value of type ``valType``.
      

      .. method:: proc readValue(ref value) throws

      
      Deserialize ``value`` in-place as a value of the map.
      

      .. method:: proc endMap() throws

      
      End deserialization of the current map.
      
      :throws: A ``BadFormatError`` if there are entries remaining.
      

      .. method:: proc hasMore(): bool throws

      
      :returns: Returns ``true`` if there are more elements to read.
      
      .. warning::
      
        Behavior of 'hasMore' is undefined when called between ``readKey`` and
        ``readValue``.
      

.. type:: type BinaryDeserializer = binaryDeserializer

   .. warning::

      'BinaryDeserializer' is deprecated; please use 'binaryDeserializer' instead

.. method:: proc fileReader.withDeserializer(type deserializerType): fileReader(this._kind, this.locking, deserializerType)

   
   Create and return an alias of this ``fileReader`` configured to use
   ``deserializerType`` for deserialization. The provided ``deserializerType``
   must be able to be default-initialized.
   
   .. warning::
   
     It is an error for the returned alias to outlive the original ``fileReader``.

.. method:: proc fileReader.withDeserializer(in deserializer: ?dt): fileReader(this._kind, this.locking, dt)

   
   Create and return an alias of this ``fileReader`` configured to use
   ``deserializer`` for deserialization.
   
   .. warning::
   
     It is an error for the returned alias to outlive the original ``fileReader``.

.. method:: proc fileWriter.withSerializer(type serializerType): fileWriter(this._kind, this.locking, serializerType)

   
   Create and return an alias of this ``fileWriter`` configured to use
   ``serializerType`` for serialization. The provided ``serializerType`` must be
   able to be default-initialized.
   
   .. warning::
   
     It is an error for the returned alias to outlive the original ``fileWriter``.

.. method:: proc fileWriter.withSerializer(in serializer: ?st): fileWriter(this._kind, this.locking, st)

   
   Create and return an alias of this ``fileWriter`` configured to use
   ``serializer`` for serialization.
   
   .. warning::
   
     It is an error for the returned alias to outlive the original ``fileWriter``.

.. type:: type ioNewline = chpl_ioNewline

   .. warning::

      :type:`ioNewline` is deprecated; please use :proc:`fileReader.readNewline`, :proc:`fileReader.matchNewline`, or :proc:`fileWriter.writeNewline` instead

   
   
   Represents a newline character or character sequence (ie ``\n``). I/O routines
   (such as :proc:`fileReader.read` and :proc:`fileWriter.write`) can use arguments
   of this type in order to read or write a newline. This is different from ``\n``
   because an ioNewline always produces an actual newline, but in some cases
   writing ``\n`` will produce an escaped string (such as ``"\n"``).
   
   When reading an ioNewline, read routines will skip any character sequence
   (including, e.g., letters and numbers) to get to the newline character unless
   ``skipWhitespaceOnly`` is set to true.
   
    

.. type:: type ioLiteral = chpl_ioLiteral

   .. warning::

      :type:`ioLiteral` is deprecated; please use :proc:`fileReader.readLiteral`, :proc:`fileReader.matchLiteral`, or :proc:`fileWriter.writeLiteral` instead

   
   
   Used to represent a constant string we want to read or write.
   
   When writing, the ``ioLiteral`` is output without any quoting or escaping.
   
   When reading, the ``ioLiteral`` must be matched exactly - or else the read call
   will return an error for incorrectly formatted input
   

.. method:: proc fileReader.lock() throws

   
   Acquire a fileReader's lock. See :ref:`locking-filereaders-and-filewriters`
   for more details.
   
   :throws SystemError: Thrown if the lock could not be acquired.
   

.. method:: proc fileWriter.lock() throws

   
   Acquire a fileWriter's lock. See :ref:`locking-filereaders-and-filewriters`
   for more details.
   
   :throws SystemError: Thrown if the lock could not be acquired.
   

.. method:: proc fileReader.unlock()

   
   Release a fileReader's lock. See :ref:`locking-filereaders-and-filewriters`
   for more details.
   

.. method:: proc fileWriter.unlock()

   
   Release a fileWriter's lock. See :ref:`locking-filereaders-and-filewriters`
   for more details.
   

.. method:: proc fileReader.offset(): int(64)

   
   Return the current offset of a fileReader.
   
   If the fileReader can be used by multiple tasks, take care when doing
   operations that rely on the fileReader's current offset. To prevent race
   conditions, lock the fileReader with :proc:`fileReader.lock` before calling
   :proc:`fileReader.offset`, then unlock it afterwards with
   :proc:`fileReader.unlock`.
   
   :returns: the current offset of the fileReader
   

.. method:: proc fileWriter.offset(): int(64)

   
   Return the current offset of a fileWriter.
   
   If the fileWriter can be used by multiple tasks, take care when doing
   operations that rely on the fileWriter's current offset. To prevent race
   conditions, lock the fileWriter with :proc:`fileWriter.lock` before calling
   :proc:`fileWriter.offset`, then unlock it afterwards with
   :proc:`fileWriter.unlock`.
   
   :returns: the current offset of the fileWriter
   

.. method:: proc fileReader.advance(amount: int(64)) throws

   
   Move a :record:`fileReader` offset forward.
   
   This routine will consume the next ``amount`` bytes from the file, storing
   them in the ``fileReader``'s buffer. This can be useful for advancing to some
   known offset in the file before reading.
   
   Note that calling :proc:`fileReader.mark` before advancing will cause at
   least ``amount`` bytes to be retained in memory until
   :proc:`~fileReader.commit` or :proc:`~fileReader.revert` are called. As such,
   it is typical to advance by a small number of bytes during an I/O transaction.
   
   To make large adjustments to the offset, consider creating a new
   ``fileReader`` or using :proc:`~fileReader.seek` instead.
   
   :throws EofError: If EOF is reached before the requested number of bytes can
                     be consumed. The offset will be left at EOF.
   :throws SystemError: For other failures, for which fileReader offset is not
                        moved.
   

.. method:: proc fileWriter.advance(amount: int(64)) throws

   
   Move a :record:`fileWriter` offset forward.
   
   This routine will populate the ``fileWriter``'s buffer as the offset is moved
   forward by ``amount`` bytes. The buffer can be populated with any of the
   following data depending on the ``fileWriter``'s configuration and whether
   it was marked before advancing:
   
   * zeros
   * bytes directly from the file
   * bytes from a previously buffered portion of the file
   
   The contents of the buffer will subsequently be written to the file by the
   buffering mechanism.
   
   Note that calling :proc:`fileWriter.mark` before advancing will cause at
   least ``amount`` bytes to be retained in memory until
   :proc:`~fileWriter.commit` or :proc:`~fileWriter.revert` are called. As such,
   it is typical to advance by a small number of bytes during an I/O transaction.
   
   To make large adjustments to the offset, consider creating a new
   ``fileWriter`` or using :proc:`~fileWriter.seek` instead.
   
   :throws EofError: If EOF is reached before the offset can be advanced by the
                     requested number of bytes. The offset will be left at EOF.
   :throws SystemError: For other failures, for which fileWriter offset is not
                        moved.
   

.. method:: proc fileReader.advanceThrough(separator: ?t) throws where t == string || t == bytes

   
   Read until a separator is found, leaving the ``fileReader`` offset just
   after it.
   
   If the separator cannot be found, the ``fileReader`` offset is left at EOF
   and an ``UnexpectedEofError`` is thrown.
   
   .. note::
   
    The implementation is faster for single-byte ``string`` or ``bytes``
    separators.
   
   :arg separator: The separator to match with. Must be a :type:`~String.string`
    or :type:`~Bytes.bytes`.
   
   :throws EofError: Thrown if the ``fileReader`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the requested ``separator`` could not
                               be found.
   :throws SystemError: Thrown if data could not be read from the ``file``.

.. method:: proc fileReader.advanceTo(separator: ?t) throws where t == string || t == bytes

   
   Read until a separator is found, leaving the ``fileReader`` offset just before it.
   
   If the separator cannot be found, the ``fileReader`` offset is left at EOF and an
   ``UnexpectedEofError`` is thrown.
   
   .. note::
   
    The implementation is faster for single-byte ``string`` or ``bytes``
    separators.
   
   :arg separator: The separator to match with. Must be a :type:`~String.string` or
    :type:`~Bytes.bytes`.
   
   :throws EofError: Thrown if the ``fileReader`` offset is already at EOF.
   :throws UnexpectedEofError: Thrown if the requested ``separator`` could not be found.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``.

.. method:: proc fileReader.mark() throws

   
    *Mark* a :record:`fileReader` - that is, save the current offset of the
    ``fileReader`` on its *mark stack*.
   
    The *mark stack* stores several file offsets. The ``fileReader`` will keep
    the region of the file between its minimum and maximum *mark stack* values
    buffered in memory so that IO operations can be undone. As a result, it is
    possible to perform *I/O transactions* on a ``fileReader``. The basic steps
    for an *I/O transaction* are:
   
     * *mark* the current offset with :proc:`fileReader.mark`
     * do something speculative (e.g. try to read 200 bytes of anything followed
       by a 'B')
     * if the speculative operation was successful, commit the changes by
       calling :proc:`fileReader.commit`
     * if the speculative operation was not successful, go back to the *mark* by
       calling :proc:`fileReader.revert`. Subsequent I/O operations will work
       as though nothing happened.
   
    If a fileReader has ``locking==true``, :proc:`~fileReader.mark` should only
    be called once it has been locked with :proc:`fileReader.lock`. The
    fileReader should not be unlocked with :proc:`fileReader.unlock` until
    after the mark has been committed with :proc:`~fileReader.commit` or reverted
    with :proc:`~fileReader.revert`.
   
    See :ref:`io-transactions` for more.
   
   .. note::
   
     Note that it is possible to request an entire file be buffered in memory
     using this feature, for example by *marking* at offset=0 and then
     advancing to the end of the file. It is important to be aware of these
     memory space requirements.
   
   :returns: The offset that was marked
   :throws SystemError: if marking the ``fileReader`` failed
   

.. method:: proc fileWriter.mark() throws

   
    *Mark* a :record:`fileWriter` - that is, save the current offset of the
    ``fileWriter`` on its *mark stack*.
   
    The *mark stack* stores several file offsets. The ``fileWriter`` will keep
    the region of the file between its minimum and maximum *mark stack* values
    buffered in memory so that IO operations can be undone. As a result, it
    is possible to perform *I/O transactions* on a ``fileWriter``. The basic
    steps for an *I/O transaction* are:
   
     * *mark* the current offset with :proc:`fileWriter.mark`
     * do something speculative (e.g. try to write 200 bytes)
     * if the speculative operation was successful, commit the changes by
       calling :proc:`fileWriter.commit`
     * if the speculative operation was not successful, go back to the *mark* by
       calling :proc:`fileWriter.revert`. Subsequent I/O operations will work
       as though nothing happened.
   
    If a fileWriter has ``locking==true``, :proc:`~fileWriter.mark` should only
    be called once it has been locked with :proc:`fileWriter.lock`. The
    fileWriter should not be unlocked with :proc:`fileWriter.unlock` until
    after the mark has been committed with :proc:`~fileWriter.commit` or reverted
    with :proc:`~fileWriter.revert`.
   
    See :ref:`io-transactions` for more.
   
   .. note::
   
     Note that it is possible to request an entire file be buffered in memory
     using this feature, for example by *marking* at offset=0 and then
     advancing to the end of the file. It is important to be aware of these
     memory space requirements.
   
   :returns: The offset that was marked
   :throws SystemError: if marking the ``fileWriter`` failed
   

.. method:: proc fileReader.revert()

   
   Abort an *I/O transaction* by popping from the ``fileReader``'s *mark stack*
   and adjusting its position to that offset. See :ref:`io-transactions` for
   more.
   
   This routine should only be called on a fileReader that has already
   been marked. If called on a fileReader with ``locking=true``, the fileReader
   should have already been locked manually with :proc:`~fileReader.lock` before
   :proc:`~fileReader.mark` was called.

.. method:: proc fileWriter.revert()

   
   Abort an *I/O transaction* by popping from the ``fileWriter``'s *mark stack*
   and adjusting its position to that offset. See :ref:`io-transactions` for
   more.
   
   This routine should only be called on a fileWriter that has already
   been marked. If called on a fileWriter with ``locking=true``, the fileWriter
   should have already been locked manually with :proc:`~fileWriter.lock` before
   :proc:`~fileWriter.mark` was called.

.. method:: proc fileReader.commit()

   
   Commit an *I/O transaction* by popping from the ``fileReader``'s *mark stack*
   and leaving its position in the file unchanged. See :ref:`io-transactions` for
   more.
   
   This routine should only be called on a fileReader that has already
   been marked. If called on a fileReader with ``locking=true``, the fileReader
   should have already been locked manually with :proc:`~fileReader.lock` before
   :proc:`~fileReader.mark` was called.

.. method:: proc fileWriter.commit()

   
   Commit an *I/O transaction* by popping from the ``fileWriter``'s *mark stack*
   and leaving its position in the file unchanged. See :ref:`io-transactions` for
   more.
   
   This routine should only be called on a fileWriter that has already
   been marked. If called on a fileWriter with ``locking=true``, the fileWriter
   should have already been locked manually with :proc:`~fileWriter.lock` before
   :proc:`~fileWriter.mark` was called.

.. method:: proc fileReader.seek(region: range(?)) throws

   
   Adjust a :record:`fileReader`'s region. The ``fileReader``'s buffer will be
   discarded.
   
   This routine has the following constraints:
   
    * the underlying file must be seekable (sockets and pipes are not seekable)
    * the ``fileReader`` must be non-locking (to avoid race conditions if two
      tasks seek and read simultaneously)
    * the ``fileReader`` must not be marked (see: :proc:`fileReader.mark`)
   
   If the ``fileReader`` offset needs to be updated during an I/O transaction
   or if discarding the buffer will incur a performance penalty, consider using
   :proc:`fileReader.advance` instead.
   
   :arg region: the new region, measured in bytes and counting from 0. An upper
                bound can be omitted (e.g., ``r.seek(range=42..)``). See
                :ref:`region <filereader-filewriter-regions>` for more.
   
   .. warning::
   
      The region argument will ignore any specified stride other than 1.
   
   :throws SystemError: if seeking failed. Possible reasons include
                         that the file is not seekable, or that the
                         fileReader is marked.
   :throws IllegalArgumentError: if region argument did not have a lower bound
   

.. method:: proc fileWriter.seek(region: range(?)) throws

   
   Adjust a :record:`fileWriter`'s region. The ``fileWriter``'s buffer will be
   discarded.
   
   This routine has the following constraints:
   
    * the underlying file must be seekable (sockets and pipes are not seekable)
    * the ``fileWriter`` must be non-locking (to avoid race conditions if two
      tasks seek and read simultaneously)
    * the ``fileWriter`` must not be marked (see: :proc:`fileWriter.mark`)
   
   If the ``fileWriter`` offset needs to be updated during an I/O transaction
   or if discarding the buffer will incur a performance penalty, consider using
   :proc:`fileWriter.advance` instead.
   
   :arg region: the new region, measured in bytes and counting from 0. An upper
                bound can be omitted (e.g., ``w.seek(range=42..)``). See
                :ref:`region <filereader-filewriter-regions>` for more.
   
   .. warning::
   
      The region argument will ignore any specified stride other than 1.
   
   :throws SystemError: if seeking failed. Possible reasons include
                         that the file is not seekable, or that the
                         fileReader is marked.
   :throws IllegalArgumentError: if region argument did not have a lower bound
   

.. method:: proc fileReader._style(): iostyle

   .. warning::

      fileReader._style is deprecated because it returns a type that is deprecated

   
   
   Return the current style used by a fileReader. This function should only be
   called on a locked fileReader.
   
   

.. method:: proc fileWriter._style(): iostyle

   .. warning::

      fileWriter._style is deprecated because it returns a type that is deprecated

   
   
   Return the current style used by a fileWriter. This function should only be
   called on a locked fileWriter.
   
   

.. method:: proc fileReader._set_style(style: iostyle)

   .. warning::

      fileReader._set_style is deprecated because its purpose involves a deprecated type

   
   
   Set the style associated with a fileReader. This function should only
   be called on a locked fileReader.
   
   

.. method:: proc fileWriter._set_style(style: iostyle)

   .. warning::

      fileWriter._set_style is deprecated because its purpose involves a deprecated type

   
   
   Set the style associated with a fileWriter. This function should only
   be called on a locked fileWriter.
   
   

.. method:: proc fileReader.readWriteThisFromLocale()

   .. warning::

      'readWriteThisFromLocale' is unstable and may be removed or modified in a future release

   
   
   Return the locale on which an ongoing I/O was started with a fileReader.
   This method will return ``nilLocale`` unless it is called on a fileReader
   that is the formal argument to a `readThis` method.
   
   

.. method:: proc fileWriter.readWriteThisFromLocale()

   .. warning::

      'readWriteThisFromLocale' is unstable and may be removed or modified in a future release

   
   
   Return the locale on which an ongoing I/O was started with a fileWriter.
   This method will return ``nilLocale`` unless it is called on a fileWriter
   that is the formal argument to a `writeThis` method.
   
   

.. function:: proc openReader(path: string, param kind = _iokind.dynamic, param locking = true, start: int(64) = 0, end: int(64) = max(int(64)), hints = ioHintSet.empty, style: iostyle): fileReader(kind, locking, defaultSerializeType(false, kind)) throws

   .. warning::

      openReader with a 'style' argument is deprecated, please pass a Deserializer to the 'deserializer' argument instead

.. function:: proc openReader(path: string, param locking = true, region: range(?) = 0.., hints = ioHintSet.empty, in deserializer: ?dt = defaultSerializeVal(false)): fileReader(locking, dt) throws

   
   
   Open a file at a particular path and return a :record:`fileReader` for it.
   This function is equivalent to calling :proc:`open` and then
   :proc:`file.reader` on the resulting file.
   
   :arg path: which file to open (for example, "some/file.txt").
   :arg locking: compile-time argument to determine whether or not the
                 fileReader should use locking; sets the
                 corresponding parameter of the :record:`fileReader` type.
                 Defaults to true, but when safe, setting it to false
                 can improve performance.
   :arg region: zero-based byte offset indicating where in the file the
               fileReader should start and stop reading. Defaults to
               ``0..``, meaning from the start of the file to no specified end
               point.
   :arg hints: optional argument to specify any hints to the I/O system about
               this file. See :record:`ioHintSet`.
   :returns: an open fileReader to the requested resource.
   
   .. warning::
   
      The region argument will ignore any specified stride other than 1.
   
   :throws FileNotFoundError: Thrown if part of the provided path did not exist
   :throws PermissionError: Thrown if part of the provided path had inappropriate
                            permissions
   :throws NotADirectoryError: Thrown if part of the provided path was expected to
                               be a directory but was not
   :throws SystemError: Thrown if a fileReader could not be returned.
   :throws IllegalArgumentError: Thrown if trying to read explicitly prior to byte
                                 0.
    

.. function:: proc openReader(path: string, param kind = iokind.dynamic, param locking = true, region: range(?) = 0.., hints = ioHintSet.empty, in deserializer: ?dt = defaultSerializeVal(false, kind)): fileReader(kind, locking, dt) throws

   .. warning::

      openReader with a 'kind' argument is deprecated, please use Deserializers that support endianness instead

.. function:: proc openWriter(path: string, param kind = iokind.dynamic, param locking = true, start: int(64) = 0, end: int(64) = max(int(64)), hints = ioHintSet.empty, style: iostyle): fileWriter(kind, locking, defaultSerializeType(true, kind)) throws

   .. warning::

      openWriter with a 'style' argument is deprecated, please pass a Serializer to the 'serializer' argument instead

.. function:: proc openWriter(path: string, param locking = true, hints = ioHintSet.empty, in serializer: ?st = defaultSerializeVal(true)): fileWriter(locking, st) throws

   
   
   Open a file at a particular path and return a :record:`fileWriter` for it.
   This function is equivalent to calling :proc:`open` with ``ioMode.cwr`` and then
   :proc:`file.writer` on the resulting file.
   
   :arg path: which file to open (for example, "some/file.txt").
   :arg locking: compile-time argument to determine whether or not the
                 fileWriter should use locking; sets the
                 corresponding parameter of the :record:`fileWriter` type.
                 Defaults to true, but when safe, setting it to false
                 can improve performance.
   :arg hints: optional argument to specify any hints to the I/O system about
               this file. See :record:`ioHintSet`.
   :returns: an open fileWriter to the requested resource.
   
   :throws FileNotFoundError: Thrown if part of the provided path did not exist
   :throws PermissionError: Thrown if part of the provided path had inappropriate
                            permissions
   :throws NotADirectoryError: Thrown if part of the provided path was expected to
                               be a directory but was not
   :throws SystemError: Thrown if a fileWriter could not be returned.
   :throws IllegalArgumentError: Thrown if trying to write explicitly prior to byte
                                 0.

.. function:: proc openWriter(path: string, param kind = iokind.dynamic, param locking = true, hints = ioHintSet.empty, in serializer: ?st = defaultSerializeVal(true, kind)): fileWriter(kind, locking, st) throws

   .. warning::

      openWriter with a 'kind' argument is deprecated, please use Serializers that support endianness instead

.. method:: proc file.reader(param kind = iokind.dynamic, param locking = true, start: int(64) = 0, end: int(64) = max(int(64)), hints = ioHintSet.empty, style: iostyle): fileReader(kind, locking) throws

   .. warning::

      reader with a 'style' argument is deprecated, please pass a Deserializer to the 'deserializer' argument instead

.. method:: proc file.reader(param locking = true, region: range(?) = 0.., hints = ioHintSet.empty, in deserializer: ?dt = defaultSerializeVal(false)): fileReader(locking, dt) throws

   
   Create a :record:`fileReader` that supports reading from a file. See
   :ref:`about-io-overview`.
   
   The ``region=`` argument defines the portion of the file that the fileReader
   will read from.  This is a byte offset; the beginning of the file is at the
   offset 0.  The default for this argument enables the fileReader to access the
   entire file.
   
   A fileReader will never read beyond its maximum end offset. In addition,
   reading from a fileReader beyond the end of the underlying file will not
   extend that file.  Reading beyond the end of the file or beyond the end
   offset of the fileReader will produce the error ``OS.EofError`` (or just
   return `false` in many cases such as :proc:`fileReader.read`) to indicate
   that the end was reached.
   
   :arg locking: compile-time argument to determine whether or not the
                 fileReader should use locking; sets the
                 corresponding parameter of the :record:`fileReader` type.
                 Defaults to true, but when safe, setting it to false
                 can improve performance.
   :arg region: zero-based byte offset indicating where in the file the
               fileReader should start and stop reading. Defaults to
               ``0..`` - meaning from the start of the file to no end point.
   :arg hints: provide hints about the I/O that this fileReader will perform.
               See :record:`ioHintSet`. The default value of `ioHintSet.empty`
               will cause the fileReader to use the hints provided when the
               file was opened.
   
   .. warning::
   
      The region argument will ignore any specified stride other than 1.
   
   :throws SystemError: Thrown if a fileReader could not be returned.
   :throws IllegalArgumentError: Thrown if trying to read explicitly prior to
                                 byte 0.
   

.. method:: proc file.reader(param kind = iokind.dynamic, param locking = true, region: range(?) = 0.., hints = ioHintSet.empty, in deserializer: ?dt = defaultSerializeVal(false, kind)): fileReader(kind, locking, dt) throws

   .. warning::

      reader with a 'kind' argument is deprecated, please use Deserializers instead

.. method:: proc file.writer(param kind = iokind.dynamic, param locking = true, start: int(64) = 0, end: int(64) = max(int(64)), hints = ioHintSet.empty, style: iostyle): fileWriter(kind, locking) throws

   .. warning::

      writer with a 'style' argument is deprecated, please pass a Serializer to the 'serializer' argument instead

.. method:: proc file.writer(param locking = true, region: range(?) = 0.., hints = ioHintSet.empty, in serializer: ?st = defaultSerializeVal(true)): fileWriter(locking, st) throws

   
   Create a :record:`fileWriter` that supports writing to a file. See
   :ref:`about-io-overview`.
   
   The ``region=`` argument defines the portion of the file that the fileWriter
   will write to.  This is a byte offset; the beginning of the file is at the
   offset 0.  The default for this argument enables the fileWriter to access the
   entire file.
   
   When a fileWriter writes to a file, it will replace file data that was
   previously stored at the relevant offset. If the offset is beyond the
   end of the file, the file will be extended.
   
   A fileWriter will never write beyond its maximum end offset.  It will
   extend the file only as necessary to store data written to the fileWriter. In
   other words, specifying the high bound of the region argument here does not
   impact the file size directly; it impacts only the section of the file that
   this fileWriter can write to. After all fileWriters to a file are closed,
   that file will have a size equal to the last offset written to by any
   fileWriter.
   
   :arg locking: compile-time argument to determine whether or not the
                 fileWriter should use locking; sets the
                 corresponding parameter of the :record:`fileWriter` type.
                 Defaults to true, but when safe, setting it to false
                 can improve performance.
   :arg region: zero-based byte offset indicating where in the file the
               fileWriter should start and stop writing. Defaults to
               ``0..`` - meaning from the start of the file to no specified end
               point.
   :arg hints: provide hints about the I/O that this fileWriter will perform.
               See :record:`ioHintSet`. The default value of `ioHintSet.empty`
               will cause the fileWriter to use the hints provided when the
               file was opened.
   
   .. warning::
   
      The region argument will ignore any specified stride other than 1.
   
   :throws SystemError: Thrown if a fileWriter could not be returned.
   :throws IllegalArgumentError: Thrown if trying to write explicitly prior to
                                 byte 0.
   

.. method:: proc file.writer(param kind = iokind.dynamic, param locking = true, region: range(?) = 0.., hints = ioHintSet.empty, in serializer: ?st = defaultSerializeVal(true, kind)): fileWriter(kind, locking, st) throws

   .. warning::

      writer with a 'kind' argument is deprecated, please use Serializers instead

.. method:: proc fileReader.readWriteLiteral(lit: string, ignoreWhiteSpace = true) throws

   .. warning::

      :proc:`fileReader.readWriteLiteral` is deprecated; please use :proc:`fileReader.readLiteral` instead

   Explicit call for reading or writing a literal. Equivalent to calling
   :proc:`fileReader.readLiteral`.

.. method:: proc fileWriter.readWriteLiteral(lit: string, ignoreWhiteSpace = true) throws

   .. warning::

      :proc:`fileWriter.readWriteLiteral` is deprecated; please use :proc:`fileWriter.writeLiteral` instead

   Explicit call for reading or writing a literal. Equivalent to calling
   :proc:`fileWriter.writeLiteral`

.. method:: proc fileReader.readLiteral(literal: string, ignoreWhitespace = true): void throws

   
   Advances the offset of a ``fileReader`` within the file by reading the exact
   text of the given string ``literal`` from the fileReader.
   
   If the string is not matched exactly, then the fileReader's offset is
   unchanged. In such cases a :class:`OS.BadFormatError` will be thrown, unless
   the end of the fileReader is encountered in which case an :class:`OS.EofError`
   will be thrown.
   
   By default this method will ignore leading whitespace in the file when
   attempting to read a literal (leading whitespace in the ``literal`` itself
   is still matched against whitespace in the file).
   
   :arg literal: the string to be matched.
   :arg ignoreWhitespace: determines whether leading whitespace is ignored.
   
   :throws BadFormatError: Thrown if literal could not be matched.
   :throws EofError: Thrown if end of fileReader is encountered.
   

.. method:: proc fileReader.readLiteral(literal: bytes, ignoreWhitespace = true): void throws

   
   Advances the offset of a fileReader by reading the exact bytes of the given
   ``literal`` from the ``fileReader``.
   
   If the bytes are not matched exactly, then the fileReader's offset is
   unchanged. In such cases a :class:`OS.BadFormatError` will be thrown, unless
   the end of the ``fileReader`` is encountered in which case an
   :class:`OS.EofError` will be thrown.
   
   By default this method will ignore leading whitespace in the file when
   attempting to read a literal (leading whitespace in the ``literal`` itself
   is still matched against whitespace in the file).
   
   :arg literal: the bytes to be matched.
   :arg ignoreWhitespace: determines whether leading whitespace is ignored.
   
   :throws BadFormatError: Thrown if literal could not be matched.
   :throws EofError: Thrown if end of the ``fileReader`` is encountered.
   

.. method:: proc fileReader.readNewline(): void throws

   
   Advances the offset of the fileReader by reading a newline.
   
   If a newline is not matched exactly, then the fileReader's offset is
   unchanged. In such cases a :class:`OS.BadFormatError` will be thrown, unless
   the end of the ``fileReader`` is encountered in which case an
   :class:`OS.EofError` will be thrown. By default this method will ignore
   leading whitespace when attempting to read a newline.
   
   :throws BadFormatError: Thrown if a newline could not be matched.
   :throws EofError: Thrown if end of the ``fileReader`` is encountered.

.. method:: proc fileReader.matchLiteral(literal: string, ignoreWhitespace = true): bool throws

   
   Advances the offset of a fileReader by reading the exact text of the given
   string ``literal`` from the fileReader.
   
   If the string is not matched exactly, then the fileReader's offset is
   unchanged and this method will return ``false``. In other words, this
   fileReader will return ``false`` in the cases where
   :proc:`fileReader.readLiteral` would throw a :class:`OS.BadFormatError` or an
   :class:`OS.EofError`.
   
   By default this method will ignore leading whitespace in the file when
   attempting to read a literal (leading whitespace in the ``literal`` itself
   is still matched against whitespace in the file).
   
   :arg literal: the string to be matched.
   :arg ignoreWhitespace: determines whether leading whitespace is ignored.
   
   :returns: ``true`` if the read succeeded, and ``false`` on end of file or if
             the literal could not be matched.

.. method:: proc fileReader.matchLiteral(literal: bytes, ignoreWhitespace = true): bool throws

   
   Advances the offset of a ``fileReader`` by reading the exact bytes of the
   given ``literal`` from the ``fileReader``.
   
   If the bytes are not matched exactly, then the fileReader's offset is
   unchanged and this method will return ``false``. In other words, this
   fileReader will return ``false`` in the cases where
   :proc:`fileReader.readLiteral` would throw a :class:`OS.BadFormatError` or an
   :class:`OS.EofError`.
   
   By default this method will ignore leading whitespace in the file when
   attempting to read a literal (leading whitespace in the ``literal`` itself
   is still matched against whitespace in the file).
   
   :arg literal: the bytes to be matched.
   :arg ignoreWhitespace: determines whether leading whitespace is ignored.
   
   :returns: ``true`` if the read succeeded, and ``false`` on end of file or if
             the literal could not be matched.

.. method:: proc fileReader.matchNewline(): bool throws

   
   Advances the offset of the ``fileReader`` by reading a newline.
   
   If a newline is not matched exactly, then the fileReader's offset is
   unchanged and this method will return ``false``. In other words, this
   fileReader will return ``false`` in the cases where
   :proc:`fileReader.readNewline` would throw a :class:`OS.BadFormatError` or an
   :class:`OS.EofError`.
   
   By default this method will ignore leading whitespace when attempting to
   read a newline.
   
   :returns: ``true`` if the read succeeded, and ``false`` on end of file or if
             the newline could not be matched.

.. method:: proc fileWriter.writeLiteral(literal: string): void throws

   
   Writes a string to the ``fileWriter``, ignoring any formatting configured for
   this ``fileWriter``.

.. method:: proc fileWriter.writeLiteral(literal: bytes): void throws

   
   Writes bytes to the ``fileWriter``, ignoring any formatting configured for this
   ``fileWriter``.

.. method:: proc fileWriter.writeNewline(): void throws

   
   Writes a newline to the ``fileWriter``, ignoring any formatting configured for
   this ``fileWriter``.

.. method:: proc fileReader.readWriteNewline() throws

   .. warning::

      :proc:`fileReader.readWriteNewline` is deprecated; please use :proc:`fileReader.readNewline` instead

   Explicit call for reading or writing a newline. Equivalent to
   :proc:`fileReader.readNewline`.

.. method:: proc fileWriter.readWriteNewline() throws

   .. warning::

      :proc:`fileWriter.readWriteNewline` is deprecated; please use :proc:`fileWriter.writeNewline` instead

   Explicit call for reading or writing a newline. Equivalent to
   :proc:`fileWriter.writeNewline`.

.. method:: proc fileReader.binary(): bool

   .. warning::

      'fileReader.binary()' is deprecated; please use 'fileReader.deserializerType' to check for a binary deserializer instead

   Returns `true` if this fileReader is configured for binary I/O.
    

.. method:: proc fileWriter.binary(): bool

   .. warning::

      'fileWriter.binary()' is deprecated; please use 'fileWriter.serializerType' to check for a binary serializer instead

   Returns `true` if this fileWriter is configured for binary I/O.
    

.. itermethod:: iter fileReader.lines(stripNewline = false)

   
   Iterate over all of the lines ending in ``\n`` in a fileReader - the
   fileReader lock will be held while iterating over the lines.
   
   Only serial iteration is supported. This iterator will halt on internal
   system errors.
   
   .. warning::
   
     This iterator executes on the current locale. This may impact multilocale
     performance if the current locale is not the same locale on which the
     fileReader was created.
   
   :arg stripNewline: Whether to strip the trailing ``\n`` from the line. Defaults to false
   :yields: lines from the fileReader, by default with a trailing ``\n``
   
   

.. function:: proc stringify(const args ...?k): string

   .. warning::

      'stringify(x)' is deprecated; please use 'try! "%?".format(x)' from IO.FormattedIO instead

.. method:: proc fileReader.read(ref args ...?k): bool throws

   
   Read one or more values from a ``fileReader``. The ``fileReader``'s lock
   will be held while reading the values  this protects against interleaved
   reads.
   
   :arg args: a series of variables to read into. Basic types are handled
              internally, but for other types this function will call
              value.readThis() with a ``Reader`` argument as described
              in :ref:`readThis-writeThis`.
   :returns: `true` if the read succeeded, and `false` on end of file.
   
   :throws UnexpectedEofError: Thrown if an EOF occurred while reading an item.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        for :ref:`another reason<io-general-sys-error>`.
   

.. method:: proc fileReader.read(ref args ...?k, style: iostyle): bool throws

   .. warning::

      read with a 'style' argument is deprecated

.. method:: proc fileReader.readline(ref arg: [] uint(8), out numRead: int, start = arg.domain.lowBound, amount = arg.domain.highBound - start + 1): bool throws where arg.rank == 1 && arg.isRectangular()

   .. warning::

      fileReader.readline is deprecated. Use :proc:`fileReader.readLine` instead

   
   Read a line into a Chapel array of bytes. Reads until a ``\n`` is reached.
   The ``\n`` is returned in the array.
   
   Note that this routine currently requires a 1D rectangular non-strided array.
   
   Throws a SystemError if a line could not be read from the fileReader.
   
   :arg arg: A 1D DefaultRectangular array which must have at least 1 element.
   :arg numRead: The number of bytes read.
   :arg start: Index to begin reading into.
   :arg amount: The maximum amount of bytes to read.
   :returns: true if the bytes were read without error.

.. method:: proc fileReader.readLine(ref a: [] ?t, maxSize = a.size, stripNewline = false): int throws where a.rank == 1 && a.isRectangular() && a.strides == strideKind.one && (t == uint(8) || t == int(8))

   
   Read a line into an array of bytes.
   
   Reads bytes from the ``fileReader`` until a ``\n`` is reached. Values are
   read in binary format (i.e., this method is not aware of UTF-8 encoding).
   
   The array's size is not changed to accommodate bytes. If a newline is not
   found before the array is filled, or ``maxSize`` bytes are read, a
   :class:`~OS.BadFormatError` is thrown and the ``fileReader`` offset is
   returned to its original position.
   
   :arg a: A 1D DefaultRectangular non-strided array storing ``int(8)`` or
           ``uint(8)``. Values are overwritten.
   :arg maxSize: The maximum number of bytes to store into the ``a`` array.
                 Defaults to the size of the array.
   :arg stripNewline: Whether to strip the trailing ``\n`` from the line. If
                      ``true``, the newline isn't counted in the number of
                      bytes read.
   :returns: The number of array elements set by this call, or ``0`` otherwise
             (i.e., the ``fileReader`` was already at EOF).
   
   :throws IllegalArgumentError: Thrown if ``maxSize > a.size``
   :throws BadFormatError: Thrown if the line is longer than ``maxSize``. File
                           offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readline(ref arg: ?t): bool throws where t == string || t == bytes

   .. warning::

      fileReader.readline is deprecated. Use :proc:`fileReader.readLine` instead

   
   Read a line into a Chapel string or bytes. Reads until a ``\n`` is reached.
   The ``\n`` is included in the resulting value.
   
   :arg arg: a string or bytes to receive the line
   :returns: `true` if a line was read without error, `false` upon EOF
   
   :throws UnexpectedEofError: Thrown if unexpected EOF encountered while reading.
   :throws SystemError: Thrown if data could not be read from the fileReader.

.. method:: proc fileReader.readLine(ref s: string, maxSize = -1, stripNewline = false): bool throws

   
   Read a line into a ``string``. Reads until a ``\n`` is reached.
   
   :arg s: the :type:`~String.string` to read into. Contents are overwritten.
   :arg maxSize: The maximum number of codepoints to store into ``s``. The
                 default of -1 means to read an unlimited number of codepoints.
   :arg stripNewline: Whether to strip the trailing ``\n`` from the line.
   :returns: ``true`` if a line was read without error, ``false`` upon EOF
   
   :throws BadFormatError: Thrown if the line is longer than `maxSize`. The
                           ``fileReader`` offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readLine(ref b: bytes, maxSize = -1, stripNewline = false): bool throws

   
   Read a line into a ``bytes``. Reads until a ``\n`` is reached.
   
   :arg b: the :type:`~Bytes.bytes` to receive the line. Contents are overwritten.
   :arg maxSize: The maximum number of bytes to store into ``b``. The default of
                 -1 means to read an unlimited number of bytes.
   :arg stripNewline: Whether to strip the trailing ``\n`` from the line.
   :returns: ``true`` if a line was read without error, ``false`` upon EOF
   
   :throws BadFormatError: Thrown if the line is longer than `maxSize`. The file
                           offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readLine(type t = string, maxSize = -1, stripNewline = false): t throws where t == string || t == bytes

   
   Read a line. Reads until a ``\n`` is reached.
   
   :arg t: the type of data to read, which must be :type:`~String.string` or
           :type:`~Bytes.bytes`. Defaults to ``string`` if not specified.
   :arg maxSize: The maximum number of codepoints to read. The default of -1
                 means to read an unlimited number of codepoints.
   :arg stripNewline: Whether to strip the trailing ``\n`` from the line.
   :returns: A ``string`` or ``bytes`` with the contents of the ``fileReader``
             up to (and possibly including) the newline.
   
   :throws EofError: Thrown if nothing could be read because the ``fileReader``
                     was already at EOF.
   :throws BadFormatError: Thrown if the line is longer than `maxSize`. The file
                           offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readThrough(separator: ?t, maxSize = -1, stripSeparator = false): t throws where t == string || t == bytes

   
   Read until the given separator is found, returning the contents of the
   ``fileReader`` through that point.
   
   If the separator is found, the ``fileReader`` offset is left immediately
   after it. If the separator could not be found in the next ``maxSize`` bytes,
   a ``BadFormatError`` is thrown and the ``fileReader``'s offset is not
   changed. Otherwise, if EOF is reached before finding the separator, the
   remainder of the ``fileReader``'s contents are returned and the offset is
   left at EOF.
   
   To match with multiple separators, or a more complex separator, use the
   overload of :proc:`~Regex.fileReader.readThrough` that accepts a
   :type:`~Regex.regex` separator.
   
   :arg separator: The separator to match with. Must be a :type:`~String.string`
                   or :type:`~Bytes.bytes`.
   :arg maxSize: The maximum number of bytes to read. For the default value of
                 ``-1``, this method can read until EOF.
   :arg stripSeparator: Whether to strip the separator from the returned
                         ``string`` or ``bytes``. If ``true``, the returned
                         value will not include the separator.
   :returns: A ``string`` or ``bytes`` with the contents of the ``fileReader``
             up to (and possibly including) the separator.
   
   :throws EofError: Thrown if nothing could be read because the ``fileReader``
                     was already at EOF.
   :throws BadFormatError: Thrown if the separator was not found in the next
                           `maxSize` bytes. The fileReader offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readThrough(separator: string, ref s: string, maxSize = -1, stripSeparator = false): bool throws

   
   Read until the given separator is found, returning the contents of the
   ``fileReader`` through that point.
   
   See the above :proc:`overload <fileReader.readThrough>` of this method for
   more details.
   
   :arg separator: The separator to match with.
   :arg s: The :type:`~String.string` to read into. Contents will be overwritten.
   :arg maxSize: The maximum number of bytes to read. For the default value
                 of ``-1``, this method can read until EOF.
   :arg stripSeparator: Whether to strip the separator from the returned ``string``.
                        If ``true``, the separator will not be included in ``s``.
   :returns: ``true`` if something was read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws BadFormatError: Thrown if the separator was not found in the next
                           `maxSize` bytes. The fileReader offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readThrough(separator: bytes, ref b: bytes, maxSize = -1, stripSeparator = false): bool throws

   
   Read until the given separator is found, returning the contents of the
   ``fileReader`` through that point.
   
   See the above :proc:`overload <fileReader.readThrough>` of this method for
   more details.
   
   :arg separator: The separator to match with.
   :arg s: The :type:`~Bytes.bytes` to read into. Contents will be overwritten.
   :arg maxSize: The maximum number of codepoints to read. For the default value
                 of ``-1``, this method can read until EOF.
   :arg stripSeparator: Whether to strip the separator from the returned ``bytes``.
                        If ``true``, the separator will not be included in ``b``.
   :returns: ``true`` if something was read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws BadFormatError: Thrown if the separator was not found in the next
                           ``maxSize`` bytes. The fileReader offset is not moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readTo(separator: ?t, maxSize = -1): t throws where t == string || t == bytes

   
   Read until the given separator is found, returning the contents of the
   ``fileReader`` up to that point.
   
   If the separator is found, the ``fileReader`` offset is left immediately
   before it. If the separator could not be found in the next ``maxSize`` bytes,
   a ``BadFormatError`` is thrown and the ``fileReader``'s offset is not
   changed. Otherwise, if EOF is reached before finding the separator, the
   remainder of the ``fileReader``'s contents are returned and the offset is
   left at EOF.
   
   To match with multiple separators, or a more complex separator, use the
   overload of :proc:`~Regex.fileReader.readTo` that accepts a
   :type:`~Regex.regex` separator.
   
   :arg separator: The separator to match with. Must be a :type:`~String.string`
                   or :type:`~Bytes.bytes`.
   :arg maxSize: The maximum number of bytes to read. For the default
                 value of ``-1``, this method can read until EOF.
   :returns: A ``string`` or ``bytes`` with the contents of the ``fileReader``
             up to the ``separator``.
   
   :throws EofError: Thrown if nothing could be read because the ``fileReader``
                     was already at EOF.
   :throws BadFormatError: Thrown if the separator was not found in the next
                           ``maxSize`` bytes. The ``fileReader`` offset is not
                           moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readTo(separator: string, ref s: string, maxSize = -1): bool throws

   
   Read until the given separator is found, returning the contents of the
   ``fileReader`` up to that point.
   
   See the above :proc:`overload <fileReader.readTo>` of this method for
   more details.
   
   :arg separator: The separator to match with.
   :arg s: The :type:`~String.string` to read into. Contents will be overwritten.
   :arg maxSize: The maximum number of bytes to read. For the default value
                 of ``-1``, this method will read until EOF.
   :returns: ``true`` if something was read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws BadFormatError: Thrown if the separator was not found in the next
                           `maxSize` bytes. The ``fileReader`` offset is not
                           moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readTo(separator: bytes, ref b: bytes, maxSize = -1): bool throws

   
   Read until the given separator is found, returning the contents of the
   ``fileReader`` up to that point.
   
   See the above :proc:`overload <fileReader.readTo>` of this method for
   more details.
   
   :arg separator: The separator to match with.
   :arg b: The :type:`~Bytes.bytes` to read into. Contents will be overwritten.
   :arg maxSize: The maximum number of bytes to read. For the default value
                 of ``-1``, this method will read until EOF.
   :returns: ``true`` if something was read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws BadFormatError: Thrown if the separator was not found in the next
                           ``maxSize`` bytes. The ``fileReader`` offset is not
                           moved.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readAll(type t = bytes): t throws where t == string || t == bytes

   
   Read the remaining contents of the fileReader into an instance of the
   specified type
   
   :arg t: the type to read into; must be :type:`~String.string` or
           :type:`~Bytes.bytes`. Defaults to ``bytes`` if not specified.
   :returns: the contents of the ``fileReader`` as a ``t``
   
   :throws EofError: Thrown if nothing could be read because the ``fileReader``
                     was already at EOF.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readAll(ref s: string): int throws

   
   Read the remaining contents of the ``fileReader`` into a ``string``.
   
   Note that any existing contents of the ``string`` are overwritten.
   
   :arg s: the :type:`~String.string` to read into
   :returns: the number of codepoints that were stored in ``s``, or 0 if
             the ``fileReader`` is at EOF.
   :rtype: int
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readAll(ref b: bytes): int throws

   
   Read the remaining contents of the ``fileReader`` into a ``bytes``.
   
   Note that any existing contents of the ``bytes`` are overwritten.
   
   :arg b: the :type:`~Bytes.bytes` to read into
   :returns: the number of bytes that were stored in ``b``, or 0 if
             the ``fileReader`` is at EOF.
   :rtype: int
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readAll(ref a: [?d] ?t): int throws where a.rank == 1 && a.isRectangular() && a.strides == strideKind.one && (t == uint(8) || t == int(8))

   
   Read the remaining contents of the ``fileReader`` into an array of bytes.
   
   Note that this routine currently requires a 1D rectangular non-strided array.
   
   If the remaining contents of the fileReader exceed the size of ``a``, the
   first ``a.size`` bytes will be read into ``a``, and then an
   :class:`~OS.InsufficientCapacityError` will be thrown. In such a case, the
   ``fileReader`` offset is advanced ``a.size`` bytes from its original
   position.
   
   :arg a: the array of bytes to read into
   :returns: the number of bytes that were stored in ``a``
   :rtype: int
   
   :throws InsufficientCapacityError: Thrown if the fileReader's contents do not
                                      fit into ``a``.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readString(maxSize: int): string throws

   
   Read a given number of codepoints from a ``fileReader``, returning a new
   :type:`~String.string`.
   
   The ``string``'s length may be less than ``maxSize`` if EOF is reached while
   reading. If nothing is read, the empty string (``""``) will be returned.
   
   :arg maxSize: the maximum number of codepoints to read from the ``fileReader``
   :returns: a new ``string`` containing up to the next ``maxSize`` codepoints
               from the ``fileReader``
   
   :throws EofError: Thrown if the ``fileReader`` offset was already at EOF.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readString(ref s: string, maxSize: int): bool throws

   
   Read a given number of codepoints from a ``fileReader`` into a
   :type:`~String.string`.
   
   The updated ``string``'s length may be less than ``maxSize`` if EOF is
   reached while reading. If nothing is read, it will be set to the empty
   string (``""``).
   
   :arg s: the ``string`` to read into  contents will be overwritten
   :arg maxSize: the maximum number of codepoints to read from the ``fileReader``
   :returns: ``true`` if something was read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBytes(maxSize: int): bytes throws

   
   Read a given number of bytes from a ``fileReader``, returning a new
   :type:`~Bytes.bytes`.
   
   The ``bytes``'s length may be less than ``maxSize`` if EOF is reached while
   reading. If nothing is read, the empty bytes (``b""``) will be returned.
   
   :arg maxSize: the maximum number of bytes to read from the ``fileReader``
   :returns: a new ``bytes`` containing up to the next ``maxSize`` bytes
             from the ``fileReader``
   
   :throws EofError: Thrown if the ``fileReader`` offset was already at EOF.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBytes(ref b: bytes, maxSize: int): bool throws

   
   Read a given number of bytes from a ``fileReader`` into a
   :type:`~Bytes.bytes`.
   
   The updated ``bytes``'s length may be less than ``maxSize`` if EOF is
   reached while reading. If nothing is read, it will be set to the empty
   bytes (``b""``).
   
   :arg b: the ``bytes`` to read into  contents will be overwritten
   :arg maxSize: the maximum number of bytes to read from the ``fileReader``
   :returns: ``true`` if something was read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBits(ref x: integral, numBits: int): bool throws

   
   Read bits with binary I/O
   
   :arg x: where to store the read bits. This value will have its *numBits*
           least-significant bits set.
   :arg numBits: how many bits to read
   :returns: ``true`` if the bits were read, and ``false`` otherwise (i.e., the
             ``fileReader`` was already at EOF).
   
   :throws UnexpectedEofError: Thrown if EOF was encountered before ``numBits``
                               could be read.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readBits(type resultType, numBits: int): resultType throws

   
   Read bits with binary I/O
   
   :arg resultType: type of the value returned
   :arg numBits: how many bits to read
   :returns: bits read. This value will have its *numBits* least-significant
             bits set
   
   :throws EofError: Thrown if the ``fileReader`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if EOF was encountered before ``numBits``
                               could be read.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeBits(x: integral, numBits: int): void throws

   
   Write bits with binary I/O
   
   :arg x: a value containing *numBits* bits to write the least-significant bits
   :arg numBits: how many bits to write
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified range.
   :throws IllegalArgumentError: Thrown if writing more bits than fit into `x`.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeCodepoint(codepoint: int) throws

   
   Write a single Unicode codepoint to a ``fileWriter``
   
   :arg codepoint: Unicode codepoint to write
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified range.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readCodepoint(): int throws

   
   Read a single Unicode codepoint from a ``fileReader``
   
   :returns: Unicode codepoint read
   
   :throws EofError: Thrown if the ``fileReader`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if EOF was encountered while reading a
                               codepoint.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readCodepoint(ref codepoint: int): bool throws

   
   Read a single Unicode codepoint from a ``fileReader``
   
   :arg c: where to store the read codepoint
   :returns: ``true`` if the codepoint was read, and ``false`` otherwise (i.e.,
             the ``fileReader`` was already at EOF).
   
   :throws UnexpectedEofError: Thrown if EOF was encountered while reading a
                               codepoint.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeByte(byte: uint(8)) throws

   
   Write a single byte to a ``fileWriter``
   
   :arg byte: the byte to write
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified range.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readByte(): uint(8) throws

   
   Read a single byte from a ``fileReader``
   
   :returns: the byte read
   
   :throws EofError: Thrown if the ``fileReader`` offset was already at EOF.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readByte(ref byte: uint(8)): bool throws

   
   Read a single byte from a ``fileReader``
   
   :arg byte: where to store the read byte
   :returns: ``true`` if the byte was read, and ``false`` otherwise (i.e.,
             the ``fileReader`` was already at EOF).
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. data:: config param IOSkipBufferingForLargeOps = true

   .. warning::

      IOSkipBufferingForLargeOps is unstable and could change or be removed in the future

   
   Controll whether large read/write operations can bypass the IO runtime's
   buffering mechanism.
   
   This optimization is on by default as it can improve performance for large
   operations where buffering doesn't significantly reduce the number of system
   I/O calls and thus adds unnecessary overhead.
   
   To disable the optimization, compile with ``-sIOSkipBufferingForLargeOps=false``.
   
   Note that this flag controls an implementation-specific feature and
   thus is not part of the Chapel language specification.

.. method:: proc fileWriter.writeString(s: string, size = s.size) throws

   
   Write ``size`` codepoints from a :type:`~String.string` to a ``fileWriter``
   
   :arg s: the ``string`` to write
   :arg size: the number of codepoints to write from the ``string``
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified range.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   :throws IllegalArgumentError: Thrown if ``size`` is larger than ``s.size``

.. method:: proc fileWriter.writeBytes(b: bytes, size = b.size) throws

   
   Write ``size`` bytes from a :type:`~Bytes.bytes` to a ``fileWriter``
   
   :arg b: the ``bytes`` to write
   :arg size: the number of bytes to write from the ``bytes``
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified range.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   :throws IllegalArgumentError: Thrown if ``size`` is larger than ``b.size``

.. method:: proc fileWriter.writeBinary(ptr: c_ptr(?t), numBytes: int) throws

   
   Write ``numBytes`` of data from a :class:`~CTypes.c_ptr` to a ``fileWriter``
   
   Note that native endianness is always used.
   
   If ``numBytes`` is not evenly divisible by the size of ``t``, the remaining
   bytes will be ignored. For example, if the ``c_ptr``'s internal type is 4
   bytes in length, and ``numBytes=17``, only 16 bytes will be written.
   
   .. warning::
     This method provides no protection against attempting to access invalid
     memory
   
   :arg ptr: a :class:`~CTypes.c_ptr` to some valid memory
   :arg numBytes: the number of bytes to write
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeBinary(ptr: c_ptr(void), numBytes: int) throws

   
   Write ``numBytes`` of data from a ``CTypes.c_ptr(void)`` to a ``fileWriter``
   
   The data are written to the file one byte at a time.
   
   .. warning::
     This method provides no protection against attempting to access invalid
     memory
   
   :arg ptr: a ``c_ptr(void)`` to some valid memory
   :arg numBytes: the number of bytes to write
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeBinary(arg: numeric, param endian: endianness = endianness.native) throws

   
   Write a binary number to the ``fileWriter``
   
   :arg arg: number to be written
   :arg endian: :type:`endianness` compile-time argument that specifies the byte
                order in which to write the number. Defaults to
                :enumconstant:`endianness.native`.
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileWriter.writeBinary(arg: numeric, endian: endianness) throws

   
   Write a binary number to the ``fileWriter``
   
   :arg arg: number to be written
   :arg endian: :type:`endianness` specifies the byte order in which
                to write the number.
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeBinary(s: string, size: int = s.size) throws

   
   Write a :type:`~String.string` to a ``fileWriter`` in binary format
   
   :arg s: the ``string`` to write
   :arg size: the number of codepoints to write from the ``string``
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   :throws IllegalArgumentError: Thrown if ``size`` is larger than ``s.size``.

.. method:: proc fileWriter.writeBinary(b: bytes, size: int = b.size) throws

   
   Write a :type:`~Bytes.bytes` to a ``fileWriter`` in binary format
   
   :arg b: the ``bytes`` to write
   :arg size: the number of bytes to write from the ``bytes``
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   :throws IllegalArgumentError: Thrown if ``size`` is larger than ``b.size``.

.. method:: proc fileWriter.writeBinary(const ref data: [?d] ?t, param endian: endianness = endianness.native) throws where isSuitableForBinaryReadWrite(data) && data.strides == strideKind.one && (isIntegralType(t) || isRealType(t) || isImagType(t) || isComplexType(t))

   
   Write an array of binary numbers to a ``fileWriter``
   
   Note that this routine currently requires a local rectangular non-strided array.
   
   :arg data: an array of numbers to write to the fileWriter
   :arg endian: :type:`endianness` compile-time argument that specifies the byte
                order in which to read the numbers. Defaults to
                :enumconstant:`endianness.native`.
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileWriter.writeBinary(const ref data: [] ?t, endian: endianness) throws where isSuitableForBinaryReadWrite(data) && data.strides == strideKind.one && (isIntegralType(t) || isRealType(t) || isImagType(t) || isComplexType(t))

   
   Write an array of binary numbers to a ``fileWriter``
   
   Note that this routine currently requires a local rectangular non-strided array.
   
   :arg data: an array of numbers to write to the fileWriter
   :arg endian: :type:`endianness` specifies the byte order in which
                to write the number.
   
   :throws EofError: Thrown if the ``fileWriter`` offset was already at EOF.
   :throws UnexpectedEofError: Thrown if the write operation exceeds the
                               ``fileWriter``'s specified region.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBinary(ref arg: numeric, param endian: endianness = endianness.native): bool throws

   
   Read a binary number from the ``fileReader``
   
   :arg arg: number to be read
   :arg endian: :type:`endianness` compile-time argument that specifies the byte
                order in which to read the number. Defaults to
                :enumconstant:`endianness.native`.
   :returns: ``true`` if the number was read, and ``false`` otherwise (i.e.,
             the ``fileReader`` was already at EOF).
   
   :throws UnexpectedEofError: Thrown if EOF was encountered while reading the
                               number.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readBinary(ref arg: numeric, endian: endianness): bool throws

   
    Read a binary number from the ``fileReader``
   
    :arg arg: number to be read
    :arg endian: :type:`endianness` specifies the byte order in which
                 to read the number.
    :returns: ``true`` if the number was read, and ``false`` otherwise (i.e.,
              the ``fileReader`` was already at EOF).
   
   :throws UnexpectedEofError: Thrown if EOF was encountered while reading the
                               number.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readBinary(ref s: string, maxSize: int): bool throws

   
   Read a specified number of codepoints into a :type:`~String.string`
   
   The resulting string ``s`` may be smaller than ``maxSize`` if EOF is reached
   before reading the specified number of codepoints. Additionally, if nothing
   is read from the fileReader, ``s`` will be set to ``""`` (the empty string)
   and the method will return ``false``.
   
   .. note::
   
     This method always uses UTF-8 encoding regardless of the fileReader's
     configuration
   
   :arg s: the string to read into  this value is overwritten
   :arg maxSize: the number of codepoints to read from the ``fileReader``
   :returns: ``true`` if some codepoints were read, or ``false`` on EOF
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBinary(ref b: bytes, maxSize: int): bool throws

   
   Read a specified number of bytes into a :type:`~Bytes.bytes`
   
   The bytes ``b`` may be smaller than ``maxSize`` if EOF is reached before
   reading the specified number of bytes. Additionally, if nothing is read
   from the fileReader, ``b`` will be set to ``b""`` (the empty bytes) and
   the method will return ``false``.
   
   :arg b: the bytes to read into  this value is overwritten
   :arg maxSize: the number of bytes to read from the ``fileReader``
   :returns: ``true`` if some bytes were read, or ``false`` on EOF
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBinary(ref data: [?d] ?t, param endian = endianness.native): int throws where isSuitableForBinaryReadWrite(data) && data.strides == strideKind.one && (isIntegralType(t) || isRealType(t) || isImagType(t) || isComplexType(t))

   
   Read an array of binary numbers from a ``fileReader``
   
   Binary values of the type ``data.eltType`` are consumed from the fileReader
   until ``data`` is full or EOF is reached.
   
   Note that this routine currently requires a local rectangular non-strided array.
   
   :arg data: an array to read into  existing values are overwritten.
   :arg endian: :type:`endianness` compile-time argument that specifies the byte
                order in which to read the numbers in. Defaults to
                :enumconstant:`endianness.native`.
   :returns: the number of values that were read into the array. This can be
             less than ``data.size`` if EOF was reached, or an error occurred,
             before filling the array.
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBinary(ref data: [] ?t, endian: endianness): int throws where isSuitableForBinaryReadWrite(data) && data.strides == strideKind.one && (isIntegralType(t) || isRealType(t) || isImagType(t) || isComplexType(t))

   
   Read an array of binary numbers from a ``fileReader``
   
   Binary values of the type ``data.eltType`` are consumed from the fileReader
   until ``data`` is full or EOF is reached.
   
   Note that this routine currently requires a local rectangular non-strided array.
   
   :arg data: an array to read into  existing values are overwritten.
   :arg endian: :type:`endianness` specifies the byte order in which
                to read the number.
   :returns: the number of values that were read into the array. This can be
             less than ``data.size`` if EOF was reached, or an error occurred,
             before filling the array.
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBinary(ptr: c_ptr(?t), maxBytes: int): int throws

   
   Read up to ``maxBytes`` bytes from a ``fileReader`` into a
   :class:`~CTypes.c_ptr`
   
   Note that native endianness is always used.
   
   If ``maxBytes`` is not evenly divisible by the size of ``t``, then the
   remaining bytes are ignored.
   
   :arg ptr: a :class:`~CTypes.c_ptr` to some memory  existing values will be
             overwritten
   :arg maxBytes: the maximum number of bytes to read from the ``fileReader``
   :returns: the number of bytes that were read. this can be less than
              ``maxBytes`` if EOF was reached before reading the specified
              number of bytes, or if ``maxBytes`` is not evenly divisible by
              the size of ``t``
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readBinary(ptr: c_ptr(void), maxBytes: int): int throws

   
   Read up to ``maxBytes`` bytes from a ``fileReader`` into a
   ``CTypes.c_ptr(void)``
   
   Note that data are read from the file one byte at a time.
   
   :arg ptr: a ``c_ptr(void)`` to some memory  existing
             values will be overwritten
   :arg maxBytes: the maximum number of bytes to read from the ``fileReader``
   :returns: the number of bytes that were read. this can be less than
             ``maxBytes`` if EOF was reached before reading the specified number
             of bytes
   
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.

.. method:: proc fileReader.readln(ref args ...?k): bool throws

   .. warning::

      'readln' is unstable and may be removed or modified in a future release

   
   Read values from a ``fileReader`` and then consume any bytes until
   newline is reached. The input will be consumed atomically - the
   fileReader lock will be held while reading all of the passed values.
   
   :arg args: a list of arguments to read. This routine can be called
              with zero or more such arguments. Basic types are handled
              internally, but for other types this function will call
              value.readThis() with a ``Reader`` argument as described
              in :ref:`readThis-writeThis`.
   :returns: `true` if the read succeeded, and `false` upon end of file.
   
   :throws UnexpectedEofError: Thrown if EOF was encountered before data could
                               be read.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readln(ref args ...?k, style: iostyle): bool throws

   .. warning::

      readln with a 'style' argument is deprecated

.. method:: proc fileReader.read(type t) throws

   
   Read a value of passed type.
   
   For example, the following line of code reads a value of type `int`
   from :var:`stdin` and uses it to initialize a variable ``x``:
   
   .. code-block:: chapel
   
     var x = stdin.read(int);
   
   :arg t: the type to read
   :returns: the value read
   
   :throws EofError: Thrown if the ``fileReader`` is already at EOF.
   :throws UnexpectedEofError: Thrown if EOF was encountered before data could
                               be fully read.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readln(type t) throws

   .. warning::

      'readln' is unstable and may be removed or modified in a future release

   
   Read a value of passed type followed by a newline.
   
   :arg t: the type to read
   :returns: the value read
   
   :throws EofError: Thrown if the ``fileReader`` is at already EOF.
   :throws UnexpectedEofError: Thrown if EOF was encountered before data could
                               be fully read.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.readln(type t ...?numTypes) throws where numTypes > 1

   .. warning::

      'readln' is unstable and may be removed or modified in a future release

   
   Read values of passed types followed by a newline
   and return a tuple containing the read values.
   
   :arg t: more than one type to read
   :returns: a tuple of the read values
   
   :throws EofError: Thrown if the ``fileReader`` is already at EOF.
   :throws UnexpectedEofError: Thrown if EOF was encountered before data could
                               be fully read.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileReader.read(type t ...?numTypes) throws where numTypes > 1

   
   Read values of passed types and return a tuple containing the read values.
   The ``fileReader``'s lock will be held while reading  this protects against
   interleaved reads.
   
   :arg t: more than one type to read
   :returns: a tuple of the read values
   
   :throws EofError: Thrown if the ``fileReader`` is already at EOF.
   :throws UnexpectedEofError: Thrown if EOF was encountered while more data was
                               expected.
   :throws SystemError: Thrown if data could not be read from the ``fileReader``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileWriter.write(const args ...?k) throws

   
   Write values to a ``fileWriter``. The output will be produced atomically -
   the ``fileWriter`` lock will be held while writing all of the passed
   values.
   
   :arg args: a list of arguments to write. Basic types are handled
              internally, but for other types this function will call
              value.writeThis() with the ``fileWriter`` as an argument.
   
   :throws EofError: Thrown if EOF is reached before all the arguments could be
                     written.
   :throws UnexpectedEofError: Thrown if EOF is encountered while writing one of
                               the arguments.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileWriter.write(const args ...?k, style: iostyle) throws

   .. warning::

      write with a 'style' argument is deprecated

.. method:: proc fileWriter.writeln(const args ...?k) throws

   
   
   Write values to a ``fileWriter`` followed by a newline.  The output will be
   produced atomically - the ``fileWriter`` lock will be held while writing all of
   the passed values.
   
   :arg args: a variable number of arguments to write. This method can be
              called with zero or more arguments. Basic types are handled
              internally, but for other types this function will call
              value.writeThis() with the fileWriter as an argument.
   
   :throws EofError: Thrown if EOF is reached before all the arguments
                     could be written.
   :throws UnexpectedEofError: Thrown if EOF is encountered while writing one of
                               the arguments.
   :throws SystemError: Thrown if data could not be written to the ``fileWriter``
                        due to a :ref:`system error<io-general-sys-error>`.
   

.. method:: proc fileWriter.writeln(const args ...?k, style: iostyle) throws

   .. warning::

      writeln with a 'style' argument is deprecated

.. method:: proc fileWriter.flush() throws

   
   
   Makes all writes to the ``fileWriter``, if any, available to concurrent
   viewers of its associated file, such as other fileWriters/fileReader or other
   applications accessing this file concurrently.
   
   Unlike :proc:`file.fsync`, this does not commit the written data
   to the file's device.
   
   :throws SystemError: Thrown if the flush fails.

.. method:: proc fileReader.assertEOF(errStr: string = "- Not at EOF")

   .. warning::

      'assertEOF' is unstable and may be removed or modified in a future release

   Assert that a ``fileReader`` has reached end-of-file and that there was no
   error doing the read.

.. method:: proc fileReader.close() throws

   
   Close a ``fileReader``
   
   :throws SystemError: Thrown if the ``fileReader`` is not successfully closed.

.. method:: proc fileWriter.close() throws

   
   Close a ``fileWriter``. Implicitly performs the :proc:`fileWriter.flush`
   operation (see :ref:`about-io-filereader-filewriter-synchronization`).
   
   :throws SystemError: Thrown if the ``fileWriter`` is not successfully closed.

.. method:: proc fileReader.isClosed(): bool

   
   Return ``true`` if a fileReader is currently closed.
   

.. method:: proc fileWriter.isClosed(): bool

   
   Return ``true`` if a fileWriter is currently closed.
   

.. data:: const stdin: fileReader(true)

   A locking :record:`fileReader` instance that reads from standard input. 

.. data:: const stdout: fileWriter(true)

   A locking :record:`fileWriter` instance that writes to standard output. 

.. data:: const stderr: fileWriter(true)

   A locking :record:`fileWriter` instance that writes to standard error. 

.. function:: proc read(ref args ...?n): bool throws

   Equivalent to ``stdin.read``. See :proc:`fileReader.read` 

.. function:: proc read(type t ...?numTypes) throws

   Equivalent to ``stdin.read``. See :proc:`fileReader.read` for types 

.. function:: proc readLine(ref a: [] ?t, maxSize = a.size, stripNewline = false): int throws where a.rank == 1 && a.isRectangular() && a.strides == strideKind.one && (t == uint(8) || t == int(8))

   Equivalent to ``stdin.readLine``.  See :proc:`fileReader.readLine` 

.. function:: proc readline(arg: [] uint(8), out numRead: int, start = arg.domain.lowBound, amount = arg.domain.highBound - start + 1): bool throws where arg.rank == 1 && arg.isRectangular()

   .. warning::

      readline is deprecated. Use :proc:`readLine` instead

   Equivalent to ``stdin.readline``.  See :proc:`fileReader.readline` 

.. function:: proc readline(ref arg: ?t): bool throws where t == string || t == bytes

   .. warning::

      readline is deprecated. Use :proc:`readLine` instead

   Equivalent to ``stdin.readline``.  See :proc:`fileReader.readline` 

.. function:: proc readLine(ref s: string, maxSize = -1, stripNewline = false): bool throws

   Equivalent to ``stdin.readLine``.  See :proc:`fileReader.readLine` 

.. function:: proc readLine(ref b: bytes, maxSize = -1, stripNewline = false): bool throws

   Equivalent to ``stdin.readLine``.  See :proc:`fileReader.readLine` 

.. function:: proc readLine(type t = string, maxSize = -1, stripNewline = false): t throws where t == string || t == bytes

   Equivalent to ``stdin.readLine``.  See :proc:`fileReader.readLine` 

.. function:: proc readln(ref args ...?n): bool throws

   .. warning::

      'readln' is unstable and may be removed or modified in a future release

   Equivalent to ``stdin.readln``. See :proc:`fileReader.readln` 

.. function:: proc readln(type t ...?numTypes) throws

   .. warning::

      'readln' is unstable and may be removed or modified in a future release

   Equivalent to ``stdin.readln``. See :proc:`fileReader.readln` for types 

.. method:: proc file.localesForRegion(start: int(64), end: int(64))

   .. warning::

      file.localesForRegion is deprecated

   
   Returns the 'best' locale to run something working with the region
   of the file in start..end-1.
   
   This *must* return the same result when called from different locales.
   Returns a domain of locales that are "best" for the given region. If no
   locales are "best" we return a domain containing all locales.
   
   :arg start: the file offset (starting from 0) where the region begins
   :arg end: the file offset just after the region
   :returns: a set of locales that are best for working with this region
   :rtype: domain(locale)
   

