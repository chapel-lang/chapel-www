<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Conversions &mdash; Chapel Documentation 1.33</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Expressions" href="expressions.html" />
    <link rel="prev" title="Variables" href="variables.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.33
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.33";
$pagename = "language/spec/conversions";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#language-basics">Language Basics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-conversions">Implicit Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-conversions">Explicit Conversions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l3"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-structures">Code Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
      <li>Conversions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/conversions.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="conversions">
<span id="chapter-conversions"></span><h1>Conversions<a class="headerlink" href="#conversions" title="Permalink to this headline">¶</a></h1>
<p>A <em>conversion</em> converts an expression of one type to another type,
possibly producing a new value. In certain cases noted below, the source
expression can be a type expression. We refer to these two types as the
<em>source</em> and <em>target</em> types. Conversions can be either
implicit (<a class="reference internal" href="#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) or
explicit (<a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a>).</p>
<div class="section" id="implicit-conversions">
<span id="id1"></span><h2>Implicit Conversions<a class="headerlink" href="#implicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>An <em>implicit conversion</em> is a conversion that occurs implicitly—that
is, without an explicit operation within the program. Implicit conversions
fall into the following categories:</p>
<blockquote>
<div><ul class="simple">
<li><p>implicit conversions for initialization and assignment
(<a class="reference internal" href="#implicit-conversion-init-assign"><span class="std std-ref">Implicit Conversions for Initialization and Assignment</span></a>)</p></li>
<li><p>implicit conversions for function calls
(<a class="reference internal" href="#implicit-conversion-call"><span class="std std-ref">Implicit Conversions for Function Calls</span></a>)</p></li>
<li><p>implicit conversions for conditionals
(<a class="reference internal" href="#implicit-conversion-conditionals"><span class="std std-ref">Implicit Conversions for Conditionals</span></a>)</p></li>
</ul>
</div></blockquote>
<p>If an implicit conversion for a function call is allowed from type <code class="docutils literal notranslate"><span class="pre">T1</span></code> to
type <code class="docutils literal notranslate"><span class="pre">T2</span></code> then implicit conversion for initialization and assignment is
allowed.</p>
<p>In addition, an implicit conversion from a type to the same type is
allowed for any type. Such a conversion does not change the value of the
expression.</p>
<p>Implicit conversion is not transitive. That is, if an implicit
conversion is allowed from type <code class="docutils literal notranslate"><span class="pre">T1</span></code> to <code class="docutils literal notranslate"><span class="pre">T2</span></code> and from <code class="docutils literal notranslate"><span class="pre">T2</span></code> to
<code class="docutils literal notranslate"><span class="pre">T3</span></code>, that by itself does not allow an implicit conversion from <code class="docutils literal notranslate"><span class="pre">T1</span></code>
to <code class="docutils literal notranslate"><span class="pre">T3</span></code>.</p>
<p>Implicit conversion for function calls, initialization, and assignment
are allowed between the following source and target types, as defined in
the referenced subsections:</p>
<ul class="simple">
<li><p>boolean and numeric types
types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>),</p></li>
<li><p>numeric types in the special case when the expression’s value is a
compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>),</p></li>
<li><p>ranges (<a class="reference internal" href="#implicit-range-conversions"><span class="std std-ref">Implicit Range Conversions</span></a>),</p></li>
<li><p>class types (<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>), and</p></li>
<li><p>when the source type is a subtype of the target type (including when
the target type is generic)
(<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>)</p></li>
</ul>
<p>Additionally, implicit conversions for initialization and assignment can
be defined for record types, as specified in
<a class="reference internal" href="#implicit-conversion-init-assign"><span class="std std-ref">Implicit Conversions for Initialization and Assignment</span></a>.</p>
<div class="section" id="implicit-numeric-and-bool-conversions">
<span id="implicit-numbool-conversions"></span><h3>Implicit Numeric and Bool Conversions<a class="headerlink" href="#implicit-numeric-and-bool-conversions" title="Permalink to this headline">¶</a></h3>
<p>Implicit conversions among numeric types are allowed when all values
representable in the source type can also be represented in the target
type, retaining their full precision. In addition, implicit conversions
are permitted from <code class="docutils literal notranslate"><span class="pre">int(s)</span></code> and <code class="docutils literal notranslate"><span class="pre">uint(s)</span></code> values to <code class="docutils literal notranslate"><span class="pre">real(t)</span></code> and
<code class="docutils literal notranslate"><span class="pre">complex(2*t)</span></code>, for any widths <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, even though these cases
may result in a loss of precision.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We allow these additional conversions because they provide an
important convenience for application programmers who want to mix
integral and floating point values in mathematical expressions, and
for computing using values using a specific bit-width. For these
benefits, the loss of precision seemed like a reasonable tradeoff,
particularly given that floating point types are approximate by
nature.</p>
</div></blockquote>
<p>Signed integral types <code class="docutils literal notranslate"><span class="pre">int(s)</span></code> can implicitly convert to <code class="docutils literal notranslate"><span class="pre">uint(t)</span></code>
where <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&lt;=</span> <span class="pre">t</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We allow these conversions to avoid the situation that something
similar to a binary operator produces surprising results when mixing
<code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">uint</span></code> types. In particular, without this rule, the
<code class="docutils literal notranslate"><span class="pre">plus</span></code> function defined below would surprisingly produce values of a
different width or a different kind:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">plus</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">plus</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">plus</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">plus</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">plus</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">myInt32</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">myUint32</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
<span class="nx">plus</span><span class="p">(</span><span class="nx">myInt32</span><span class="p">,</span> <span class="nx">myUint32</span><span class="p">);</span> <span class="c1">// calls &#39;uint(32)&#39; version, but</span>
                         <span class="c1">// without int-&gt;uint implicit conversion,</span>
                         <span class="c1">// would call the &#39;int(64)&#39; version</span>
<span class="kd">var</span> <span class="nx">myInt64</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">myUint64</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="nx">plus</span><span class="p">(</span><span class="nx">myInt64</span><span class="p">,</span> <span class="nx">myUint64</span><span class="p">);</span> <span class="c1">// calls &#39;uint(64)&#39; version, but</span>
                         <span class="c1">// without int-&gt;uint implicit conversion,</span>
                         <span class="c1">// would call the &#39;real(64)&#39; version</span>
</pre></div>
</div>
<p>While implicitly converting an <code class="docutils literal notranslate"><span class="pre">int</span></code> to a <code class="docutils literal notranslate"><span class="pre">uint</span></code> can lead to
surprising behavior, this behavior is less problematic than the
surprising behavior that comes from the above scenario.</p>
</div></blockquote>
<p>A <code class="docutils literal notranslate"><span class="pre">bool</span></code> can be implicitly converted to any integral type by
representing <code class="docutils literal notranslate"><span class="pre">false</span></code> as 0 and <code class="docutils literal notranslate"><span class="pre">true</span></code> as 1.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We disallow implicit conversion of a <code class="docutils literal notranslate"><span class="pre">bool</span></code> to a real, imaginary,
or complex type because we expect that such conversions are most
likely to be an unintended mistake by the programmer.
Marking such cases as errors will draw the programmer’s attention
to the issue, and if such a conversion is actually desired, a cast
can be used (see <a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a>).</p>
</div></blockquote>
<p>Legal implicit conversions with numeric and boolean types may thus be
summarized as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 16%" />
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 19%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p></p></td>
<td colspan="5"><p><strong>Destination Type</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Source Type</strong></p></td>
<td><p>uint(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>int(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>real(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>imag(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>complex(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
</tr>
<tr class="row-odd"><td><p>bool</p></td>
<td><p>all <span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(t\)</span></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>uint(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s &lt; t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
<td></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>int(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
<td></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
</tr>
<tr class="row-even"><td><p>real(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t/2\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>imag(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le t/2\)</span></p></td>
</tr>
<tr class="row-even"><td><p>complex(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="implicit-compile-time-constant-conversions">
<span id="id2"></span><h3>Implicit Compile-Time Constant Conversions<a class="headerlink" href="#implicit-compile-time-constant-conversions" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">param</span></code> of numeric type can be implicitly converted to another numeric
type in some cases if the <code class="docutils literal notranslate"><span class="pre">param</span></code> value can be represented exactly by
the target type. In particular:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code> <code class="docutils literal notranslate"><span class="pre">int(s)</span></code> and <code class="docutils literal notranslate"><span class="pre">uint(s)</span></code> values that are exactly
representable in the target type can implicit convert to <code class="docutils literal notranslate"><span class="pre">int(t)</span></code>
and <code class="docutils literal notranslate"><span class="pre">uint(t)</span></code> regardless of the values of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code> <code class="docutils literal notranslate"><span class="pre">real(s)</span></code> that is exactly representable in the target
type can implicitly convert to <code class="docutils literal notranslate"><span class="pre">real(t)</span></code> or to <code class="docutils literal notranslate"><span class="pre">complex(t)</span></code>
regardless of the values of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code> <code class="docutils literal notranslate"><span class="pre">imag(s)</span></code> that is exactly representable in the target
type can implicitly convert to <code class="docutils literal notranslate"><span class="pre">imag(t)</span></code> or to <code class="docutils literal notranslate"><span class="pre">complex(t)</span></code>
regardless of the values of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code> <code class="docutils literal notranslate"><span class="pre">complex(s)</span></code> that is exactly representable in the target
type can implicitly convert to <code class="docutils literal notranslate"><span class="pre">complex(t)</span></code>.</p></li>
</ul>
</div></blockquote>
<p>As with the implicit numeric conversions, integral <code class="docutils literal notranslate"><span class="pre">param</span></code> values can
implicitly convert:</p>
<blockquote>
<div><ul class="simple">
<li><p>to <code class="docutils literal notranslate"><span class="pre">uint</span></code> of matching or greater size or to <code class="docutils literal notranslate"><span class="pre">real</span></code></p></li>
<li><p>or, to <code class="docutils literal notranslate"><span class="pre">complex</span></code> of any size.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="implicit-range-conversions">
<span id="id3"></span><h3>Implicit Range Conversions<a class="headerlink" href="#implicit-range-conversions" title="Permalink to this headline">¶</a></h3>
<p>Implicit conversions among range types are allowed when all values
representable in the source type can also be represented in the target
type, retaining their full precision. In particular, an implicit
conversion is allowed when:</p>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">idxType</span></code> of the source can be implicitly converted
to the <code class="docutils literal notranslate"><span class="pre">idxType</span></code> of the target,</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">bounds</span></code> of the source and the target are the same, and</p></li>
<li><p>one of the following holds:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">strides</span></code> of the source and the target are the same,</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">strides</span></code> of the target is <code class="docutils literal notranslate"><span class="pre">any</span></code>,</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">strides</span></code> of the target is <code class="docutils literal notranslate"><span class="pre">positive</span></code>
and the <code class="docutils literal notranslate"><span class="pre">strides</span></code> of the source is <code class="docutils literal notranslate"><span class="pre">one</span></code>, or</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">strides</span></code> of the target is <code class="docutils literal notranslate"><span class="pre">negative</span></code>
and the <code class="docutils literal notranslate"><span class="pre">strides</span></code> of the source is <code class="docutils literal notranslate"><span class="pre">negOne</span></code>.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="implicit-class-conversions">
<span id="id4"></span><h3>Implicit Class Conversions<a class="headerlink" href="#implicit-class-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>An expression of class type can be implicitly converted to:</dt><dd><ul class="simple">
<li><p>to a parent class type,</p></li>
<li><p>to a nilable type, or</p></li>
<li><p>to the borrow type.</p></li>
</ul>
</dd>
</dl>
<p>Any combination of these three conversions is allowed.</p>
<p>The value <code class="docutils literal notranslate"><span class="pre">nil</span></code> can be implicitly converted to any nilable class type.</p>
<p>Conversion to a parent class type or to a nilable type is a subtype
conversion and is discussed in the next section
(<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>).</p>
<p>Class types can be converted to the corresponding <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> type. For
example, <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code> can be implicitly converted to <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>, and
<code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C?</span></code> can be implicitly converted to <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code>. This
coercion is equivalent to calling the <code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method.
See <a class="reference internal" href="classes.html#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a>.  For example:</p>
<blockquote>
<div><p><em>Example (implicit-conversion-to-borrow.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// equivalent to f(c.borrow())</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="implicit-subtype-conversions">
<span id="implicit-generic-type-conversions"></span><span id="implicit-type-arg-conversions"></span><span id="subtype-arg-conversions"></span><span id="subtype"></span><h3>Implicit Subtype Conversions<a class="headerlink" href="#implicit-subtype-conversions" title="Permalink to this headline">¶</a></h3>
<p>An implicit subtype conversion is allowed when the source type is a
subtype of the target type.</p>
<p>Given any two types <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code>, the type <code class="docutils literal notranslate"><span class="pre">T1</span></code> is considered to be a
subtype of a type <code class="docutils literal notranslate"><span class="pre">T2</span></code> if:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T2</span></code> is a generic type (<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>) and <code class="docutils literal notranslate"><span class="pre">T1</span></code> is an
instantiation that type</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T1</span></code> is a class type that inherits from the class <code class="docutils literal notranslate"><span class="pre">T2</span></code>
(<a class="reference internal" href="classes.html#inheritance"><span class="std std-ref">Inheritance</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T1</span></code> is a non-nilable class type (e.g. <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>) and <code class="docutils literal notranslate"><span class="pre">T2</span></code> is
the nilable version of the same class type (e.g. <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code>)
(<a class="reference internal" href="classes.html#nilable-classes"><span class="std std-ref">Nilable Class Types</span></a>)</p></li>
<li><p>or a combination of the above.</p></li>
</ul>
</div></blockquote>
<p>The below examples use <a class="reference internal" href="../../modules/standard/Types.html#Types.isSubtype" title="Types.isSubtype"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">isSubtype</span></code></a> to demonstrate
when one type is a subtype of another.</p>
<blockquote>
<div><p><em>Example (not-a-subtype.chpl)</em></p>
<p>The following code snippet demonstrates that <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> is not a
subtype of <code class="docutils literal notranslate"><span class="pre">int</span></code>. Note that, even though an <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> value can be
implicitly converted to <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> is not a subtype of
<code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">isSubtype</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// evaluates to false</span>
</pre></div>
</div>
<p><em>Example (subtype-int8-integral.chpl)</em></p>
<p>However, <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> is a subtype of the generic type <code class="docutils literal notranslate"><span class="pre">integral</span></code>
according to the first rule above (<a class="reference internal" href="generics.html#built-in-generic-types"><span class="std std-ref">Built-in Generic Types</span></a>).</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">isSubtype</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">integral</span><span class="p">);</span> <span class="c1">// evaluates to true</span>
</pre></div>
</div>
<p><em>Example (subtype-pass-int8-integral.chpl)</em></p>
<p>Since <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">integral</span></code>, the type <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> can
be passed to the type argument <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">integral</span></code>
(<a class="reference internal" href="procedures.html#legal-argument-mapping"><span class="std std-ref">Legal Argument Mapping</span></a>). As a result the following program
will compile:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span> <span class="nx">integral</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
</pre></div>
</div>
<p><em>Example (subtype-parent-class.chpl)</em></p>
<p>This example demonstrates that <code class="docutils literal notranslate"><span class="pre">ChildClass</span></code> is a subtype of
<code class="docutils literal notranslate"><span class="pre">ParentClass</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ParentClass</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">ChildClass</span> <span class="p">:</span> <span class="nx">ParentClass</span> <span class="p">{</span> <span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">isSubtype</span><span class="p">(</span><span class="nx">ChildClass</span><span class="p">,</span> <span class="nx">ParentClass</span><span class="p">));</span> <span class="c1">// outputs true</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">isSubtype</span><span class="p">(</span><span class="k">borrowed</span> <span class="nx">ChildClass</span><span class="p">,</span> <span class="k">borrowed</span> <span class="nx">ParentClass</span><span class="p">));</span> <span class="c1">// outputs true</span>

<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span> <span class="nx">ParentClass</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">ChildClass</span><span class="p">);</span> <span class="c1">// implicit subtype conversion</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">ParentClass</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">g</span><span class="p">(</span><span class="k">borrowed</span> <span class="nx">ChildClass</span><span class="p">);</span> <span class="c1">// implicit subtype conversion</span>

<span class="c1">// The implicit subtype conversion can also apply to non-type arguments:</span>
<span class="k">proc</span> <span class="nf">h</span><span class="p">(</span><span class="kd">in</span> <span class="nx">arg</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">ParentClass</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">h</span><span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">ChildClass</span><span class="p">());</span> <span class="c1">// implicit subtype conversion</span>
</pre></div>
</div>
<p><em>Example (subtype-nilable.chpl)</em>.</p>
<p>This example shows that a non-nilable class type is a subtype of a
nilable class type with the same management.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">isSubtype</span><span class="p">(</span><span class="nx">C</span><span class="p">,</span> <span class="nx">C</span><span class="p">?));</span> <span class="c1">// outputs true</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">isSubtype</span><span class="p">(</span><span class="k">owned</span> <span class="nx">C</span><span class="p">,</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?));</span> <span class="c1">// outputs true</span>
</pre></div>
</div>
<p><em>Example (subtype-three.chpl)</em>.</p>
<p>This example demonstrates a combination of all three rules. Note that
<code class="docutils literal notranslate"><span class="pre">ParentClass</span></code> indicates a generic memory management strategy
(<a class="reference internal" href="classes.html#class-types"><span class="std std-ref">Class Types</span></a>).</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ParentClass</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">ChildClass</span> <span class="p">:</span> <span class="nx">ParentClass</span> <span class="p">{</span> <span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">isSubtype</span><span class="p">(</span><span class="nx">ChildClass</span><span class="p">,</span> <span class="nx">ParentClass</span><span class="p">?));</span> <span class="c1">// outputs true</span>

<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span> <span class="nx">ParentClass</span><span class="p">?)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">ChildClass</span><span class="p">);</span> <span class="c1">// uses implicit subtype conversion</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="kd">in</span> <span class="nx">arg</span><span class="p">:</span> <span class="nx">ParentClass</span><span class="p">?)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">g</span><span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">ChildClass</span><span class="p">());</span> <span class="c1">// uses implicit subtype conversion</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="implicit-conversions-for-initialization-and-assignment">
<span id="implicit-conversion-init-assign"></span><h3>Implicit Conversions for Initialization and Assignment<a class="headerlink" href="#implicit-conversions-for-initialization-and-assignment" title="Permalink to this headline">¶</a></h3>
<p>An implicit conversion for initialization or assignment occurs at each of
the following program locations:</p>
<ul class="simple">
<li><p>In an assignment, the expression on the right-hand side of the
assignment is converted to the type of the expression on the
left-hand side of the assignment.</p></li>
<li><p>In a variable or field declaration that is not a ref variable,
the initializing expression is converted to the type of the variable
or field. The initializing expression is the right-hand side of the
<code class="docutils literal notranslate"><span class="pre">=</span></code> in the declaration, if present, or in the field initialization
statement in an initializer.</p></li>
<li><p>The return or yield expression within a function without a <code class="docutils literal notranslate"><span class="pre">ref</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent is converted to the return type of that
function.</p></li>
<li><p>For a call to a function with a formal argument with <code class="docutils literal notranslate"><span class="pre">out</span></code> or
<code class="docutils literal notranslate"><span class="pre">inout</span></code> intent. The value of the formal argument is converted to the
type of the corresponding actual argument when setting that actual
with assignment or initialization (see <a class="reference internal" href="procedures.html#the-out-intent"><span class="std std-ref">The Out Intent</span></a>).</p></li>
</ul>
<p>Implicit conversions for initialization or assignment are allowed between
numeric and boolean types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>), numeric
types in the special case when the expression’s value is a compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>), ranges
(<a class="reference internal" href="#implicit-range-conversions"><span class="std std-ref">Implicit Range Conversions</span></a>), class types
(<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>), and for generic target types
(<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>).</p>
<p>In addition, these implicit conversions can be defined for record types
by implementing <code class="docutils literal notranslate"><span class="pre">init=</span></code> and possibly the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator between two
types as described in <a class="reference internal" href="records.html#advanced-copy-initialization"><span class="std std-ref">Advanced Copy Initialization</span></a> and
<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>.  <code class="docutils literal notranslate"><span class="pre">init=</span></code> will be called for initialization
as described in <a class="reference internal" href="variables.html#split-initialization"><span class="std std-ref">Split Initialization</span></a> and the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator will
be invoked for other uses of assignment.</p>
<p>In the event that an <code class="docutils literal notranslate"><span class="pre">=</span></code> overload is provided to support assignment
between two types, the compiler will check that a corresponding <code class="docutils literal notranslate"><span class="pre">init=</span></code>
also exists and emit an error if not.  Additionally, if <code class="docutils literal notranslate"><span class="pre">init=</span></code> is
provided to initialize one type from another, the corresponding <code class="docutils literal notranslate"><span class="pre">:</span></code>
overload must also exist. See also <a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a> for more
information on the <code class="docutils literal notranslate"><span class="pre">:</span></code> operator. It is possible to provide <code class="docutils literal notranslate"><span class="pre">:</span></code>
without <code class="docutils literal notranslate"><span class="pre">init=</span></code> or to provide <code class="docutils literal notranslate"><span class="pre">init=</span></code> without <code class="docutils literal notranslate"><span class="pre">=</span></code>.</p>
<blockquote>
<div><p><em>Example (implementing-assignment.chpl)</em></p>
<p>Suppose that we have defined a record type to wrap an integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">myInteger</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">intValue</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We might wish to support assignments setting a <code class="docutils literal notranslate"><span class="pre">myInteger</span></code> from
<code class="docutils literal notranslate"><span class="pre">int</span></code>. In that event, we can provide the following functions:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">operator</span> <span class="nf">=</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">lhs</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lhs</span><span class="p">.</span><span class="nx">intValue</span> <span class="o">=</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">myInteger.init</span><span class="o">=</span><span class="p">(</span><span class="nx">rhs</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">intValue</span> <span class="o">=</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">operator</span> <span class="nf">:</span><span class="p">(</span><span class="nx">from</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">toType</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tmp</span><span class="p">:</span> <span class="nx">myInteger</span> <span class="o">=</span> <span class="nx">from</span><span class="p">;</span> <span class="c1">// invoke the init= above</span>
  <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since we defined <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">=</span></code>, it is necessary to also define
<code class="docutils literal notranslate"><span class="pre">init=</span></code> and <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">:</span></code> between these types.</p>
<p>We can invoke these functions like this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nx">myInteger</span><span class="p">;</span>  <span class="c1">// cast -- invokes operator :</span>

<span class="kd">var</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">myInteger</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// initialization -- invokes init=</span>

<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">;</span>
<span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>                <span class="c1">// split-initialization -- invokes init=</span>

<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myInteger</span><span class="p">();</span>
<span class="nx">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>                <span class="c1">// assignment -- invokes operator =</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="implicit-conversions-for-function-calls">
<span id="implicit-conversion-call"></span><h3>Implicit Conversions for Function Calls<a class="headerlink" href="#implicit-conversions-for-function-calls" title="Permalink to this headline">¶</a></h3>
<p>An implicit conversion for a function call - also called a <em>coercion</em> -
occurs when the actual argument of a function call is converted to the
type of the corresponding formal argument, if the formal’s intent is
<code class="docutils literal notranslate"><span class="pre">param</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span></code>, or the default intent.</p>
<p>Implicit conversions for function calls are allowed between numeric
and boolean types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>), numeric types
in the special case when the expression’s value is a compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>),
ranges (<a class="reference internal" href="#implicit-range-conversions"><span class="std std-ref">Implicit Range Conversions</span></a>), class
types (<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>), and for generic target
types (<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>).</p>
<p>Additionally, an implicit conversion for a function call occurs when the
actual type is a subtype of the formal type. This rule applies to <code class="docutils literal notranslate"><span class="pre">in</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, and <code class="docutils literal notranslate"><span class="pre">type</span></code> intent formals and includes
generic formal types. See <a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>.</p>
<p>Implicit conversions are not applied for actual arguments passed to
<code class="docutils literal notranslate"><span class="pre">ref</span></code> formal arguments.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent, subtype conversions can be allowed while
keeping the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> formal referring to the original actual
argument’s value. However, this feature is still under discussion.</p>
<p><em>Open issue</em>.</p>
<p>Should Chapel allow user-defined implicit conversions for function
calls?  If so, how would the user define them?</p>
</div></blockquote>
</div>
<div class="section" id="implicit-conversions-for-conditionals">
<span id="implicit-statement-bool-conversions"></span><span id="implicit-conversion-conditionals"></span><h3>Implicit Conversions for Conditionals<a class="headerlink" href="#implicit-conversions-for-conditionals" title="Permalink to this headline">¶</a></h3>
<p>An implicit conversion for a conditional occurs for the condition of:</p>
<blockquote>
<div><ul class="simple">
<li><p>a conditional expression,</p></li>
<li><p>a conditional statement,</p></li>
<li><p>a while-do loop, or</p></li>
<li><p>a do-while loop.</p></li>
</ul>
</div></blockquote>
<p>In such a condition, the following implicit conversions to <code class="docutils literal notranslate"><span class="pre">bool</span></code> are
supported:</p>
<ul class="simple">
<li><p>An expression of integral type is taken to be <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is <code class="docutils literal notranslate"><span class="pre">0</span></code> and
is <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p></li>
<li><p>An expression of a class type is taken to be <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is <code class="docutils literal notranslate"><span class="pre">nil</span></code> and
is <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p></li>
</ul>
<p>Other standard types also allow implicit conversion for conditionals as
indicated in their documentation.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Should Chapel allow user-defined implicit conversions for
conditionals? If so, how would the user define them?</p>
</div></blockquote>
</div>
</div>
<div class="section" id="explicit-conversions">
<span id="id5"></span><h2>Explicit Conversions<a class="headerlink" href="#explicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>Explicit conversions require a cast in the code. Casts are defined
in <a class="reference internal" href="expressions.html#casts"><span class="std std-ref">Casts</span></a>. Explicit conversions are supported between more
types than implicit conversions, but not between all types.</p>
<p>The allowed explicit conversions are described in the following sections:</p>
<blockquote>
<div><ul class="simple">
<li><p>conversions among primitive numeric and bool types (see
<a class="reference internal" href="#explicit-numeric-conversions"><span class="std std-ref">Explicit Numeric Conversions</span></a>)</p></li>
<li><p>tuple to complex (see <a class="reference internal" href="#explicit-tuple-to-complex-conversion"><span class="std std-ref">Explicit Tuple to Complex Conversion</span></a>)</p></li>
<li><p>enumerated types (see <a class="reference internal" href="#explicit-enumeration-conversions"><span class="std std-ref">Explicit Enumeration Conversions</span></a>)</p></li>
<li><p>class conversions (see <a class="reference internal" href="#explicit-class-conversions"><span class="std std-ref">Explicit Class Conversions</span></a>)</p></li>
<li><p>range conversions (see <a class="reference internal" href="#explicit-range-conversions"><span class="std std-ref">Explicit Range Conversions</span></a>)</p></li>
<li><p>domain conversions (see <a class="reference internal" href="#explicit-domain-conversions"><span class="std std-ref">Explicit Domain Conversions</span></a>)</p></li>
<li><p>string to bytes conversions (see
<a class="reference internal" href="#explicit-string-to-bytes-conversions"><span class="std std-ref">Explicit String to Bytes Conversions</span></a>)</p></li>
<li><p>type to string conversions (see
<a class="reference internal" href="#explicit-type-to-string-conversions"><span class="std std-ref">Explicit Type to String Conversions</span></a>)</p></li>
<li><p>user-defined explicit conversions (see <a class="reference internal" href="#user-defined-casts"><span class="std std-ref">User-Defined Casts</span></a>).</p></li>
</ul>
</div></blockquote>
<p>The available explicit conversions are a superset of the available
implicit conversions for initialization and assignment
(<a class="reference internal" href="#implicit-conversion-init-assign"><span class="std std-ref">Implicit Conversions for Initialization and Assignment</span></a>), which, in turn, are a superset
of the implicit conversions for function calls.  As a result, the
implicit conversions described in <a class="reference internal" href="#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a> are also
available as explicit conversions.</p>
<p>An explicit conversion from a type to the same type is allowed for any
type. Such a conversion does not change the value of the expression.</p>
<div class="section" id="explicit-numeric-conversions">
<span id="id6"></span><h3>Explicit Numeric Conversions<a class="headerlink" href="#explicit-numeric-conversions" title="Permalink to this headline">¶</a></h3>
<p>Explicit conversions are allowed from <code class="docutils literal notranslate"><span class="pre">bool</span></code> or any numeric type to
<code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code>, and vice-versa.  When converting to <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
or <code class="docutils literal notranslate"><span class="pre">string</span></code> the result will hold the string <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>
for a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, or a representation of the expression’s numerical
value in other cases.  When converting from a <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>,
the reverse occurs, converting the represented value into a numerical
or <code class="docutils literal notranslate"><span class="pre">bool</span></code> value.  If the <code class="docutils literal notranslate"><span class="pre">string</span></code>/<code class="docutils literal notranslate"><span class="pre">bytes</span></code> does not represent a
legal value of the given type, an <code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code>
converts to the value 0 and <code class="docutils literal notranslate"><span class="pre">true</span></code> to 1.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, or <code class="docutils literal notranslate"><span class="pre">real</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, the
result is <code class="docutils literal notranslate"><span class="pre">false</span></code> if the number was equal to 0 and <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
<p>When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is converted to a larger <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value
is sign-extended to fit the new representation. When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is
converted to a larger <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value is zero-extended.
When an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> of
the same size, its binary representation is unchanged. When an <code class="docutils literal notranslate"><span class="pre">int</span></code>
or <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value is
truncated to fit the new representation.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em>.</p>
<p>There are several kinds of integer conversion which can result in a
loss of precision. Currently, the conversions are performed as
specified, and no error is reported. In the future, we intend to
improve type checking, so the user can be informed of potential
precision loss at compile time, and actual precision loss at run
time. Such cases include: When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">uint</span></code>
and the original value is negative; When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to
an <code class="docutils literal notranslate"><span class="pre">int</span></code> and the sign bit of the result is true; When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is
converted to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> and any of the truncated
bits differs from the original sign bit; When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted
to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> and any of the truncated bits is
true;</p>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>For integer conversions, the default behavior of a program should be
to produce a run-time error if there is a loss of precision. Thus,
cast expressions not only give rise to a value conversion at run
time, but amount to an assertion that the required precision is
preserved. Explicit conversion procedures would be available in the
run-time library so that one can perform explicit conversions that
result in a loss of precision but do not generate a run-time
diagnostic.</p>
</div></blockquote>
<p>When converting from a <code class="docutils literal notranslate"><span class="pre">real</span></code> type to a larger <code class="docutils literal notranslate"><span class="pre">real</span></code> type, the
represented value is preserved. When converting from a <code class="docutils literal notranslate"><span class="pre">real</span></code> type to
a smaller <code class="docutils literal notranslate"><span class="pre">real</span></code> type, the closest representation in the target type
is chosen. <a class="footnote-reference brackets" href="#id16" id="id7">1</a></p>
<p>When converting to a <code class="docutils literal notranslate"><span class="pre">real</span></code> type from an integer type, integer types
smaller than <code class="docutils literal notranslate"><span class="pre">int</span></code> are first converted to <code class="docutils literal notranslate"><span class="pre">int</span></code>. Then, the closest
representation of the converted value in the target type is chosen. The
exact behavior of this conversion is implementation-defined.</p>
<p>When converting from <code class="docutils literal notranslate"><span class="pre">real(k)</span></code> to <code class="docutils literal notranslate"><span class="pre">complex(2k)</span></code>, the original
value is copied into the real part of the result, and the imaginary part
of the result is set to zero. When converting from a <code class="docutils literal notranslate"><span class="pre">real(k)</span></code> to a
<code class="docutils literal notranslate"><span class="pre">complex(j)</span></code> such that <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">2k</span></code>, the conversion is
performed as if the original value is first converted to
<code class="docutils literal notranslate"><span class="pre">real(j/2)</span></code> and then to <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>The rules for converting from <code class="docutils literal notranslate"><span class="pre">imag</span></code> to <code class="docutils literal notranslate"><span class="pre">complex</span></code> are the same as
for converting from real, except that the imaginary part of the result
is set using the input value, and the real part of the result is set to
zero.</p>
</div>
<div class="section" id="explicit-tuple-to-complex-conversion">
<span id="id8"></span><h3>Explicit Tuple to Complex Conversion<a class="headerlink" href="#explicit-tuple-to-complex-conversion" title="Permalink to this headline">¶</a></h3>
<p>A two-tuple of numerical values may be converted to a <code class="docutils literal notranslate"><span class="pre">complex</span></code> value.
If the destination type is <code class="docutils literal notranslate"><span class="pre">complex(128)</span></code>, each member of the
two-tuple must be convertible to <code class="docutils literal notranslate"><span class="pre">real(64)</span></code>. If the destination type
is <code class="docutils literal notranslate"><span class="pre">complex(64)</span></code>, each member of the two-tuple must be convertible to
<code class="docutils literal notranslate"><span class="pre">real(32)</span></code>. The first member of the tuple becomes the real part of the
resulting complex value; the second member of the tuple becomes the
imaginary part of the resulting complex value.</p>
</div>
<div class="section" id="explicit-enumeration-conversions">
<span id="id9"></span><h3>Explicit Enumeration Conversions<a class="headerlink" href="#explicit-enumeration-conversions" title="Permalink to this headline">¶</a></h3>
<p>Explicit conversions are allowed from any enumerated type to <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
or <code class="docutils literal notranslate"><span class="pre">string</span></code> and vice-versa, including <code class="docutils literal notranslate"><span class="pre">param</span></code> conversions. For
enumerated types that are either <cite>concrete</cite> or <cite>semi-concrete</cite> (see
<a class="reference internal" href="types.html#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>), conversions are supported from the enum to
any numeric or boolean type, including <code class="docutils literal notranslate"><span class="pre">param</span></code> conversions.
Explicit conversions are also supported from integer values back to
concrete or semi-concrete enumerated types.</p>
<p>When converting from an enum to a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code>, the value
becomes the name of the enumerator.</p>
<p>When converting from a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code> to an enum, the result
is the constant whose name matches the source value. If no matching
value exists, an <code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
<p>For a semi-concrete enumerated type, if a numeric conversion is
attempted for a constant with no underlying integer value, it will
generate a compile-time error for a <code class="docutils literal notranslate"><span class="pre">param</span></code> conversion or throw an
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> otherwise.</p>
<p>When converting from an enum to an integer type, the value is first
converted to the enum’s underlying integer type and then to the target
type, following the rules above for converting between integers.</p>
<p>When converting from an enum to a real, imaginary, or complex type,
the value is first converted to the enum’s underlying integer type and
then to the target type.</p>
<p>When converting from an enum to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, the value is first
converted to the enum’s underlying integer type. If the result is
zero, the value of the <code class="docutils literal notranslate"><span class="pre">bool</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>; otherwise, it is
<code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>When converting from an integer value to an enum, the value is
converted to the enum’s underlying integer type and then converted to
the matching symbol.  If no symbol has the given integer value, an
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
</div>
<div class="section" id="explicit-class-conversions">
<span id="id10"></span><h3>Explicit Class Conversions<a class="headerlink" href="#explicit-class-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of static class type <code class="docutils literal notranslate"><span class="pre">C</span></code> can be explicitly converted to
a class type <code class="docutils literal notranslate"><span class="pre">D</span></code> provided that <code class="docutils literal notranslate"><span class="pre">C</span></code> is derived from <code class="docutils literal notranslate"><span class="pre">D</span></code> or <code class="docutils literal notranslate"><span class="pre">D</span></code> is
derived from <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>When at run time the source expression refers to an instance of <code class="docutils literal notranslate"><span class="pre">D</span></code> or
it subclass, its value is not changed. Otherwise, the cast fails and the
result depends on whether or not the destination type is nilable. If the
cast fails and the destination type is not nilable, the cast expression
will throw a <code class="docutils literal notranslate"><span class="pre">ClassCastError</span></code>. If the cast fails and the destination
type is nilable, as with <code class="docutils literal notranslate"><span class="pre">D?</span></code>, then the result will be <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>An expression of class type can also be converted to a different
nilability with a cast. For conversions from a nilable class type to a
non-nilable class type, the cast will throw a <code class="docutils literal notranslate"><span class="pre">NilClassError</span></code> if the
value was actually <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>In some cases a new variant of a class type needs to be computed that
has different nilability or memory management strategy. Supposing that
<code class="docutils literal notranslate"><span class="pre">T</span></code> represents a class type, then these casts may compute a new type:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span></code> - new management is <code class="docutils literal notranslate"><span class="pre">owned</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span></code> - new management <code class="docutils literal notranslate"><span class="pre">shared</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span></code> - new management <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span></code> - new management <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:class</span></code> - non-nilable type with specific concrete or generic
management from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:class?</span></code> - nilable type with specific concrete or generic
management from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">owned</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">owned</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>
management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> management</p></li>
</ul>
<p>The conversions in this subsection apply when the source is either an
expression or a type expression.</p>
</div>
<div class="section" id="explicit-range-conversions">
<span id="id11"></span><h3>Explicit Range Conversions<a class="headerlink" href="#explicit-range-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of a range type can be explicitly converted to another
range type with the same <code class="docutils literal notranslate"><span class="pre">bounds</span></code> parameter. Upon such conversion,
each non-infinite bound of the source is explicitly converted
to the target’s <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. The explicit conversion for ranges
is not allowed when the explicit conversion between their <code class="docutils literal notranslate"><span class="pre">idxTypes</span></code>
is not allowed.</p>
<p>The explicit conversion results in an error when the <code class="docutils literal notranslate"><span class="pre">stride</span></code> value
of the source is not legal for the target type. This may be the case
either because the source stride is not representable within the
target’s stride type or it is of the opposite sign than expected
by the target’s <code class="docutils literal notranslate"><span class="pre">strides</span></code> parameter.</p>
</div>
<div class="section" id="explicit-domain-conversions">
<span id="id12"></span><h3>Explicit Domain Conversions<a class="headerlink" href="#explicit-domain-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of a rectangular domain type can be explicitly converted
to another rectangular domain type of the same <code class="docutils literal notranslate"><span class="pre">rank</span></code>.
Such conversion is performed dimension-wise following the rules
for explicit range conversions (see <a class="reference internal" href="#explicit-range-conversions"><span class="std std-ref">Explicit Range Conversions</span></a>).</p>
</div>
<div class="section" id="explicit-string-to-bytes-conversions">
<span id="id13"></span><h3>Explicit String to Bytes Conversions<a class="headerlink" href="#explicit-string-to-bytes-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of <code class="docutils literal notranslate"><span class="pre">string</span></code> type can be explicitly converted to a
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>. However, the reverse is not possible as a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> can
contain arbitrary bytes. Instead, <code class="docutils literal notranslate"><span class="pre">bytes.decode()</span></code> method should be
used to produce a <code class="docutils literal notranslate"><span class="pre">string</span></code> from a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
</div>
<div class="section" id="explicit-type-to-string-conversions">
<span id="id14"></span><h3>Explicit Type to String Conversions<a class="headerlink" href="#explicit-type-to-string-conversions" title="Permalink to this headline">¶</a></h3>
<p>A type expression can be explicitly converted to a <code class="docutils literal notranslate"><span class="pre">string</span></code>. The
resultant <code class="docutils literal notranslate"><span class="pre">string</span></code> is the name of the type.</p>
<blockquote>
<div><p><em>Example (explicit-type-to-string.chpl)</em>.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
</pre></div>
</div>
<p>This program will print out the string <code class="docutils literal notranslate"><span class="pre">&quot;real(64)&quot;</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="user-defined-casts">
<span id="id15"></span><h3>User-Defined Casts<a class="headerlink" href="#user-defined-casts" title="Permalink to this headline">¶</a></h3>
<p>An explicit conversion can be defined by implementing <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">:</span></code> (see
also <a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>). An <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">:</span></code> should accept two
arguments: the value to convert and the type to convert it to.</p>
<blockquote>
<div><p><em>Example (implementing-cast.chpl)</em></p>
<p>Suppose that we have defined a record type to wrap an integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">myInteger</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">intValue</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We might wish to support casts from <code class="docutils literal notranslate"><span class="pre">myInteger</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>. In that
event, we can provide this cast operator:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">operator</span> <span class="nf">:</span><span class="p">(</span><span class="nx">from</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">toType</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">from</span><span class="p">.</span><span class="nx">intValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and we can invoke it using the cast syntax like this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myInteger</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p>When converting to a smaller real type, a loss of precision is
<em>expected</em>. Therefore, there is no reason to produce a run-time
diagnostic.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="variables.html" class="btn btn-neutral float-left" title="Variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="expressions.html" class="btn btn-neutral float-right" title="Expressions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>