<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Domains &mdash; Chapel Documentation 1.33</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Arrays" href="arrays.html" />
    <link rel="prev" title="Ranges" href="ranges.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.33
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.33";
$pagename = "language/spec/domains";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#introductory-material">Introductory Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-structures">Code Structures</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#composite-types">Composite Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="strings.html">Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="bytes.html">Bytes</a></li>
<li class="toctree-l3"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Domains</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#domain-overview">Domain Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-safety-with-respect-to-domains-and-arrays">Parallel Safety with respect to Domains (and Arrays)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#base-domain-types-and-values">Base Domain Types and Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-subdomain-types-and-values">Simple Subdomain Types and Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparse-subdomain-types-and-values">Sparse Subdomain Types and Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-index-types">Domain Index Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iteration-over-domains">Iteration Over Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domains-as-arguments">Domains as Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-operations">Domain Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#predefined-routines-on-domains">Predefined Routines on Domains</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="arrays.html">Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-programming">Generic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-programming">Parallel Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#distributed-programming">Distributed Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#additional-topics">Additional Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
      <li>Domains</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/language/spec/domains.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="domains">
<span id="chapter-domains"></span><h1>Domains<a class="headerlink" href="#domains" title="Permalink to this headline">¶</a></h1>
<p>A <em>domain</em> is a first-class representation of an index set. Domains are
used to specify iteration spaces, to define the size and shape of arrays
(<a class="reference internal" href="arrays.html#chapter-arrays"><span class="std std-ref">Arrays</span></a>), and to specify aggregate operations like
slicing. A domain can specify a single- or multi-dimensional rectangular
iteration space or represent a set of indices of a given type. Domains
can also represent a subset of another domain’s index set, using either
a dense or sparse representation. A domain’s indices may potentially be
distributed across multiple locales as described
in <a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">Distributions</span></a>, thus supporting global-view data
structures.</p>
<p>In the next subsection, we introduce the key characteristics of domains.
In <a class="reference internal" href="#base-domain-types-and-values"><span class="std std-ref">Base Domain Types and Values</span></a>, we discuss the types and
values that can be associated with a base domain.
In <a class="reference internal" href="#simple-subdomain-types-and-values"><span class="std std-ref">Simple Subdomain Types and Values</span></a>, we discuss the
types and values of simple subdomains that can be created from those
base domains. In <a class="reference internal" href="#sparse-subdomain-types-and-values"><span class="std std-ref">Sparse Subdomain Types and Values</span></a>, we
discuss the types and values of sparse subdomains. The remaining
sections describe the important manipulations that can be performed with
domains, as well as the predefined operators and functions defined for
domains.</p>
<div class="section" id="domain-overview">
<h2>Domain Overview<a class="headerlink" href="#domain-overview" title="Permalink to this headline">¶</a></h2>
<p>There are three <em>kinds</em> of domain, distinguished by their subset
dependencies: <em>base domains</em>, <em>subdomains</em> and <em>sparse subdomains</em>. A
base domain describes an index set spanning one or more dimensions. A
subdomain creates an index set that is a subset of the indices in a base
domain or another subdomain. Sparse subdomains are subdomains which can
represent sparse index subsets efficiently. Simple subdomains are
subdomains that are not sparse. These relationships can be represented
as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-type:
  base-domain-type
  simple-subdomain-type
  sparse-subdomain-type
</pre></div>
</div>
<p>Domains can be further classified according to whether they are
<em>regular</em> or <em>irregular</em>. A regular domain represents a rectangular
iteration space and can have a compact representation whose size is
independent of the number of indices. Rectangular domains, with the
exception of sparse subdomains, are regular.</p>
<p>An irregular domain can store an arbitrary set of indices of an
arbitrary but homogeneous index type. Irregular domains typically
require space proportional to the number of indices being represented.
All <em>associative</em> domain types and their subdomains (including sparse
subdomains) are irregular. Sparse subdomains of regular domains are also
irregular.</p>
<p>An index set can be either <em>ordered</em> or <em>unordered</em> depending on whether
its members have a well-defined order relationship. All regular domains
are ordered. All associative domains are unordered.</p>
<p>The type of a domain describes how a domain is represented and the
operations that can be performed upon it, while its value is the set of
indices it represents. In addition to storing a value, each domain
variable has an identity that distinguishes it from other domains that
may have the same type and value. This identity is used to define the
domain’s relationship with subdomains, index
types (<a class="reference internal" href="#index-types"><span class="std std-ref">Domain Index Types</span></a>), and
arrays (<a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>).</p>
<p>The runtime representation of a domain is controlled by its distribution,
see <a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">Distributions</span></a>.</p>
</div>
<div class="section" id="parallel-safety-with-respect-to-domains-and-arrays">
<span id="domain-and-array-parallel-safety"></span><h2>Parallel Safety with respect to Domains (and Arrays)<a class="headerlink" href="#parallel-safety-with-respect-to-domains-and-arrays" title="Permalink to this headline">¶</a></h2>
<p>Users must take care when applying operations to arrays and domains
concurrently from distinct tasks.  For instance, if one task is
modifying the index set of a domain while another task is operating
on either the domain itself or an array declared over that domain,
this represents a race and could have arbitrary consequences
including incorrect results and program crashes.  While making
domains and arrays safe with respect to such concurrent operations
would be appealing, Chapel’s current position is that such safety
guarantees would be prohibitively expensive.</p>
<p>Chapel arrays do support concurrent reads, writes, iterations, and
operations as long as their domains are not being modified
simultaneously.  Such operations are subject to Chapel’s memory
consistency model like any other memory accesses.  Similarly, tasks
may make concurrent queries and iterations on a domain as long as
another task is not simultaneously modifying the domain’s index
set.</p>
<p>By default, associative domains permit multiple tasks
to modify their index sets concurrently.  This adds some amount of
overhead to these operations.  If the user knows that all such
modifications will be done serially or in a parallel-safe context,
the overheads can be avoided by setting <code class="docutils literal notranslate"><span class="pre">parSafe</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code> in
the domain’s type declaration.  For example, the following
declaration creates an associative domain of strings where the
implementation will do nothing to ensure that simultaneous
modifications to the domain are parallel-safe:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">parSafe</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>As with any other domain type, it is not safe to access an
associative array while its domain is changing, regardless of
whether <code class="docutils literal notranslate"><span class="pre">parSafe</span></code> is set to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="base-domain-types-and-values">
<span id="id1"></span><h2>Base Domain Types and Values<a class="headerlink" href="#base-domain-types-and-values" title="Permalink to this headline">¶</a></h2>
<p>Base domain types can be classified as regular or irregular. Dense and
strided rectangular domains are regular domains. Irregular base domain
types include all of the associative domain types.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>base-domain-type:
  rectangular-domain-type
  associative-domain-type
</pre></div>
</div>
<p>These base domain types are discussed in turn in the following
subsections.</p>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">domain</span></code>, when not followed by parentheses, refers to
a generic type that can be instantiated with any domain type.
This type may also be written as <code class="docutils literal notranslate"><span class="pre">domain(?)</span></code>.</p>
<div class="section" id="rectangular-domains">
<h3>Rectangular Domains<a class="headerlink" href="#rectangular-domains" title="Permalink to this headline">¶</a></h3>
<p>Rectangular domains describe multidimensional rectangular index sets.
They are characterized by a tensor product of ranges and represent
indices that are tuples of an integral type. Because their index sets
can be represented using ranges, regular domain values typically require
only <span class="math notranslate nohighlight">\(O(1)\)</span> space.</p>
<div class="section" id="rectangular-domain-types">
<h4>Rectangular Domain Types<a class="headerlink" href="#rectangular-domain-types" title="Permalink to this headline">¶</a></h4>
<p>Rectangular domain types are parameterized by three things:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rank</span></code> a positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value indicating the number of dimensions
that the domain represents;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">idxType</span></code> a type member representing the index type for each
dimension; and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strides</span></code> a parameter of the type <a class="reference internal" href="ranges.html#strideKind" title="strideKind"><code class="xref chpl chpl-enum docutils literal notranslate"><span class="pre">strideKind</span></code></a> defining
what strides are allowed in each dimension.</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">rank</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the index type represented by a rectangular
domain is <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. Otherwise, the index type is the homogeneous
tuple type <code class="docutils literal notranslate"><span class="pre">rank*idxType</span></code>. If unspecified, <code class="docutils literal notranslate"><span class="pre">idxType</span></code> defaults to
<code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">strides</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">strideKind.one</span></code>.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>We may represent a rectangular domain’s index type as rank*idxType
even if rank is 1. This would eliminate a lot of code currently used
to support the special (rank == 1) case.</p>
</div></blockquote>
<p>The syntax of a rectangular domain type is summarized as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>rectangular-domain-type:
  &#39;domain&#39; ( named-expression-list )
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">named-expression-list</span></code> allows specifying the values of <code class="docutils literal notranslate"><span class="pre">rank</span></code>,
<code class="docutils literal notranslate"><span class="pre">idxType</span></code>, and <code class="docutils literal notranslate"><span class="pre">strides</span></code>.</p>
<blockquote>
<div><p><em>Example (typeFunctionDomain.chpl)</em>.</p>
<p>The following declarations both create an uninitialized rectangular
domain with three dimensions, with <code class="docutils literal notranslate"><span class="pre">int</span></code> indices:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D1</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nx">idxType</span><span class="o">=</span><span class="kt">int</span><span class="p">,</span> <span class="nx">strides</span><span class="o">=</span><span class="nx">strideKind</span><span class="p">.</span><span class="nx">one</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">D2</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="rectangular-domain-values">
<span id="id2"></span><h4>Rectangular Domain Values<a class="headerlink" href="#rectangular-domain-values" title="Permalink to this headline">¶</a></h4>
<p>Each dimension of a rectangular domain <code class="docutils literal notranslate"><span class="pre">d</span></code> is a range of type
<code class="docutils literal notranslate"><span class="pre">range(d.idxType,</span> <span class="pre">boundKind.both,</span> <span class="pre">d.strides)</span></code>. The index set
for a rank 1 domain is the set of indices described by its singleton
range. The index set for a rank <span class="math notranslate nohighlight">\(n\)</span> domain is the set of all
<code class="docutils literal notranslate"><span class="pre">n*idxType</span></code> tuples described by the tensor product of its ranges. When
expanded (as by an iterator), rectangular domain indices are ordered
according to the lexicographic order of their values. That is, the index
with the highest rank is listed first and changes most slowly.
This is also known as row-major ordering.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future</em></p>
<p>Domains defined using unbounded ranges may be supported.</p>
</div>
</div></blockquote>
<p>Literal rectangular domain values are represented by a comma-separated
list of range expressions of matching <code class="docutils literal notranslate"><span class="pre">idxType</span></code> enclosed in curly
braces:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>rectangular-domain-literal:
  { range-expression-list }

range-expression-list:
  range-expression
  range-expression, range-expression-list
</pre></div>
</div>
<p>The type of a rectangular domain literal is defined as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rank</span></code> = the number of range expressions in the literal;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">idxType</span></code> = the type of the range expressions;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strides</span></code> = the most narrow <a class="reference internal" href="ranges.html#strideKind" title="strideKind"><code class="xref chpl chpl-enum docutils literal notranslate"><span class="pre">strideKind</span></code></a> that can represent
all <code class="docutils literal notranslate"><span class="pre">strides</span></code> parameters of the range expressions.</p></li>
</ul>
<p>If the index types in the ranges differ and all of them can be promoted
to the same type, then that type is used as the <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. Otherwise,
the domain literal is invalid.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The expression <code class="docutils literal notranslate"><span class="pre">{1..5,</span> <span class="pre">1..5}</span></code> defines a rectangular domain with
type <code class="docutils literal notranslate"><span class="pre">domain(rank=2,</span></code> <code class="docutils literal notranslate"><span class="pre">idxType=int,</span></code> <code class="docutils literal notranslate"><span class="pre">strides=strideKind.one)</span></code>.
It is a <span class="math notranslate nohighlight">\(5 \times 5\)</span> domain with the indices:</p>
<div class="math notranslate nohighlight">
\[(1, 1), (1, 2), \ldots, (1, 5), (2, 1), \ldots (5, 5).\]</div>
</div></blockquote>
<p>A domain expression may contain bounds which are evaluated at runtime.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">D</span></code> is defined as a two-dimensional rectangular
domain with an index type of <code class="docutils literal notranslate"><span class="pre">2*int</span></code> and is initialized to contain
the set of indices <span class="math notranslate nohighlight">\((i,j)\)</span> for all <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such
that <span class="math notranslate nohighlight">\(i \in {1, 2, \ldots, n}\)</span> and
<span class="math notranslate nohighlight">\(j \in {1, 2, \ldots, n}\)</span>.</p>
</div></blockquote>
<p>The default value of a domain type is the <code class="docutils literal notranslate"><span class="pre">rank</span></code> default range values
for type:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">range(idxType,</span> <span class="pre">boundKind.both,</span> <span class="pre">strides)</span></code></p>
</div></blockquote>
<blockquote>
<div><p><em>Example (rectangularDomain.chpl)</em>.</p>
<p>The following creates a two-dimensional rectangular domain and then
uses this to declare an array. The array indices are iterated over
using the domain’s <code class="docutils literal notranslate"><span class="pre">dim()</span></code> method, and each element is filled with
some value. Then the array is printed out.</p>
<p>Thus, the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">D</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">for</span> <span class="nx">j</span> <span class="kd">in</span> <span class="nx">D</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="nx">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">j</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>produces</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>8 9 10 11 12 13 14
29 30 31 32 33 34 35
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="associative-domains">
<h3>Associative Domains<a class="headerlink" href="#associative-domains" title="Permalink to this headline">¶</a></h3>
<p>Associative domains represent an arbitrary set of indices of a given
type and can be used to describe sets or to create dictionary-style
arrays (hash tables). The type of indices of an associative domain, or
its <code class="docutils literal notranslate"><span class="pre">idxType</span></code>, can be any primitive type except <code class="docutils literal notranslate"><span class="pre">void</span></code> or any class
type.</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Associative domains and arrays are currently unstable.
Their functionality is likely to change in the future.
Chapel provides stable <cite>map</cite> and <cite>set</cite> data types
[see modules <a class="reference internal" href="../../modules/standard/Set.html#module-Set" title="Set: This module contains the implementation of Chapel's standard 'set' type."><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">Set</span></code></a> and <a class="reference internal" href="../../modules/standard/Map.html#module-Map" title="Map: Provides Chapel's standard ``map`` type for key-value storage."><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">Map</span></code></a>]
that can be used instead in many cases.</p>
</div>
</div></blockquote>
<div class="section" id="associative-domain-types">
<span id="id3"></span><h4>Associative Domain Types<a class="headerlink" href="#associative-domain-types" title="Permalink to this headline">¶</a></h4>
<p>An associative domain type is parameterized by <code class="docutils literal notranslate"><span class="pre">idxType</span></code>, the type of
the indices that it stores. The syntax is as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>associative-domain-type:
  &#39;domain&#39; ( associative-index-type )

associative-index-type:
  type-expression
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">associative-index-type</span></code> determines the <code class="docutils literal notranslate"><span class="pre">idxType</span></code> of the
associative domain type.</p>
<p>When an associative domain is used as the index set of an array, the
relation between the indices and the array elements can be thought of as
a map between the values of the index set and the elements stored in the
array.</p>
</div>
<div class="section" id="associative-domain-values">
<span id="id4"></span><h4>Associative Domain Values<a class="headerlink" href="#associative-domain-values" title="Permalink to this headline">¶</a></h4>
<p>An associative domain’s value is simply the set of all index values that
the domain describes. The iteration order over the indices of an
associative domain is undefined.</p>
<p>Specification of an associative domain literal value follows a similar
syntax as rectangular domain literal values. What differentiates the two
are the types of expressions specified in the comma separated list. Use
of values of a type other than ranges will result in the construction of
an associative domain.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>associative-domain-literal:
   { associative-expression-list }

associative-expression-list:
   non-range-expression
   non-range-expression, associative-expression-list

non-range-expression:
   expression
</pre></div>
</div>
<p>It is required that the types of the values used in constructing an
associative domain literal value be of the same type. If the types of
the indices does not match a compiler error will be issued.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future</em></p>
<p>Due to implementation of <code class="docutils literal notranslate"><span class="pre">==</span></code> over arrays it is currently not possible
to use arrays as indices within an associative domain.</p>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (associativeDomain.chpl)</em>.</p>
<p>The following example illustrates construction of an associative
domain containing string indices “bar” and “foo”. Note that due to
internal hashing of indices the order in which the values of the
associative domain are iterated is not the same as their
specification order.</p>
<p>This code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
</pre></div>
</div>
<p>produces the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>{foo, bar}
</pre></div>
</div>
</div></blockquote>
<p>If uninitialized, the default value of an associative domain is the
empty index set.</p>
<p>Indices can be added to or removed from an associative domain as
described in <a class="reference internal" href="#adding-and-removing-domain-indices"><span class="std std-ref">Adding and Removing Domain Indices</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="simple-subdomain-types-and-values">
<span id="id5"></span><h2>Simple Subdomain Types and Values<a class="headerlink" href="#simple-subdomain-types-and-values" title="Permalink to this headline">¶</a></h2>
<p>A subdomain is a domain whose indices are guaranteed to be a subset of
those described by another domain known as its <em>parent domain</em>. A
subdomain has the same type as its parent domain, and by default it
inherits the distribution of its parent domain. All domain types support
subdomains.</p>
<p>Simple subdomains are subdomains which are not sparse. Sparse subdomains
are discussed in the following section
(<a class="reference internal" href="#sparse-subdomain-types-and-values"><span class="std std-ref">Sparse Subdomain Types and Values</span></a>). A simple subdomain
inherits its representation (regular or irregular) from its base domain
(or base subdomain). A sparse subdomain is always irregular, even if its
base domain is regular.</p>
<p>In all other respects, the two kinds of subdomain behave identically. In
this specification, “subdomain” refers to both simple and sparse
subdomains, unless it is specifically distinguished as one or the other.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Subdomains are provided in Chapel for a number of reasons: to
facilitate the ability of the compiler or a reader to reason about
the inter-relationship of distinct domain variables; to support the
author’s ability to omit redundant distribution specifications; to
support the compiler’s ability to reason about the relative alignment
of multiple domains; and to improve the compiler’s ability to prove
away bounds checks for array accesses.</p>
</div></blockquote>
<div class="section" id="simple-subdomain-types">
<span id="id6"></span><h3>Simple Subdomain Types<a class="headerlink" href="#simple-subdomain-types" title="Permalink to this headline">¶</a></h3>
<p>A simple subdomain type is specified using the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>simple-subdomain-type:
  &#39;subdomain&#39; ( domain-expression )
</pre></div>
</div>
<p>This declares that <code class="docutils literal notranslate"><span class="pre">domain-expression</span></code> is the parent domain of this
subdomain type. A simple subdomain specifies a subdomain with the same
underlying representation as its base domain.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>An open semantic issue for subdomains is when a subdomain’s subset
property should be re-verified once its parent domain is reassigned
and whether this should be done aggressively or lazily.</p>
</div></blockquote>
</div>
<div class="section" id="simple-subdomain-values">
<h3>Simple Subdomain Values<a class="headerlink" href="#simple-subdomain-values" title="Permalink to this headline">¶</a></h3>
<p>The value of a simple subdomain is the set of all index values that the
subdomain describes.</p>
<p>The default value of a simple subdomain type is the same as the default
value of its parent’s type (<a class="reference internal" href="#rectangular-domain-values"><span class="std std-ref">Rectangular Domain Values</span></a>,
<a class="reference internal" href="#associative-domain-values"><span class="std std-ref">Associative Domain Values</span></a>).</p>
<p>A simple subdomain variable can be initialized or assigned to with a
tuple of values of the parent’s <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. Indices can also be added
to or removed from a simple subdomain as described in
<a class="reference internal" href="#adding-and-removing-domain-indices"><span class="std std-ref">Adding and Removing Domain Indices</span></a>. It is an error to
attempt to add an index to a subdomain that is not also a member of the
parent domain.</p>
</div>
</div>
<div class="section" id="sparse-subdomain-types-and-values">
<span id="id7"></span><h2>Sparse Subdomain Types and Values<a class="headerlink" href="#sparse-subdomain-types-and-values" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Sparse domains and arrays are currently unstable.
Their functionality is likely to change in the future.</p>
</div>
</div></blockquote>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>sparse-subdomain-type:
  &#39;sparse&#39; &#39;subdomain&#39;[OPT] ( domain-expression )
</pre></div>
</div>
<p>This declaration creates a sparse subdomain. <em>Sparse subdomains</em> are
irregular domains that describe an arbitrary subset of a domain, even if
the parent domain is a regular domain. Sparse subdomains are useful in
Chapel for defining <em>sparse arrays</em> in which a single element value
(usually “zero”) occurs frequently enough that it is worthwhile to avoid
storing it redundantly. The set difference between a sparse subdomain’s
index set and that of parent domain is the set of indices for which the
sparse array will store this replicated value.
See <a class="reference internal" href="arrays.html#sparse-arrays"><span class="std std-ref">Sparse Arrays</span></a> for details about sparse arrays.</p>
<div class="section" id="sparse-subdomain-types">
<h3>Sparse Subdomain Types<a class="headerlink" href="#sparse-subdomain-types" title="Permalink to this headline">¶</a></h3>
<p>Each root domain type has a unique corresponding sparse subdomain type.
Sparse subdomains whose parent domains are also sparse subdomains share
the same type.</p>
</div>
<div class="section" id="sparse-subdomain-values">
<span id="sparse-domain-values"></span><h3>Sparse Subdomain Values<a class="headerlink" href="#sparse-subdomain-values" title="Permalink to this headline">¶</a></h3>
<p>A sparse subdomain’s value is simply the set of all index values that
the domain describes. If the parent domain defines an iteration order
over its indices, the sparse subdomain inherits that order.</p>
<p>There is no literal syntax for a sparse subdomain. However, a variable
of a sparse subdomain type can be initialized using a tuple of values of
the parent domain’s index type.</p>
<p>The default value for a sparse subdomain value is the empty set.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code declares a two-dimensional dense domain <code class="docutils literal notranslate"><span class="pre">D</span></code>,
followed by a two dimensional sparse subdomain of <code class="docutils literal notranslate"><span class="pre">D</span></code> named
<code class="docutils literal notranslate"><span class="pre">SpsD</span></code>. Since <code class="docutils literal notranslate"><span class="pre">SpsD</span></code> is uninitialized, it will initially describe
an empty set of indices from <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">SpsD</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="domain-index-types">
<span id="index-types"></span><h2>Domain Index Types<a class="headerlink" href="#domain-index-types" title="Permalink to this headline">¶</a></h2>
<p>Each domain value has a corresponding compiler-provided <em>index type</em>
which can be used to represent values belonging to that domain’s index
set. Index types are described using the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>index-type:
  &#39;index&#39; ( domain-expression )
</pre></div>
</div>
<p>A variable with a given index type is constrained to take on only values
available within the domain on which it is defined. This restriction
allows the compiler to prove away the bound checking that code safety
considerations might otherwise require. Due to the subset relationship
between a base domain and its subdomains, a variable of an index type
defined with respect to a subdomain is also necessarily a valid index
into the base domain.</p>
<p>Since an index types are known to be legal for a given domain, it may
also afford the opportunity to represent that index using an optimized
format that doesn’t simply store the index variable’s value. This fact
could be used to support accelerated access to arrays declared over that
domain. For example, iteration over an index type could be implemented
using memory pointers and strides, rather than explicitly calculating
the offset of each index within the domain.</p>
<p>These potential optimizations may make it less expensive to index into
arrays using index type variables of their domains or subdomains.</p>
<p>In addition, since an index type is associated with a specific domain or
subdomain, it carries more semantic weight than a generic index. For
example, one could iterate over a rectangular domain with integer bounds
using an <code class="docutils literal notranslate"><span class="pre">int(n)</span></code> as the index variable. However, it would be more
precise to use a variable of the domain’s index type.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>An open issue for index types is what the semantics should be for an
index type value that is live across a modification to its domain’s
index set—particularly one that shrinks the index set. Our hypothesis
is that most stored indices will either have short lifespans or
belong to constant or monotonically growing domains. But these
semantics need to be defined nevertheless.</p>
</div></blockquote>
</div>
<div class="section" id="iteration-over-domains">
<span id="id8"></span><h2>Iteration Over Domains<a class="headerlink" href="#iteration-over-domains" title="Permalink to this headline">¶</a></h2>
<p>All domains support iteration via standard <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">forall</span></code>, and
<code class="docutils literal notranslate"><span class="pre">coforall</span></code> loops. These loops iterate over all of the indices that the
domain describes. If the domain defines an iteration order of its
indices, then the indices are visited in that order.</p>
<p>The type of the iterator variable for an iteration over a domain named
<code class="docutils literal notranslate"><span class="pre">D</span></code> is that domain’s index type, <code class="docutils literal notranslate"><span class="pre">index(D)</span></code>.</p>
</div>
<div class="section" id="domains-as-arguments">
<span id="domain-arguments"></span><h2>Domains as Arguments<a class="headerlink" href="#domains-as-arguments" title="Permalink to this headline">¶</a></h2>
<p>This section describes the semantics of passing domains as arguments to
functions.</p>
<div class="section" id="formal-arguments-of-domain-type">
<h3>Formal Arguments of Domain Type<a class="headerlink" href="#formal-arguments-of-domain-type" title="Permalink to this headline">¶</a></h3>
<p>When a domain value is passed to a formal argument of compatible domain
type by default intent, it is passed by reference in order to preserve
the domain’s identity.</p>
</div>
<div class="section" id="domain-promotion-of-scalar-functions">
<span id="id9"></span><h3>Domain Promotion of Scalar Functions<a class="headerlink" href="#domain-promotion-of-scalar-functions" title="Permalink to this headline">¶</a></h3>
<p>Domain values may be passed to a scalar function argument whose type
matches the domain’s index type. This results in a promotion of the
scalar function as defined in <a class="reference internal" href="data-parallelism.html#promotion"><span class="std std-ref">Promotion</span></a>.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>Given a function <code class="docutils literal notranslate"><span class="pre">foo()</span></code> that accepts real floating point values
and an associative domain <code class="docutils literal notranslate"><span class="pre">D</span></code> of type <code class="docutils literal notranslate"><span class="pre">domain(real)</span></code>, <code class="docutils literal notranslate"><span class="pre">foo</span></code> can
be called with <code class="docutils literal notranslate"><span class="pre">D</span></code> as its actual argument which will result in the
function being invoked for each value in the index set of <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example</em>.</p>
<p>Given an array <code class="docutils literal notranslate"><span class="pre">A</span></code> with element type <code class="docutils literal notranslate"><span class="pre">int</span></code> declared over a
one-dimensional domain <code class="docutils literal notranslate"><span class="pre">D</span></code> with <code class="docutils literal notranslate"><span class="pre">idxType</span></code> <code class="docutils literal notranslate"><span class="pre">int</span></code>, the array
elements can be assigned their corresponding index values by writing:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="o">=</span> <span class="nx">D</span><span class="p">;</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span><span class="nx">D</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="domain-operations">
<h2>Domain Operations<a class="headerlink" href="#domain-operations" title="Permalink to this headline">¶</a></h2>
<p>Chapel supplies predefined operators and functions that can be used to
manipulate domains. Unless otherwise noted, these operations are
applicable to a domain of any type, whether a base domain or a
subdomain.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-expression:
  domain-literal
  domain-name
  domain-assignment-expression
  domain-striding-expression
  domain-alignment-expression
  domain-slice-expression

domain-literal:
  rectangular-domain-literal
  associative-domain-literal

domain-assignment-expression:
  domain-name = domain-expression

domain-name:
  identifier
</pre></div>
</div>
<div class="section" id="domain-assignment">
<span id="id10"></span><h3>Domain Assignment<a class="headerlink" href="#domain-assignment" title="Permalink to this headline">¶</a></h3>
<p>All domain types support domain assignment.</p>
<p>Domain assignment is by value and causes the target domain variable to
take on the index set of the right-hand side expression. In practice,
the right-hand side expression is often another domain value; a tuple of
ranges (for regular domains); or a tuple of indices or a loop that
enumerates indices (for irregular domains). If the domain variable being
assigned was used to declare arrays, these arrays are reallocated as
discussed in <a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>.</p>
<p>When assigning between two rectangular domains, they must have the same
rank and assignment between the ranges in each dimension must be legal.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following three assignments show ways of assigning indices to a
sparse domain, <code class="docutils literal notranslate"><span class="pre">SpsD</span></code>. The first assigns the domain two index
values, <code class="docutils literal notranslate"><span class="pre">(1,1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(n,n)</span></code>. The second assigns the domain all of
the indices along the diagonal from
<code class="docutils literal notranslate"><span class="pre">(1,1)</span></code><span class="math notranslate nohighlight">\(\ldots\)</span><code class="docutils literal notranslate"><span class="pre">(n,n)</span></code>. The third invokes an iterator
that is written to <code class="docutils literal notranslate"><span class="pre">yield</span></code> indices read from a file named
“inds.dat”. Each of these assignments has the effect of replacing the
previous index set with a completely new set of values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">SpsD</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">));</span>
<span class="nx">SpsD</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">i</span><span class="p">);</span>
<span class="nx">SpsD</span> <span class="o">=</span> <span class="nx">readIndicesFromFile</span><span class="p">(</span><span class="s">&quot;inds.dat&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="domain-comparison">
<h3>Domain Comparison<a class="headerlink" href="#domain-comparison" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Equality operators are defined to test if two distributions
are equivalent or not:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">dist1</span> <span class="o">==</span> <span class="nx">dist2</span>
<span class="nx">dist1</span> <span class="o">!=</span> <span class="nx">dist2</span>
</pre></div>
</div>
<p>Or to test if two domains are equivalent or not:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">dom1</span> <span class="o">==</span> <span class="nx">dom2</span>
<span class="nx">dom1</span> <span class="o">!=</span> <span class="nx">dom2</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="domain-striding">
<span id="id11"></span><h3>Domain Striding<a class="headerlink" href="#domain-striding" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">by</span></code> operator can be applied to a rectangular domain value in
order to create a strided rectangular domain value. The right-hand
operand to the <code class="docutils literal notranslate"><span class="pre">by</span></code> operator is the stride value,
which can be either an integral value or an
integral tuple whose size matches the domain’s rank.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-striding-expression:
  domain-expression &#39;by&#39; expression
</pre></div>
</div>
<p>The type of the resulting domain is the same as the original domain,
with the <code class="docutils literal notranslate"><span class="pre">strides</span></code> parameter adjusted to the most narrow
<a class="reference internal" href="ranges.html#strideKind" title="strideKind"><code class="xref chpl chpl-enum docutils literal notranslate"><span class="pre">strideKind</span></code></a> that can represent all <code class="docutils literal notranslate"><span class="pre">strides</span></code> parameters
of the resulting domain’s ranges.
The resulting domain’s range in each dimension is obtained
by applying the <code class="docutils literal notranslate"><span class="pre">by</span></code> operator to the corresponding dimension
of the operand domain and the stride value if it is an integer,
or the corresponding component of the stride value if it is a tuple.</p>
</div>
<div class="section" id="domain-alignment">
<span id="id12"></span><h3>Domain Alignment<a class="headerlink" href="#domain-alignment" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">align</span></code> operator can be applied to a rectangular domain value in
order to create a domain with different alignment(s).
The right-hand operand to the <code class="docutils literal notranslate"><span class="pre">align</span></code> operator is the alignment value,
which can be either an integral
value or an integral tuple whose size matches the domain’s rank.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-alignment-expression:
  domain-expression &#39;align&#39; expression
</pre></div>
</div>
<p>The type of the resulting domain is the same as the original domain.
The resulting domain’s range in each dimension is obtained
by applying the <code class="docutils literal notranslate"><span class="pre">align</span></code> operator to the corresponding dimension
of the operand domain and the alignment value if it is an integer,
or the corresponding component of the alignment value if it is a tuple.</p>
</div>
<div class="section" id="domain-slicing">
<span id="id13"></span><h3>Domain Slicing<a class="headerlink" href="#domain-slicing" title="Permalink to this headline">¶</a></h3>
<p>Slicing is the application of an index set to a domain. It can be
written using either parentheses or square brackets. The index set can
be defined with either a domain or a list of ranges.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-slice-expression:
  domain-expression [ slicing-index-set ]
  domain-expression ( slicing-index-set )

slicing-index-set:
  domain-expression
  range-expression-list
</pre></div>
</div>
<p>The result of slicing, or a <em>slice</em>, is a new domain value that
represents the intersection of the index set of the domain being sliced
and the index set being applied. The type and distribution of the slice
match the domain being sliced.</p>
<p>Slicing can also be performed on an array, resulting in aliasing a
subset of the array’s elements (<a class="reference internal" href="arrays.html#array-slicing"><span class="std std-ref">Array Slicing</span></a>).</p>
<div class="section" id="domain-based-slicing">
<h4>Domain-based Slicing<a class="headerlink" href="#domain-based-slicing" title="Permalink to this headline">¶</a></h4>
<p>If the brackets or parentheses contain a domain value, its index set is
applied for slicing.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Can we say that it is an alias in the case of sparse/associative?</p>
</div></blockquote>
</div>
<div class="section" id="range-based-slicing">
<span id="id14"></span><h4>Range-based Slicing<a class="headerlink" href="#range-based-slicing" title="Permalink to this headline">¶</a></h4>
<p>When slicing rectangular domains or arrays, the brackets or parentheses
can contain a list of <code class="docutils literal notranslate"><span class="pre">rank</span></code> ranges. These ranges can either be
bounded or unbounded. When unbounded, they inherit their bounds from the
domain or array being sliced. The Cartesian product of the ranges’ index
sets is applied for slicing.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code declares a two dimensional rectangular domain
<code class="docutils literal notranslate"><span class="pre">D</span></code>, and then a number of subdomains of <code class="docutils literal notranslate"><span class="pre">D</span></code> by slicing into <code class="docutils literal notranslate"><span class="pre">D</span></code>
using bounded and unbounded ranges. The <code class="docutils literal notranslate"><span class="pre">InnerD</span></code> domain describes
the inner indices of D, <code class="docutils literal notranslate"><span class="pre">Col2OfD</span></code> describes the 2nd column of
<code class="docutils literal notranslate"><span class="pre">D</span></code>, and <code class="docutils literal notranslate"><span class="pre">AllButLastRow</span></code> describes all of <code class="docutils literal notranslate"><span class="pre">D</span></code> except for the
last row.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">},</span>
      <span class="nx">InnerD</span> <span class="o">=</span> <span class="nx">D</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="nx">Col2OfD</span> <span class="o">=</span> <span class="nx">D</span><span class="p">[</span><span class="o">..</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="mi">2</span><span class="p">],</span>
      <span class="nx">AllButLastRow</span> <span class="o">=</span> <span class="nx">D</span><span class="p">[</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="rank-change-slicing">
<span id="id15"></span><h4>Rank-Change Slicing<a class="headerlink" href="#rank-change-slicing" title="Permalink to this headline">¶</a></h4>
<p>For multidimensional rectangular domains and arrays, substituting
integral values for one or more of the ranges in a range-based slice
will result in a domain or array of lower rank.</p>
<p>The result of a rank-change slice on an array is an alias to a subset of
the array’s elements as described
in <a class="reference internal" href="arrays.html#rectangular-array-slicing"><span class="std std-ref">Rectangular Array Slicing</span></a>.</p>
<p>The result of rank-change slice on a domain is a subdomain of the domain
being sliced. The resulting subdomain’s type will be the same as the
original domain, but with a <code class="docutils literal notranslate"><span class="pre">rank</span></code> equal to the number of dimensions
that were sliced by ranges rather than integers.</p>
</div>
</div>
<div class="section" id="count-operator">
<span id="count-operator-domains"></span><h3>Count Operator<a class="headerlink" href="#count-operator" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> operator can be applied to dense rectangular domains with a
tuple argument whose size matches the rank of the domain (or optionally
an integer in the case of a 1D domain). The operator produces a new domain
obtained by applying the <code class="docutils literal notranslate"><span class="pre">#</span></code> operator to each of the component ranges
of the argument domain, with the same distribution as the argument.</p>
</div>
<div class="section" id="adding-and-removing-domain-indices">
<span id="id16"></span><h3>Adding and Removing Domain Indices<a class="headerlink" href="#adding-and-removing-domain-indices" title="Permalink to this headline">¶</a></h3>
<p>All irregular domain types support the ability to incrementally add and
remove indices from their index sets. This can either be done using
<code class="docutils literal notranslate"><span class="pre">add(i:idxType)</span></code> and <code class="docutils literal notranslate"><span class="pre">remove(i:idxType)</span></code> methods on a domain
variable or by using the <code class="docutils literal notranslate"><span class="pre">+=</span></code> and <code class="docutils literal notranslate"><span class="pre">-=</span></code> assignment operators. It is
legal to add the same index to an irregular domain’s index set twice,
but illegal to remove an index that does not belong to the domain’s
index set.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>These remove semantics seem dangerous in a parallel context; maybe
add flags to both the method versions of the call that say whether
they should balk or not? Or add exceptions…</p>
</div></blockquote>
<p>As with normal domain assignments, arrays declared in terms of a domain
being modified in this way will be reallocated as discussed
in <a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>.</p>
</div>
<div class="section" id="set-operations-on-associative-domains">
<h3>Set Operations on Associative Domains<a class="headerlink" href="#set-operations-on-associative-domains" title="Permalink to this headline">¶</a></h3>
<p>Associative domains (and arrays) support a number of operators for
set manipulations.  The supported set operators are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>+ , |</p></td>
<td><p>Union</p></td>
</tr>
<tr class="row-even"><td><p>&amp;</p></td>
<td><p>Intersection</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>Difference</p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>Symmetric Difference</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="predefined-routines-on-domains">
<h2>Predefined Routines on Domains<a class="headerlink" href="#predefined-routines-on-domains" title="Permalink to this headline">¶</a></h2>
<dl class="chpl data">
<dt class="sig sig-object chpl" id="ChapelDomain.defaultHashTableResizeThreshold">
<em class="property"><span class="pre">config</span> <span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">defaultHashTableResizeThreshold</span></span> <span class="pre">=</span> <span class="pre">0.5</span><a class="headerlink" href="#ChapelDomain.defaultHashTableResizeThreshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional value that specifies how full this domain can be
before requesting additional memory. The default value of
0.5 means that the map will not resize until the map is more
than 50% full. The acceptable values for this argument are
between 0 and 1, exclusive, meaning (0,1). A lower
<cite>defaultHashTableResizeThreshold</cite> value can potentially
improve indexing performance, since the table will likely
have fewer collisions, while a higher value can help save
memory.
Note that this value also impacts all of Chapel’s hash-based
data structures, such as <cite>set</cite> and <cite>map</cite>.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="ChapelDomain.domainDistIsLayout">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">domainDistIsLayout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.domainDistIsLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the distribution of <cite>d</cite> is a layout,
that is, all indices of <cite>d</cite> are owned by the current locale.</p>
</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="ChapelDomain.domain">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">domain</span></span> <span class="pre">:</span> <span class="pre">writeSerializable,</span> <span class="pre">readDeserializable</span><a class="headerlink" href="#ChapelDomain.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The domain type.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.distribution">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">distribution</span></span><a class="headerlink" href="#ChapelDomain.distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain map that implements this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.dist">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">dist</span></span><a class="headerlink" href="#ChapelDomain.dist" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.dist is deprecated, please use domain.distribution instead</p>
</div>
<p>Returns the domain map that implements this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.rank">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">rank</span></span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of dimensions in this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.idxType">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">idxType</span></span> <span class="pre">type</span><a class="headerlink" href="#ChapelDomain.idxType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type used to represent the indices of this domain.
For a multidimensional domain, this represents the
per-dimension index type.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.fullIdxType">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">fullIdxType</span></span> <span class="pre">type</span><a class="headerlink" href="#ChapelDomain.fullIdxType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full type used to represent the indices of this
domain.  For a 1D or associative domain, this is the same
as <a class="reference internal" href="#ChapelDomain.idxType" title="ChapelDomain.idxType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">idxType</span></code></a> above.  For a multidimensional domain, it
is <a class="reference internal" href="#ChapelDomain.rank" title="ChapelDomain.rank"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">rank</span></code></a> * <a class="reference internal" href="#ChapelDomain.idxType" title="ChapelDomain.idxType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">idxType</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.intIdxType">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">intIdxType</span></span> <span class="pre">type</span><a class="headerlink" href="#ChapelDomain.intIdxType" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘.intIdxType’ on domains is deprecated; please let us know if you’re relying on it</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">idxType</span></code> as represented by an integer type.  When
<code class="docutils literal notranslate"><span class="pre">idxType</span></code> is an enum type, this evaluates to <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Otherwise, it evaluates to <code class="docutils literal notranslate"><span class="pre">idxType</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.strides">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">strides</span></span> <span class="pre">param</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isRectangular()</span></em><a class="headerlink" href="#ChapelDomain.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ‘strides’ parameter of the domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.stridable">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">stridable</span></span> <span class="pre">param</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isRectangular()</span></em><a class="headerlink" href="#ChapelDomain.stridable" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.stridable is deprecated; use domain.strides instead</p>
</div>
<p>Returns true if this domain accepts some or any strides
other than 1.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.stride">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#ChapelDomain.stride" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the stride of the indices in this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.alignment">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">alignment</span></span><a class="headerlink" href="#ChapelDomain.alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the alignment of the indices in this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.targetLocales">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">targetLocales</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">const</span> <span class="pre">ref</span><a class="headerlink" href="#ChapelDomain.targetLocales" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of locales over which this domain
has been distributed.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.isEmpty">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isEmpty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#ChapelDomain.isEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the domain has no indices.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.size">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">size</span></span><span class="pre">:</span> <span class="pre">int</span><a class="headerlink" href="#ChapelDomain.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of indices in this domain as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.sizeAs">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">sizeAs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">integral</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span><a class="headerlink" href="#ChapelDomain.sizeAs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of indices in this domain as the specified type.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.dims">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">dims</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of ranges describing the bounds of a rectangular domain.
For a sparse domain, returns the bounds of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.dim">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a range representing the boundary of this
domain in a particular dimension.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.shape">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">shape</span></span><span class="pre">:</span> <span class="pre">rank*int</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isRectangular()</span> <span class="pre">||</span> <span class="pre">this.isSparse()</span></em><a class="headerlink" href="#ChapelDomain.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of <code class="docutils literal notranslate"><span class="pre">int</span></code> values representing the size of each
dimension.</p>
<p>For a sparse domain, this returns the shape of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.low">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">low</span></span><a class="headerlink" href="#ChapelDomain.low" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lowest index represented by a rectangular domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.high">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">high</span></span><a class="headerlink" href="#ChapelDomain.high" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the highest index represented by a rectangular domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.lowBound">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">lowBound</span></span><a class="headerlink" href="#ChapelDomain.lowBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain’s ‘pure’ low bound.  For example, given the
domain <code class="docutils literal notranslate"><span class="pre">{1..10</span> <span class="pre">by</span> <span class="pre">-2}</span></code>, <code class="docutils literal notranslate"><span class="pre">.lowBound</span></code> would return 1, whereas
<code class="docutils literal notranslate"><span class="pre">.low</span></code> would return 2 since it’s the lowest index represented
by the domain.  This routine is only supported on rectangular
domains.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.highBound">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">highBound</span></span><a class="headerlink" href="#ChapelDomain.highBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain’s ‘pure’ high bound.  For example, given the
domain <code class="docutils literal notranslate"><span class="pre">{1..10</span> <span class="pre">by</span> <span class="pre">2}</span></code>, <code class="docutils literal notranslate"><span class="pre">.highBound</span></code> would return 10,
whereas <code class="docutils literal notranslate"><span class="pre">.high</span></code> would return 9 since it’s the highest index
represented by the domain.  This routine is only supported on
rectangular domains.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.alignedLow">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">alignedLow</span></span><a class="headerlink" href="#ChapelDomain.alignedLow" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘.alignedLow’ is deprecated; please use ‘.low’ instead</p>
</div>
<p>Returns the low index in this domain factoring in alignment.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.alignedHigh">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">alignedHigh</span></span><a class="headerlink" href="#ChapelDomain.alignedHigh" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘.alignedHigh’ is deprecated; please use ‘.high’ instead</p>
</div>
<p>Returns the high index in this domain factoring in alignment.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.first">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">first</span></span><a class="headerlink" href="#ChapelDomain.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first index in this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.last">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">last</span></span><a class="headerlink" href="#ChapelDomain.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last index in this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.tryCreateArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">tryCreateArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#ChapelDomain.tryCreateArray" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>tryCreateArray() is subject to change in the future.</p>
</div>
<p>Invoking this method will attempt to create and return an array
declared over the domain instance. If there is not enough memory
to satisfy the allocation, an error will be thrown, allowing
the program to continue if handled, as opposed to halting and
thus stopping program execution.</p>
<p>This method will be most reliable in configurations that use a
fixed heap (e.g., when using <code class="docutils literal notranslate"><span class="pre">CHPL_GASNET_SEGMENT=large</span></code>), but
can be called in all configurations. In the case of a dynamic
heap, it is possible that overcommit will cause the array
allocation to succeed, even if there is not enough physical
memory to satisfy the allocation, which will then fail with a bus
error when attempting to access the array.</p>
<p>This method can be called on all domains that implement a
‘doiTryCreateArray’ method.</p>
<p>Throws an <cite>ArrayOomError</cite> when out of memory allocating elements.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">tryCreateArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em>, <em class="sig-param"><span class="pre">initExpr:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSubtype(t,</span> <span class="pre">_iteratorRecord)</span> <span class="pre">||</span> <span class="pre">isCoercible(t,</span> <span class="pre">eltType)</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>tryCreateArray() is subject to change in the future.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">tryCreateArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em>, <em class="sig-param"><span class="pre">initExpr:</span> <span class="pre">[?dom]</span> <span class="pre">?arrayEltType</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.rank</span> <span class="pre">==</span> <span class="pre">dom.rank</span> <span class="pre">&amp;&amp;</span> <span class="pre">isCoercible(arrayEltType,</span> <span class="pre">eltType)</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>tryCreateArray() is subject to change in the future.</p>
</div>
</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="ChapelDomain.unsafeAssignManager">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">unsafeAssignManager</span></span> <span class="pre">:</span> <span class="pre">contextManager</span><a class="headerlink" href="#ChapelDomain.unsafeAssignManager" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of this type is a context manager that can be used in
manage statements to resize arrays of non-default-initializable
element types after resizing their underlying domain.</p>
<p>Using an instance of this type in a manage statement will cause a
domain assignment to occur before executing the statement body. The
left-hand-side of the assignment is the receiver domain that had
<code class="docutils literal notranslate"><span class="pre">unsafeAssign()</span></code> called on it, while the right-hand-side is the
<cite>dom</cite> formal of the same call.</p>
<p>If the assignment adds new indices to the assigned domain, then
corresponding elements are added to arrays declared over it.
If an array’s element type is non-default-initializable, then any
newly added elements remain uninitialized.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">initialize()</span></code> method can be used within the manage statement
body to initialize new elements of non-default-initializable arrays
declared over the assigned domain.</p>
<p>The new elements of default-initializable arrays over the assigned
domain will be default-initialized. They can be set to desired
values as usual, for example using an assignment operator.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.checks">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">checks</span></span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.checks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this manager has runtime safety checks enabled.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.isElementInitialized">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isElementInitialized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arr:</span> <span class="pre">[?d],</span> <span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.isElementInitialized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the value at a given index in an array has
been initialized.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.initialize">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arr:</span> <span class="pre">[?d],</span> <span class="pre">idx,</span> <span class="pre">in</span> <span class="pre">value:</span> <span class="pre">arr.eltType</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Initializes a newly added array element at an index with a new value.</p>
<p>If <cite>checks</cite> is <code class="docutils literal notranslate"><span class="pre">true</span></code> and the array element at <cite>idx</cite> has already
been initialized, this method will halt. If <cite>checks</cite> is <code class="docutils literal notranslate"><span class="pre">false</span></code>,
then calling this method on an already initialized element will
result in undefined behavior.</p>
<p>It is an error if <cite>idx</cite> is not a valid index in <cite>arr</cite>.</p>
<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="ChapelDomain.newIndices">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">newIndices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.newIndices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Iterates over any new indices that will be added to this domain as a
result of unsafe assignment.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.unsafeAssign">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">unsafeAssign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">dom:</span> <span class="pre">domain</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">checks:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.unsafeAssign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an instance of <a class="reference internal" href="#ChapelDomain.unsafeAssignManager" title="ChapelDomain.unsafeAssignManager"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">unsafeAssignManager</span></code></a>.</p>
<p>The returned context manager can be used in a manage statement to
assign the indices of <cite>dom</cite> into the receiver domain. Within the body
of the manage statement, the manager can initialize elements of
non-default-initializable arrays declared over the receiver domain.</p>
<p>If <cite>checks</cite> is <code class="docutils literal notranslate"><span class="pre">true</span></code>, this method will guarantee that:</p>
<blockquote>
<div><ul class="simple">
<li><p>Newly added elements of any non-default-initializable arrays
declared over the receiver domain have been initialized by the
end of the manage statement</p></li>
<li><p>Newly added elements are only initialized once</p></li>
</ul>
</div></blockquote>
<p>These guarantees hold only for initialization done through calls to
the <code class="docutils literal notranslate"><span class="pre">initialize()</span></code> method on the context manager. Performing
any other operation on a newly added array element causes undefined
behavior until after <code class="docutils literal notranslate"><span class="pre">initialize()</span></code> has been called.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="o">..</span><span class="mi">0</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="k">shared</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">[</span><span class="k">new</span> <span class="k">shared</span> <span class="nx">C</span><span class="p">(</span><span class="mi">0</span><span class="p">)];</span>
<span class="nx">manage</span> <span class="nx">D</span><span class="p">.</span><span class="nx">unsafeAssign</span><span class="p">({</span><span class="mi">0</span><span class="o">..</span><span class="mi">1</span><span class="p">},</span> <span class="nx">checks</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span> <span class="k">as</span> <span class="nx">mgr</span> <span class="p">{</span>
  <span class="c1">// &#39;D&#39; has a new index &#39;1&#39;, so &#39;A&#39; has a new element at &#39;1&#39;,</span>
  <span class="c1">// which we need to initialize:</span>
  <span class="nx">mgr</span><span class="p">.</span><span class="nx">initialize</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="k">shared</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Checks are not currently supported for arrays of
non-default-initializable element types other than arrays of
non-nilable classes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dom</strong> – The domain to assign to the receiver</p></li>
<li><p><strong>checks</strong> – If this manager should provide runtime safety checks</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#ChapelDomain.unsafeAssignManager" title="ChapelDomain.unsafeAssignManager"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">unsafeAssignManager</span></code></a> for use in manage statements</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.clear">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all indices from this domain, leaving it empty.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.remove">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes index <code class="docutils literal notranslate"><span class="pre">idx</span></code> from this domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.add">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds index <code class="docutils literal notranslate"><span class="pre">idx</span></code> to this domain. This method is also available
as the <code class="docutils literal notranslate"><span class="pre">+=</span></code> operator.</p>
<p>The domain must be irregular.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.createIndexBuffer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">createIndexBuffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.createIndexBuffer" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>createIndexBuffer() is subject to change in the future.</p>
</div>
<p>Creates an index buffer which can be used for faster index addition.</p>
<p>For example, instead of:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">spsDom</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">someIndexIterator</span><span class="p">()</span> <span class="k">do</span>
  <span class="nx">spsDom</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>You can use <cite>SparseIndexBuffer</cite> for better performance:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">spsDom</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">idxBuf</span> <span class="o">=</span> <span class="nx">spsDom</span><span class="p">.</span><span class="nx">createIndexBuffer</span><span class="p">(</span><span class="nx">size</span><span class="o">=</span><span class="nx">N</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">someIndexIterator</span><span class="p">()</span> <span class="k">do</span>
  <span class="nx">idxBuf</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="nx">idxBuf</span><span class="p">.</span><span class="nx">commit</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
<p>The above snippet will create a buffer of size N indices, and will
automatically commit indices to the sparse domain as the buffer fills up.
Indices are also committed when the buffer goes out of scope.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>size</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">int</span></code></span> – Size of the buffer in number of indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.bulkAdd">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">bulkAdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">inds:</span> <span class="pre">[]</span> <span class="pre">(_value.rank*_value.idxType)</span></em>, <em class="sig-param"><span class="pre">dataSorted</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">isUnique</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">addOn</span> <span class="pre">=</span> <span class="pre">nilLocale</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isSparse()</span> <span class="pre">&amp;&amp;</span> <span class="pre">_value.rank</span> <span class="pre">&gt;</span> <span class="pre">1</span></em><a class="headerlink" href="#ChapelDomain.bulkAdd" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>bulkAdd() is subject to change in the future.</p>
</div>
<p>Adds indices in <code class="docutils literal notranslate"><span class="pre">inds</span></code> to this domain in bulk.</p>
<p>For sparse domains, an operation equivalent to this method is available
with the <code class="docutils literal notranslate"><span class="pre">+=</span></code> operator, where the right-hand-side is an array. However,
in that case, default values will be used for the flags <code class="docutils literal notranslate"><span class="pre">dataSorted</span></code> and
<code class="docutils literal notranslate"><span class="pre">isUnique</span></code>. This method is available because in
some cases, expensive operations can be avoided by setting those flags.
To do so, <code class="docutils literal notranslate"><span class="pre">bulkAdd</span></code> must be called explicitly (instead of <code class="docutils literal notranslate"><span class="pre">+=</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Right now, this method and the corresponding <code class="docutils literal notranslate"><span class="pre">+=</span></code> operator are
only available for sparse domains. In the future, we expect that
these methods will be available for all irregular domains.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> is a sentinel value to denote that the locale where this
addition should occur is unknown. We expect this to change in the
future.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method may make a copy of <code class="docutils literal notranslate"><span class="pre">inds</span></code> if the data is not sorted to
preserve the indices used. If the data is already sorted, it is
possible to avoid this extra copy by using <a class="reference internal" href="#ChapelDomain.bulkAddNoPreserveInds" title="ChapelDomain.bulkAddNoPreserveInds"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">bulkAddNoPreserveInds</span></code></a>,
which does not copy the indices and may modify <code class="docutils literal notranslate"><span class="pre">inds</span></code> in place.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inds</strong> – Indices to be added. <code class="docutils literal notranslate"><span class="pre">inds</span></code> must be an array of
<code class="docutils literal notranslate"><span class="pre">rank*idxType</span></code>, except for 1-D domains, where it must be
an array of <code class="docutils literal notranslate"><span class="pre">idxType</span></code>.</p></li>
<li><p><strong>dataSorted</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">bool</span></code></span> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> is sorted.</p></li>
<li><p><strong>isUnique</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">bool</span></code></span> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> has no duplicates.</p></li>
<li><p><strong>addOn</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">locale</span></code></span> – The locale where the indices should be added. Default value
is <code class="docutils literal notranslate"><span class="pre">nil</span></code> which indicates that locale is unknown or there
are more than one.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of indices added to the domain</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.bulkAddNoPreserveInds">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">bulkAddNoPreserveInds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">inds:</span> <span class="pre">[]</span> <span class="pre">(_value.rank*_value.idxType)</span></em>, <em class="sig-param"><span class="pre">dataSorted</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">isUnique</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">addOn</span> <span class="pre">=</span> <span class="pre">nilLocale</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isSparse()</span> <span class="pre">&amp;&amp;</span> <span class="pre">_value.rank</span> <span class="pre">&gt;</span> <span class="pre">1</span></em><a class="headerlink" href="#ChapelDomain.bulkAddNoPreserveInds" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>bulkAddNoPreserveInds() is subject to change in the future.</p>
</div>
<p>Adds indices in <code class="docutils literal notranslate"><span class="pre">inds</span></code> to this domain in bulk.</p>
<p>This is nearly identical to <a class="reference internal" href="#ChapelDomain.bulkAdd" title="ChapelDomain.bulkAdd"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">bulkAdd</span></code></a>. <a class="reference internal" href="#ChapelDomain.bulkAdd" title="ChapelDomain.bulkAdd"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">bulkAdd</span></code></a> may
make a copy of <code class="docutils literal notranslate"><span class="pre">inds</span></code> if the data is unsorted, whereas this method will
modify <code class="docutils literal notranslate"><span class="pre">inds</span></code> in place.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Right now, this method is only available for sparse domains.
In the future, we expect that this method will be available for all
irregular domains.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> is a sentinel value to denote that the locale where this
addition should occur is unknown. We expect this to change in the
future.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inds</strong> – Indices to be added. <code class="docutils literal notranslate"><span class="pre">inds</span></code> must be an array of
<code class="docutils literal notranslate"><span class="pre">rank*idxType</span></code>, except for 1-D domains, where it must be
an array of <code class="docutils literal notranslate"><span class="pre">idxType</span></code>.</p></li>
<li><p><strong>dataSorted</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">bool</span></code></span> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> is sorted.</p></li>
<li><p><strong>isUnique</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">bool</span></code></span> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> has no duplicates.</p></li>
<li><p><strong>addOn</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">locale</span></code></span> – The locale where the indices should be added. Default value
is <code class="docutils literal notranslate"><span class="pre">nil</span></code> which indicates that locale is unknown or there
are more than one.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of indices added to the domain</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.requestCapacity">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">requestCapacity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">capacity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.requestCapacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Requests space for a particular number of values in an
domain.</p>
<p>Currently only applies to associative domains.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.contains">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">idx:</span> <span class="pre">_value.idxType</span> <span class="pre">...rank</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this domain contains <code class="docutils literal notranslate"><span class="pre">idx</span></code>. Otherwise returns false.
For sparse domains, only indices with a value are considered
to be contained in the domain.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">other:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns true if this domain contains all the indices in the domain
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.orderToIndex">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">orderToIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">order:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">this.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">isNumericType(this.idxType)</span></em><a class="headerlink" href="#ChapelDomain.orderToIndex" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.orderToIndex() is unstable and its behavior may change in the future</p>
</div>
<p>Returns the <cite>ith</cite> index in the domain counting from 0.
For example, <code class="docutils literal notranslate"><span class="pre">{2..10</span> <span class="pre">by</span> <span class="pre">2}.orderToIndex(2)</span></code> would return <code class="docutils literal notranslate"><span class="pre">6</span></code>.</p>
<p>The order of a multidimensional domain follows its serial iterator.
For example, <code class="docutils literal notranslate"><span class="pre">{1..3,</span> <span class="pre">1..2}.orderToIndex(3)</span></code> would return <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Right now, this method supports only dense rectangular domains with
numeric indices</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>order</strong> – Order for which the corresponding index in the domain
has to be found.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Domain index for a given order in the domain.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.expand">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">rank*integral</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.expand" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.expand() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the current domain expanded by
<code class="docutils literal notranslate"><span class="pre">off(d)</span></code> in dimension <code class="docutils literal notranslate"><span class="pre">d</span></code> if <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is positive or
contracted by <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> in dimension <code class="docutils literal notranslate"><span class="pre">d</span></code> if <code class="docutils literal notranslate"><span class="pre">off(d)</span></code>
is negative.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.expand" title="ChapelRange.range.expand"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.expand</span></code></a> for further information about what
it means to expand a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">integral</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">rank</span> <span class="pre">&gt;</span> <span class="pre">1</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.expand() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the current domain expanded by
<code class="docutils literal notranslate"><span class="pre">off</span></code> in all dimensions if <code class="docutils literal notranslate"><span class="pre">off</span></code> is positive or contracted
by <code class="docutils literal notranslate"><span class="pre">off</span></code> in all dimensions if <code class="docutils literal notranslate"><span class="pre">off</span></code> is negative.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.expand" title="ChapelRange.range.expand"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.expand</span></code></a> for further information about what
it means to expand a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.exterior">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">exterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">rank*integral</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.exterior" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.exterior() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the exterior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> indices for each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>.
If <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative, compute the exterior from the low
bound of the dimension; if positive, compute the exterior
from the high bound.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.exterior" title="ChapelRange.range.exterior"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.exterior</span></code></a> for further information about what
it means to compute the exterior of a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">exterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">integral</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">rank</span> <span class="pre">!=</span> <span class="pre">1</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.exterior() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the exterior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off</span></code> indices for each dimension.
If <code class="docutils literal notranslate"><span class="pre">off</span></code> is negative, compute the exterior from the low
bound of the dimension; if positive, compute the exterior
from the high bound.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.exterior" title="ChapelRange.range.exterior"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.exterior</span></code></a> for further information about what
it means to compute the exterior of a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.interior">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">interior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">rank*integral</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.interior" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.interior() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the interior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> indices for each dimension
<code class="docutils literal notranslate"><span class="pre">d</span></code>. If <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative, compute the interior from
the low bound of the dimension; if positive, compute the
interior from the high bound.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.interior" title="ChapelRange.range.interior"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.interior</span></code></a> for further information about what
it means to compute the exterior of a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">interior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">integral</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">rank</span> <span class="pre">!=</span> <span class="pre">1</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.interior() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the interior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off</span></code> indices for each dimension.
If <code class="docutils literal notranslate"><span class="pre">off</span></code> is negative, compute the interior from the low
bound of the dimension; if positive, compute the interior
from the high bound.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.interior" title="ChapelRange.range.interior"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.interior</span></code></a> for further information about what
it means to compute the exterior of a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.translate">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">rank*integral</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.translate" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.translate() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the current domain translated by
<code class="docutils literal notranslate"><span class="pre">off(d)</span></code> in each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.translate" title="ChapelRange.range.translate"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.translate</span></code></a> for further information about
what it means to translate a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">off:</span> <span class="pre">integral</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">rank</span> <span class="pre">!=</span> <span class="pre">1</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.translate() is unstable and its behavior may change in the future</p>
</div>
<p>Returns a new domain that is the current domain translated by
<code class="docutils literal notranslate"><span class="pre">off</span></code> in each dimension.</p>
<p>See <a class="reference internal" href="ranges.html#ChapelRange.range.translate" title="ChapelRange.range.translate"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ChapelRange.range.translate()</span></code></a> for further information about
what it means to translate a range.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.localSlice">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">localSlice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">r</span> <span class="pre">...rank</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">chpl__isTupleOfRanges(r)</span> <span class="pre">&amp;&amp;</span> <span class="pre">!_value.isDefaultRectangular()</span></em><a class="headerlink" href="#ChapelDomain.localSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a local view of the sub-domain (slice) defined by the provided
range(s), halting if the slice contains elements that are not local.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">localSlice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a local view of the sub-domain (slice) defined by the provided
domain, halting if the slice contains elements that are not local.</p>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="ChapelDomain.sorted">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">sorted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">comparator:</span> <span class="pre">?t</span> <span class="pre">=</span> <span class="pre">chpl_defaultComparator()</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields the domain indices in sorted order.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.hasSingleLocalSubdomain">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasSingleLocalSubdomain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.hasSingleLocalSubdomain" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘hasSingleLocalSubdomain’ on domains is unstable and may change in the future</p>
</div>
<p>Returns true if the local subdomain can be represented as a single
domain. Otherwise returns false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.localSubdomain">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">localSubdomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">loc:</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">here</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.localSubdomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subdomain that is local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>loc</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">locale</span></code></span> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="ChapelDomain.localSubdomains">
<em class="property"><span class="pre">iter</span> </em><span class="sig-name descname"><span class="pre">localSubdomains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">loc:</span> <span class="pre">locale</span> <span class="pre">=</span> <span class="pre">here</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.localSubdomains" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘localSubdomains’ on domains is unstable and may change in the future</p>
</div>
<p>Yields the subdomains that are local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>loc</strong> : <span><code class="xref chpl chpl-chplref docutils literal notranslate"><span class="pre">locale</span></code></span> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.safeCast">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">safeCast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">chpl__isRectangularDomType(t)</span> <span class="pre">&amp;&amp;</span> <span class="pre">this.isRectangular()</span></em><a class="headerlink" href="#ChapelDomain.safeCast" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>domain.safeCast() is deprecated; instead consider using a cast ‘:’</p>
</div>
<p>Casts a rectangular domain to another rectangular domain type.
Ensures that the original domain’s stride is acceptable
by the target type.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.tryCast">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">tryCast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">domain</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelDomain.tryCast" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts a rectangular domain to a new rectangular domain type.
Throws an IllegalArgumentError when the original bounds and/or stride(s)
do not fit in the new idxType or when the original stride(s)
are not legal for the new <cite>strides</cite> parameter.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.isRectangular">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isRectangular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.isRectangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this domain is a rectangular.
Otherwise returns false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.isIrregular">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isIrregular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.isIrregular" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">d</span></code> is an irregular domain; e.g. is not rectangular.
Otherwise returns false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.isAssociative">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isAssociative</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.isAssociative" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">d</span></code> is an associative domain.
Otherwise returns false.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="ChapelDomain.isSparse">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">isSparse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">param</span><a class="headerlink" href="#ChapelDomain.isSparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">d</span></code> is a sparse domain. Otherwise returns false.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ranges.html" class="btn btn-neutral float-left" title="Ranges" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="arrays.html" class="btn btn-neutral float-right" title="Arrays" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>