<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IO &mdash; Chapel Documentation 1.33</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FormattedIO" href="IO/FormattedIO.html" />
    <link rel="prev" title="FileSystem" href="FileSystem.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.33
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.33";
$pagename = "modules/standard/IO";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Docs for Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../standard.html#automatic-modules">Automatic Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#data-structures">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#files-io">Files/IO</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="FileSystem.html">FileSystem</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">IO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-overview">I/O Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-rationale">Design Rationale</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-styles">I/O Styles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-filereader-and-filewriter-creation">Functions for fileReader and fileWriter Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races">Synchronization of fileReader and fileWriter Data and Avoiding Data Races</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performing-i-o-with-filereaders-and-filewriters">Performing I/O with FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-closing-filereaders-and-filewriters">Functions for Closing FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-stdin-filereader-and-stdout-and-stderr-filewriters">The <code class="docutils literal notranslate"><span class="pre">stdin</span></code> fileReader, and <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> fileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-transactions">I/O Transactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specifying-the-region-of-a-filereader-or-filewriter">Specifying the region of a FileReader or FileWriter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#locking-behavior-of-filereaders-and-filewriters">Locking Behavior of FileReaders and FileWriters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ensuring-successful-i-o">Ensuring Successful I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correspondence-with-c-i-o">Correspondence with C I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#io-functions-and-types">IO Functions and Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="JSON.html">JSON</a></li>
<li class="toctree-l3"><a class="reference internal" href="Path.html">Path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#language-support">Language Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#math-numerical">Math/Numerical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#parallelism-distributed-computing">Parallelism/Distributed Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#system-interoperability">System/Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#utilities">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages/index.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

  <p class="caption" role="heading"><span class="caption-text">Indexes</span></p>
  <ul>
    <li class="toctree-11"><a class="reference internal" href="../../chpl-modindex.html">Chapel Module Index</a></li>
    <li class="toctree-11"><a class="reference internal" href="../../genindex.html">Complete Docs Index</a></li>
  </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
      <li>IO</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/standard/IO.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <span class="target" id="module-IO"></span><div class="section" id="io">
<h1>IO<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Submodules</strong></p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
</ul>
</div>
<p>Support for a variety of kinds of input and output.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All Chapel programs automatically include <a class="reference internal" href="ChapelIO.html#ChapelIO.write" title="ChapelIO.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">write</span></code></a>,
<a class="reference internal" href="ChapelIO.html#ChapelIO.writeln" title="ChapelIO.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writeln</span></code></a> and <a class="reference internal" href="ChapelIO.html#ChapelIO.writef" title="ChapelIO.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writef</span></code></a>.  These symbols
can also be accessed using <code class="docutils literal notranslate"><span class="pre">IO.</span></code> as their qualified access prefix.</p>
</div>
<p>Input/output (I/O) facilities in Chapel include the types <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>,
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>; the constants <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stdin</span></code></a>,
<a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stderr</span></code></a>; the functions <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a>,
<a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a>, <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a>, <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a>,
<a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a>, <a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.write</span></code></a>, and many others.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please be aware, the IO Module documentation is under development and
currently contains some minor inconsistencies.</p>
</div>
<div class="section" id="i-o-overview">
<span id="about-io-overview"></span><h2>I/O Overview<a class="headerlink" href="#i-o-overview" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> in Chapel identifies a file in the underlying operating system.
Reads to a file are done via one or more fileReaders associated with the file
and writes to a file are done via one or more fileWriters.  Each
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> uses a buffer to provide sequential
read or write access to its file, optionally starting at an offset.</p>
<p>For example, the following program opens a file and writes an integer to it:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// open the file &quot;test-file.txt&quot; for writing, creating it if</span>
  <span class="c1">// it does not exist yet.</span>
  <span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">cw</span><span class="p">);</span>

  <span class="c1">// create a fileWriter starting at file offset 0</span>
  <span class="c1">// (start and end offsets can be specified when creating the</span>
  <span class="c1">// fileWriter)</span>
  <span class="kd">var</span> <span class="nx">myFileWriter</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">writer</span><span class="p">();</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>

  <span class="c1">// This function will write the human-readable text version of x;</span>
  <span class="c1">// binary I/O is also possible.</span>
  <span class="nx">myFileWriter</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

  <span class="c1">// Now test-file.txt contains:</span>
  <span class="c1">// 17</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Error</span> <span class="p">{</span>
  <span class="c1">// Generally speaking, the I/O functions throw errors.  Handling these</span>
  <span class="c1">// errors is application-dependent and is left out of this example for</span>
  <span class="c1">// brevity.  Please see the documentation for individual functions for more</span>
  <span class="c1">// details about errors that they can throw.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, the following program can be used to read the integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// open the file &quot;test-file.txt&quot; for reading only</span>
  <span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>

  <span class="c1">// create a fileReader starting at file offset 0</span>
  <span class="c1">// (start and end offsets can be specified when creating the</span>
  <span class="c1">// fileReader)</span>
  <span class="kd">var</span> <span class="nx">myFileReader</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">reader</span><span class="p">();</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

  <span class="c1">// Now read a textual integer. Note that the</span>
  <span class="c1">// fileReader.read function returns a bool to indicate</span>
  <span class="c1">// if it read something or if the end of the file</span>
  <span class="c1">// was reached before something could be read.</span>
  <span class="kd">var</span> <span class="nx">readSomething</span> <span class="o">=</span> <span class="nx">myFileReader</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Read integer &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="c1">// prints out:</span>
  <span class="c1">// Read integer 17</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Error</span> <span class="p">{</span>
  <span class="c1">// Generally speaking, the I/O functions throw errors.  Handling these</span>
  <span class="c1">// errors is application-dependent and is left out of this example for</span>
  <span class="c1">// brevity.  Please see the documentation for individual functions for more</span>
  <span class="c1">// details about errors that they can throw.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#IO.read" title="IO.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">read</span></code></a> functions allow one to read values into variables as
the following example demonstrates. It shows three ways to read values into
a pair of variables <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="cm">/* reading into variable expressions, returning</span>
<span class="cm">   true if the values were read, false on EOF */</span>
<span class="kd">var</span> <span class="nx">ok</span><span class="p">:</span><span class="kt">bool</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>

<span class="cm">/* reading via a single type argument */</span>
<span class="nx">x</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="nx">y</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="kt">real</span><span class="p">);</span>

<span class="cm">/* reading via multiple type arguments */</span>
<span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">real</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="design-rationale">
<h2>Design Rationale<a class="headerlink" href="#design-rationale" title="Permalink to this headline">¶</a></h2>
<p>Since fileReaders and fileWriters operate independently, concurrent I/O to the
same open file is possible without contending for locks.  Furthermore, since the
fileReader or fileWriter (and not the file) stores the current file offset, it
is straightforward to create programs that access the same open file in
parallel. Note that such parallel access is not possible in C when multiple
threads are using the same <code class="docutils literal notranslate"><span class="pre">FILE*</span></code> to write to different regions of a file
because of the race condition between <code class="docutils literal notranslate"><span class="pre">fseek</span></code> and <code class="docutils literal notranslate"><span class="pre">fwrite</span></code>. Because of these
issues, Chapel programmers wishing to perform I/O will need to know how to open
files as well as create fileReaders and fileWriters.</p>
</div>
<div class="section" id="i-o-styles">
<span id="about-io-styles"></span><h2>I/O Styles<a class="headerlink" href="#i-o-styles" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> is now unstable.
We are working on creating a full-featured replacement for it
but in the meantime the <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a> facilities are still
available to control formatting.</p>
</div>
<p>Reading and writing of Chapel’s basic types is regulated by an applicable
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>.  In particular, the I/O style controls whether binary or text
I/O should be performed. For binary I/O it specifies, for example, byte order
and string encoding. For text I/O it specifies string representation; the base,
field width and precision for numeric types; and so on.  Each fileReader or
fileWriter has an associated I/O style.  It applies to all read/write operations
on that fileReader or fileWriter, except when the program specifies explicitly
an I/O style for a particular read or write.</p>
<p>See the definition for the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> type. This type represents I/O
styles and provides details on formatting and other representation choices.</p>
<p>The default value of the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> type is undefined.  However, the
compiler-generated constructor is available.  It can be used to generate the
default I/O style, with or without modifications. In addition, the function
<a class="reference internal" href="#IO.defaultIOStyle" title="IO.defaultIOStyle"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">defaultIOStyle</span></code></a> will return the default I/O style just as <code class="docutils literal notranslate"><span class="pre">new</span>
<span class="pre">iostyle()</span></code> will.</p>
<p>The I/O style for an I/O operation can be provided through an optional
<code class="docutils literal notranslate"><span class="pre">style=</span></code> argument in a variety of places:</p>
<blockquote>
<div><ul class="simple">
<li><p>when performing the I/O, e.g. in calls to <a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.write</span></code></a> or
<a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a></p></li>
<li><p>when creating the fileReader with <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a></p></li>
<li><p>when creating the fileWriter <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a></p></li>
<li><p>or when creating the file with e.g. <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Note that <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a>, or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> will copy the file’s I/O
style if a <code class="docutils literal notranslate"><span class="pre">style=</span></code> argument is not provided. Also note that I/O functions on
fileReaders and fileWriters will by default use the I/O style stored with that
fileReader or fileWriter.</p>
<p>A fileReader’s I/O style may be retrieved using <a class="reference internal" href="#IO.fileReader._style" title="IO.fileReader._style"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader._style</span></code></a> and
set using <a class="reference internal" href="#IO.fileReader._set_style" title="IO.fileReader._set_style"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader._set_style</span></code></a>. A fileWriter’s I/O style may be
retrieved using <a class="reference internal" href="#IO.fileWriter._style" title="IO.fileWriter._style"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter._style</span></code></a> and set using
<a class="reference internal" href="#IO.fileWriter._set_style" title="IO.fileWriter._set_style"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter._set_style</span></code></a>. These functions should only be called while the
fileReader’s or fileWriter’s lock is held, however. See
<a class="reference internal" href="#about-io-filereader-filewriter-synchronization"><span class="std std-ref">Synchronization of fileReader and fileWriter Data and Avoiding Data Races</span></a> for more information on
fileReader and fileWriter locks.</p>
<p>As an example for specifying an I/O style, the code below specifies the minimum
width for writing numbers so array elements are aligned in the output:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="nx">MyArray</span><span class="p">,</span> <span class="k">new</span> <span class="nx">iostyle</span><span class="p">(</span><span class="nx">min_width</span><span class="o">=</span><span class="mi">10</span><span class="p">));</span>
</pre></div>
</div>
<p>I/O facilities in Chapel also include several other ways to control I/O
formatting. There is support for <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">formatted I/O</span></a>
with <a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileReader.readf" title="FormattedIO.fileReader.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileReader.readf</span></code></a> and
<a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileWriter.writef" title="FormattedIO.fileWriter.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileWriter.writef</span></code></a>.  Also note that record or class
implementations can provide custom functions implementing read or write
operations for that type (see <a class="reference internal" href="ChapelIO.html#readthis-writethis"><span class="std std-ref">The readThis() and writeThis() Methods</span></a>).</p>
</div>
<div class="section" id="files">
<span id="about-io-files"></span><h2>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h2>
<p>There are several functions that open a file and return a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>
including <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a>, <a class="reference internal" href="#IO.openTempFile" title="IO.openTempFile"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openTempFile</span></code></a>, <a class="reference internal" href="#IO.openMemFile" title="IO.openMemFile"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openMemFile</span></code></a>, the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> initializer that takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> argument, and the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> initializer that takes a <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a> argument.</p>
<p>Once a file is open, it is necessary to create associated fileReader(s) and/or
fileWriter(s) - see <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> and <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> - to read from
and/or write to the file.</p>
<p>Use the <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> function to explicitly synchronize the file to
ensure that file data is committed to the file’s underlying device for
persistence.</p>
<p>Files, fileReaders, and fileWriters will be kept alive while there are variables
referring to them and closed when all variables referring to them have gone out
of scope.  However, each can be closed explicitly with <code class="docutils literal notranslate"><span class="pre">close</span></code> methods.  Note
that <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a> will not work if the file has open fileReaders and/or
fileWriters.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../../language/spec/strings.html#string-nonunicode"><span class="std std-ref">Escaped strings</span></a> can be used for paths on systems
where UTF-8 file names are not enforced.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="functions-for-filereader-and-filewriter-creation">
<span id="about-io-filereader-filewriter-creation"></span><h2>Functions for fileReader and fileWriter Creation<a class="headerlink" href="#functions-for-filereader-and-filewriter-creation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> creates a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> for writing to a file, and
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> creates a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> for reading from a file.</p>
<p>The helper functions <a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a> and <a class="reference internal" href="#IO.openWriter" title="IO.openWriter"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openWriter</span></code></a> can also be used
to open a file and create a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to it in a
single step.</p>
</div>
<div class="section" id="synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races">
<span id="about-io-filereader-filewriter-synchronization"></span><h2>Synchronization of fileReader and fileWriter Data and Avoiding Data Races<a class="headerlink" href="#synchronization-of-filereader-and-filewriter-data-and-avoiding-data-races" title="Permalink to this headline">¶</a></h2>
<p>FileReaders and fileWriters (and files) contain locks in order to keep their
operation safe for multiple tasks. When creating a fileReader or fileWriter, it
is possible to disable the lock (for performance reasons) by passing
<code class="docutils literal notranslate"><span class="pre">locking=false</span></code> to e.g.  file.writer().  Some <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
methods - in particular those beginning with the underscore - should only be
called on locked fileReaders or fileWriters.  With these methods, it is possible
to get or set the fileReader or fileWriter style, or perform I/O “transactions”
(see <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a>, e.g.). To use these methods, e.g., first lock the
fileWriter with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a>, call the methods you need, then unlock
the fileWriter with <a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a>. Note that in the future, we may
move to alternative ways of calling these functions that guarantee that they
are not called on a fileReader or fileWriter without the appropriate locking.</p>
<p>Besides data races that can occur if locking is not used in fileWriters when it
should be, it is also possible for there to be data races on file data that is
buffered simultaneously in multiple fileReader/fileWriter combinations.  The
main way to avoid such data races is the <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a>
synchronization operation.  <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> will make all writes to the
fileWriter, if any, available to concurrent viewers of its associated file, such
as other fileWriters, fileReaders or other applications accessing this file
concurrently. See the note below for more details on the situation in which this
kind of data race can occur.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since fileWriters can buffer data until <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> is called, it
is possible to write programs that have undefined behavior because of race
conditions on fileWriter buffers. In particular, the problem comes up for
programs that make:</p>
<blockquote>
<div><ul class="simple">
<li><p>concurrent operations on multiple fileWriters and/or fileReaders that
operate on overlapping regions of a file</p></li>
<li><p>where at least one fileWriter is used along with other fileWriters or
fileReaders</p></li>
<li><p>and where data could be stored in more than one of the overlapping
fileWriter’s buffers at the same time (i.e., write and read ordering are
not enforced through <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> and other means such as
sync variables).</p></li>
</ul>
</div></blockquote>
<p>Note that it is possible in some cases to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> that does
not allow multiple fileWriters and/or fileReaders at different
offsets. FileWriters created on such files will not change the file’s offset
based on a <code class="docutils literal notranslate"><span class="pre">start=</span></code> offset arguments. Instead, each read or write operation
will use the file descriptor’s current offset. Therefore, only one
fileWriter or fileReader should be created for files created in the following
situations:</p>
<blockquote>
<div><ul class="simple">
<li><p>with the file initializer that takes a <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a> argument</p></li>
<li><p>with the file initializer that takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> argument, where the
<code class="docutils literal notranslate"><span class="pre">int</span></code> represents a non-seekable system file descriptor</p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="performing-i-o-with-filereaders-and-filewriters">
<h2>Performing I/O with FileReaders and FileWriters<a class="headerlink" href="#performing-i-o-with-filereaders-and-filewriters" title="Permalink to this headline">¶</a></h2>
<p>FileReaders have a variety of read methods and fileWriters have a variety of
write methods. The most common variety of these are generic methods that can
read or write values of any type. For non-primitive types, the relevant
<code class="docutils literal notranslate"><span class="pre">readThis</span></code> or <code class="docutils literal notranslate"><span class="pre">writeThis</span></code> method is used to control the I/O formatting; see
<a class="reference internal" href="ChapelIO.html#readthis-writethis"><span class="std std-ref">The readThis() and writeThis() Methods</span></a>. These functions generally take any number of
arguments and <cite>throw</cite> if there was an error:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.write</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeln" title="IO.fileWriter.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeln</span></code></a></p></li>
<li><p><a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileWriter.writef" title="FormattedIO.fileWriter.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileWriter.writef</span></code></a> (see also <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a>)</p></li>
<li><p><a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readln" title="IO.fileReader.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readln</span></code></a></p></li>
<li><p><a class="reference internal" href="IO/FormattedIO.html#FormattedIO.fileReader.readf" title="FormattedIO.fileReader.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.fileReader.readf</span></code></a> (see also <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a>)</p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> type also has the following methods for executing write
operations with more specific types. These methods can provide finer control
over the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s behavior as well as some performance advantages over
the generic <cite>write</cite> methods:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileWriter.writeBits" title="IO.fileWriter.writeBits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeBits</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeCodepoint" title="IO.fileWriter.writeCodepoint"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeCodepoint</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeByte" title="IO.fileWriter.writeByte"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeByte</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeString" title="IO.fileWriter.writeString"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeString</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeBytes" title="IO.fileWriter.writeBytes"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeBytes</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.writeBinary" title="IO.fileWriter.writeBinary"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeBinary</span></code></a></p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> type has similar methods for executing read operations with
more specific types, where the goal of these methods is also to provide finer
control over the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s behavior and the potential for performance
advantages:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileReader.readBits" title="IO.fileReader.readBits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBits</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readCodepoint" title="IO.fileReader.readCodepoint"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readCodepoint</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readByte" title="IO.fileReader.readByte"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readByte</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readString" title="IO.fileReader.readString"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readString</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readBytes" title="IO.fileReader.readBytes"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBytes</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readBinary" title="IO.fileReader.readBinary"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readBinary</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Additionally, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> has the following methods which read arbitrary
amounts of data from the file until some stop condition is met. These methods
generally have multiple overloads for reading into values of different types:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.lines" title="IO.fileReader.lines"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lines</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readThrough</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readTo" title="IO.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readTo</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.readAll" title="IO.fileReader.readAll"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readAll</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Sometimes it’s important to flush the buffer in a fileWriter - to do that, use
the <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush()</span></code></a> method. Flushing the buffer will make all writes
available to other applications or other views of the file (e.g., it will call
the OS call <code class="docutils literal notranslate"><span class="pre">pwrite()</span></code>).  It is also possible to close a fileWriter, which
will implicitly flush it and release any buffer memory used by the fileWriter.
Note that if you need to ensure that data from a fileWriter is on disk, you’ll
have to call <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> or <a class="reference internal" href="#IO.fileWriter.close" title="IO.fileWriter.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.close</span></code></a> and then
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> on the related file.</p>
</div>
<div class="section" id="functions-for-closing-filereaders-and-filewriters">
<span id="about-io-closing-filereader-filewriter"></span><h2>Functions for Closing FileReaders and FileWriters<a class="headerlink" href="#functions-for-closing-filereaders-and-filewriters" title="Permalink to this headline">¶</a></h2>
<p>A fileReader or fileWriter must be closed in order to free the resources
allocated for it, to ensure that data written to it is visible to other
fileReaders, or to allow the associated file to be closed.</p>
<p>See <a class="reference internal" href="#IO.fileReader.close" title="IO.fileReader.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.close</span></code></a> and <a class="reference internal" href="#IO.fileWriter.close" title="IO.fileWriter.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.close</span></code></a>.</p>
<p>It is an error to perform any I/O operations on a fileReader or fileWriter
that has been closed.
It is an error to close a file when it has fileReaders and/or fileWriters that
have not been closed.</p>
<p>Files, fileReaders and fileWriters are reference counted. Each file, fileReader
and fileWriter is closed automatically when no references to it remain. For
example, if a local variable is the only reference to a fileReader, the
fileReader will be closed when that variable goes out of scope.  Programs may
also close a file, fileReader or fileWriter explicitly.</p>
</div>
<div class="section" id="the-stdin-filereader-and-stdout-and-stderr-filewriters">
<span id="stdin-stdout-stderr"></span><h2>The <code class="docutils literal notranslate"><span class="pre">stdin</span></code> fileReader, and <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> fileWriters<a class="headerlink" href="#the-stdin-filereader-and-stdout-and-stderr-filewriters" title="Permalink to this headline">¶</a></h2>
<p>Chapel provides the predefined fileReader <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a>, and the predefined
fileWriters <a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdout</span></code></a>, and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stderr</span></code></a> to access the corresponding
operating system streams standard input, standard output, and standard error.</p>
<p><a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a> supports reading;
<a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stderr</span></code></a> support writing.</p>
<p>All three are safe to use concurrently.
Their types’ <code class="docutils literal notranslate"><span class="pre">kind</span></code> argument is <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.</p>
</div>
<div class="section" id="error-handling">
<span id="about-io-error-handling"></span><h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>Most I/O routines throw a <a class="reference internal" href="OS.html#OS.SystemError" title="OS.SystemError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SystemError</span></code></a>, which can be handled
appropriately with <code class="docutils literal notranslate"><span class="pre">try</span></code> and <code class="docutils literal notranslate"><span class="pre">catch</span></code> (see the
<a class="reference internal" href="../../language/spec/error-handling.html#complete-handling"><span class="std std-ref">documentation</span></a> for more detail).</p>
<p>Additionally, some subclasses of <a class="reference internal" href="Errors.html#Errors.Error" title="Errors.Error"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">Error</span></code></a> are commonly used within
the I/O implementation. These are:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a> - the end of file was reached</p></li>
<li><p><a class="reference internal" href="OS.html#OS.UnexpectedEofError" title="OS.UnexpectedEofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.UnexpectedEofError</span></code></a> - a read or write only returned part of the requested data</p></li>
<li><p><a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> - data read did not adhere to the requested format</p></li>
</ul>
</div></blockquote>
<p id="io-general-sys-error"><strong>System Errors:</strong></p>
<p>For other error cases, a general <a class="reference internal" href="OS.html#OS.SystemError" title="OS.SystemError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SystemError</span></code></a> is typically thrown.
These errors are often produced by less predictable circumstances that are
more challenging to recover from. For example, a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> could run
out of memory when attempting to allocate more buffer space.</p>
<p>As such, it is typically recommended that more specific errors are caught and
recovered from separately from a <code class="docutils literal notranslate"><span class="pre">SystemError</span></code>. See the following example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">openReader</span><span class="p">(</span><span class="s">&quot;test.txt&quot;</span><span class="p">);</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">EofError</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;r is at EOF&quot;</span><span class="p">);</span>
  <span class="c1">// we&#39;re done reading</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">UnexpectedEofError</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;unable to read an &#39;int&#39;&quot;</span><span class="p">);</span>
  <span class="c1">// try to read something else? ...</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">SystemError</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;system error in IO implementation: &quot;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="c1">// try to recover from the error? ...</span>

<span class="p">}</span> <span class="k">catch</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Error</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;something else went wrong...&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="i-o-transactions">
<span id="io-transactions"></span><h2>I/O Transactions<a class="headerlink" href="#i-o-transactions" title="Permalink to this headline">¶</a></h2>
<p>An <em>I/O transaction</em> is a common pattern afforded by the IO interface that
provides the ability to temporarily hold a particular region of a file in a
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>’s buffer. This allows I/O
operations within that region of the file to easily be undone in the event
of some unexpected data or other errors.</p>
<p>To support <em>I/O transactions</em>, each <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is fitted
with a <em>mark stack</em> which contains a series of file offsets. The region of the
file between the minimum and maximum offset on the <em>mark stack</em> will always be
retained in the buffer.</p>
<p>The steps of a typical <em>I/O transaction</em> are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mark</span></code> the current file offset with <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a> or
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a>. This pushes the current offset onto the <em>mark stack</em></p></li>
<li><dl class="simple">
<dt>do a speculative I/O operation:</dt><dd><ul>
<li><p>reading example: read 200 bytes followed by a <cite>b</cite>.</p></li>
<li><p>writing example: write 200 bytes without exceeding the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s region.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>if the operation fails, <code class="docutils literal notranslate"><span class="pre">revert</span></code> the operation by calling <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.revert</span></code></a>
or <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.revert</span></code></a>. Subsequent operations will continue from the
originally marked offset as if nothing happened.</p></li>
<li><p>if the operation is successful, call <a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.commit</span></code></a> or
<a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.commit</span></code></a> to pop the value from the <em>mark stack</em> and continue
performing I/O operations from the current offset.</p></li>
</ul>
<p>Note that when the mark stack is emptied, a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is allowed to flush
any portion of its buffer to its file and a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is allowed to discard
any portion of its buffer.</p>
<p>See the following example of a simple I/O transaction:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">fr</span> <span class="o">=</span> <span class="nx">openReader</span><span class="p">(</span><span class="s">&quot;file.txt&quot;</span><span class="p">);</span>

<span class="c1">// mark the current channel position</span>
<span class="nx">fr</span><span class="p">.</span><span class="nx">mark</span><span class="p">();</span>

<span class="c1">// read an array of bytes</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..&lt;</span><span class="mi">200</span><span class="p">]</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nx">fr</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>

<span class="c1">// try to match a pattern</span>
<span class="k">if</span> <span class="nx">fr</span><span class="p">.</span><span class="nx">matchLiteral</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fr</span><span class="p">.</span><span class="nx">commit</span><span class="p">();</span> <span class="c1">// &quot;b&quot; was found, continue reading from the current offset</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">fr</span><span class="p">.</span><span class="nx">revert</span><span class="p">();</span> <span class="c1">// &quot;b&quot; was&#39;t found, revert back to the marked position</span>

  <span class="c1">// try to read something else from the file, throw an error, etc.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-region-of-a-filereader-or-filewriter">
<span id="filereader-filewriter-regions"></span><h2>Specifying the region of a FileReader or FileWriter<a class="headerlink" href="#specifying-the-region-of-a-filereader-or-filewriter" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> types can be configured to
own a specific <em>region</em> of their associated file.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is initialized using one of the
following routines, the optional <code class="docutils literal notranslate"><span class="pre">region</span></code> argument can be set to designate
some region of the file (a zero-based <a class="reference internal" href="../../language/spec/ranges.html#chapter-ranges"><span class="std std-ref">range</span></a> of integers
in bytes) that can be read from or written to:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a></p></li>
</ul>
<p>I/O operations that fall outside of the <em>region</em> are illegal. The <code class="docutils literal notranslate"><span class="pre">region</span></code>
argument defaults to <code class="docutils literal notranslate"><span class="pre">0..</span></code>, meaning that the owned region starts at the 0th
byte, and extends indefinitely.</p>
<p>Note that <a class="reference internal" href="#IO.fileReader.seek" title="IO.fileReader.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.seek</span></code></a> and <a class="reference internal" href="#IO.fileWriter.seek" title="IO.fileWriter.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.seek</span></code></a> can be used to
adjust a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s region after initialization.</p>
<p>Creating a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> that points to a sub-region of
a file can be useful for concurrently reading from or writing to multiple
portions of a file from separate tasks. See the following example, which
uses multiple tasks to concurrently read bytes from a binary file into an
array of bytes:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="c1">// the number of tasks to use</span>
<span class="kd">config</span> <span class="kd">const</span> <span class="nx">nWorkers</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="c1">// open a (large) binary file</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;file.dat&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>

<span class="c1">// compute how many bytes each worker will read</span>
<span class="kd">const</span> <span class="nx">nBytes</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span>
      <span class="nx">nPerLoc</span> <span class="o">=</span> <span class="nx">nBytes</span><span class="o">/</span> <span class="nx">nWorkers</span><span class="p">;</span>

<span class="c1">// create an array to hold the file contents</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..&lt;</span><span class="nx">nBytes</span><span class="p">]</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

<span class="c1">// concurrently read each worker&#39;s region into &#39;a&#39;</span>
<span class="k">coforall</span> <span class="nx">w</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="nx">nWorkers</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">myRegion</span> <span class="o">=</span> <span class="p">(</span><span class="nx">w</span><span class="o">*</span><span class="nx">nPerLoc</span><span class="p">)</span><span class="o">..&lt;</span><span class="p">((</span><span class="nx">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">nPerLoc</span><span class="p">),</span>
        <span class="nx">fr</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">reader</span><span class="p">(</span><span class="nx">region</span><span class="o">=</span><span class="nx">myRegion</span><span class="p">,</span> <span class="nx">locking</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>

  <span class="nx">fr</span><span class="p">.</span><span class="nx">readBinary</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">myRegion</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="locking-behavior-of-filereaders-and-filewriters">
<span id="locking-filereaders-and-filewriters"></span><h2>Locking Behavior of FileReaders and FileWriters<a class="headerlink" href="#locking-behavior-of-filereaders-and-filewriters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> and <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> types can be configured to
lock access to their file when executing I/O operations to avoid race conditions
with other <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> instances that may be accessing the
same file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">locking</span></code> field is a <code class="docutils literal notranslate"><span class="pre">param</span></code> and is thus part of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
and <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> type. As such, it is possible to use type constraints to
designate whether a reader or writer is locking. For example this could be
useful in a procedure that relies on a <code class="docutils literal notranslate"><span class="pre">reader</span></code> argument being locking:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">readSomething</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">fileReader</span><span class="p">(</span><span class="nx">locking</span><span class="o">=</span><span class="kc">true</span><span class="p">,</span> <span class="p">?))</span> <span class="p">{</span>
  <span class="c1">// use &#39;reader&#39; concurrently with another fileReader/fileWriter   ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By default, a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> will lock. A non-locking reader
or writer can be created by setting <code class="docutils literal notranslate"><span class="pre">locking=false</span></code> in one of the following
routines:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.openReader" title="IO.openReader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openReader</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.openWriter" title="IO.openWriter"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openWriter</span></code></a></p></li>
</ul>
<p>With a locking <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>, one can obtain a lock manually
by calling <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lock</span></code></a> or <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a>, and then release a
lock by calling <a class="reference internal" href="#IO.fileReader.unlock" title="IO.fileReader.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.unlock</span></code></a> or <a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following methods will not automatically acquire/release a lock for
<code class="docutils literal notranslate"><span class="pre">locking=true</span></code>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.commit</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.commit</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.revert</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.revert</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileReader.offset" title="IO.fileReader.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.offset</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.fileWriter.offset" title="IO.fileWriter.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.offset</span></code></a></p></li>
</ul>
</div>
</div>
<div class="section" id="ensuring-successful-i-o">
<span id="about-io-ensuring-successful-io"></span><h2>Ensuring Successful I/O<a class="headerlink" href="#ensuring-successful-i-o" title="Permalink to this headline">¶</a></h2>
<p>It is possible - in some situations - for I/O to fail without returning an
error. In cases where a programmer wants to be sure that there was no error
writing the data to disk, it is important to call <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> to make
sure that data has arrived on disk without an error. Many errors can be
reported with a typical operation, but some errors can only be reported by the
system during <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a> or even <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a>.</p>
<p>When a file (or fileWriter) is closed, data written to that file will be written
to disk eventually by the operating system. If an application needs to be sure
that the data is immediately written to persistent storage, it should use
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> prior to closing the file.</p>
</div>
<div class="section" id="correspondence-with-c-i-o">
<h2>Correspondence with C I/O<a class="headerlink" href="#correspondence-with-c-i-o" title="Permalink to this headline">¶</a></h2>
<p>It is not possible to seek, read, or write to a file directly; fileReaders
and/or fileWriters must be created and used.</p>
<p><a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> in Chapel has the same conceptual meaning as
<code class="docutils literal notranslate"><span class="pre">fflush()</span></code> in C.  However, <code class="docutils literal notranslate"><span class="pre">fflush()</span></code> is not necessarily called in
<a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush()</span></code></a>, unlike <code class="docutils literal notranslate"><span class="pre">fsync()</span></code>, which is actually called by
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync()</span></code></a> in Chapel.</p>
</div>
<div class="section" id="io-functions-and-types">
<h2>IO Functions and Types<a class="headerlink" href="#io-functions-and-types" title="Permalink to this headline">¶</a></h2>
<dl class="chpl enum">
<dt class="sig sig-object chpl" id="IO.ioMode">
<em class="property"><span class="pre">enum</span> </em><span class="sig-name descname"><span class="pre">ioMode</span></span> <span class="pre">{</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">cw</span> <span class="pre">=</span> <span class="pre">2,</span> <span class="pre">rw</span> <span class="pre">=</span> <span class="pre">3,</span> <span class="pre">cwr</span> <span class="pre">=</span> <span class="pre">4,</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span> <span class="pre">}</span><a class="headerlink" href="#IO.ioMode" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.ioMode" title="IO.ioMode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioMode</span></code></a> type is an enum. When used as arguments when opening files, its
constants have the same meaning as the listed strings passed to <code class="docutils literal notranslate"><span class="pre">fopen()</span></code> in C.
However, <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open()</span></code></a> in Chapel does not necessarily invoke <code class="docutils literal notranslate"><span class="pre">fopen()</span></code> in C.</p>
<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.r">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">r</span></span> <span class="pre">=</span> <span class="pre">1</span><a class="headerlink" href="#IO.ioMode.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an existing file for reading.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “r”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.cw">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">cw</span></span> <span class="pre">=</span> <span class="pre">2</span><a class="headerlink" href="#IO.ioMode.cw" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new file for writing.
If the file already exists, its contents are truncated.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “w”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.rw">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">rw</span></span> <span class="pre">=</span> <span class="pre">3</span><a class="headerlink" href="#IO.ioMode.rw" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an existing file for reading and writing.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “r+”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.cwr">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">cwr</span></span> <span class="pre">=</span> <span class="pre">4</span><a class="headerlink" href="#IO.ioMode.cwr" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#IO.ioMode.cw" title="IO.ioMode.cw"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">ioMode.cw</span></code></a>, but reading from the file is also allowed.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “w+”)</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.ioMode.a">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">a</span></span> <span class="pre">=</span> <span class="pre">5</span><a class="headerlink" href="#IO.ioMode.a" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.ioMode.a" title="IO.ioMode.a"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">ioMode.a</span></code></a> is unstable and subject to change. It currently only supports one <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> at a time.</p>
</div>
<p>Open a file for appending, creating it if it does not exist.
(<code class="docutils literal notranslate"><span class="pre">fopen()</span></code> string is “a”)</p>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.iokind">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">iokind</span></span> <span class="pre">=</span> <span class="pre">_iokind</span><a class="headerlink" href="#IO.iokind" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘iokind’ is deprecated, please use Serializers or Deserializers that support endianness instead</p>
</div>
<p>The <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> type is an enum. When used as arguments to the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type, its constants have the
following meaning:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code> means that the applicable I/O style has full effect
and as a result the kind varies at runtime.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.native</span></code> means binary I/O in native byte order
(similar to <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code> but with the byte order that is native
to the target platform).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.big</span></code> means binary I/O with big-endian byte order is performed
when writing basic types to the fileWriter or reading basic types from the
fileReader.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.little</span></code> means binary I/O with little-endian byte order
(similar to <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code> but with little-endian byte order).</p></li>
</ul>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code>, <code class="docutils literal notranslate"><span class="pre">iokind.little</span></code>, and
<code class="docutils literal notranslate"><span class="pre">iokind.native</span></code> the applicable <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> is consulted when
writing/reading strings, but not for other basic types.</p>
<p>There are synonyms available for these values:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.iodynamic" title="IO.iodynamic"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">iodynamic</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code></p></li>
<li><p><a class="reference internal" href="#IO.ionative" title="IO.ionative"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ionative</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.native</span></code></p></li>
<li><p><a class="reference internal" href="#IO.iobig" title="IO.iobig"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">iobig</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code></p></li>
<li><p><a class="reference internal" href="#IO.iolittle" title="IO.iolittle"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">iolittle</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.little</span></code></p></li>
</ul>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.iodynamic">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">iodynamic</span></span> <span class="pre">=</span> <span class="pre">_iokind.dynamic</span><a class="headerlink" href="#IO.iodynamic" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘iodynamic’ is deprecated, please use Serializers or Deserializers that support endianness instead</p>
</div>
<p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.ionative">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">ionative</span></span> <span class="pre">=</span> <span class="pre">_iokind.native</span><a class="headerlink" href="#IO.ionative" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘ionative’ is deprecated, please use Serializers or Deserializers that support endianness instead</p>
</div>
<p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.native</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.iobig">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">iobig</span></span> <span class="pre">=</span> <span class="pre">_iokind.big</span><a class="headerlink" href="#IO.iobig" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘iobig’ is deprecated, please use Serializers or Deserializers that support endianness instead</p>
</div>
<p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.iolittle">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">iolittle</span></span> <span class="pre">=</span> <span class="pre">_iokind.little</span><a class="headerlink" href="#IO.iolittle" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘iolittle’ is deprecated, please use Serializers or Deserializers that support endianness instead</p>
</div>
<p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.little</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl enum">
<dt class="sig sig-object chpl" id="IO.endianness">
<em class="property"><span class="pre">enum</span> </em><span class="sig-name descname"><span class="pre">endianness</span></span> <span class="pre">{</span> <span class="pre">native</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">big</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">little</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">}</span><a class="headerlink" href="#IO.endianness" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> type is an enum. When used as an argument to the
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> methods, its constants have the
following meanings:</p>
<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.endianness.native">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">native</span></span> <span class="pre">=</span> <span class="pre">0</span><a class="headerlink" href="#IO.endianness.native" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">native</span></code> means binary I/O is performed in the byte order that is native
to the target platform.</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.endianness.big">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">big</span></span> <span class="pre">=</span> <span class="pre">1</span><a class="headerlink" href="#IO.endianness.big" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">big</span></code> means binary I/O is performed in big-endian byte order.</p>
</dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.endianness.little">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">little</span></span> <span class="pre">=</span> <span class="pre">2</span><a class="headerlink" href="#IO.endianness.little" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">little</span></code> means binary I/O is performed in little-endian byte order.</p>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.ioendian">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">ioendian</span></span> <span class="pre">=</span> <span class="pre">endianness</span><a class="headerlink" href="#IO.ioendian" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<dl class="field-list simple">
<dt class="field-odd">enum</dt>
<dd class="field-odd"><p>ioendian is deprecated; please use :enum: endianness instead</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="chpl enum">
<dt class="sig sig-object chpl" id="IO.iostringstyle">
<em class="property"><span class="pre">enum</span> </em><span class="sig-name descname"><span class="pre">iostringstyle</span></span> <span class="pre">{</span> <span class="pre">len1b_data</span> <span class="pre">=</span> <span class="pre">-1,</span> <span class="pre">len2b_data</span> <span class="pre">=</span> <span class="pre">-2,</span> <span class="pre">len4b_data</span> <span class="pre">=</span> <span class="pre">-4,</span> <span class="pre">len8b_data</span> <span class="pre">=</span> <span class="pre">-8,</span> <span class="pre">lenVb_data</span> <span class="pre">=</span> <span class="pre">-10,</span> <span class="pre">data_toeof</span> <span class="pre">=</span> <span class="pre">-0xff00,</span> <span class="pre">data_null</span> <span class="pre">=</span> <span class="pre">-0x0100</span> <span class="pre">}</span><a class="headerlink" href="#IO.iostringstyle" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>iostringstyle is deprecated, please use Serializers or Deserializers instead</p>
</div>
<p>This enum contains values used to control binary I/O with strings
via the <code class="docutils literal notranslate"><span class="pre">str_style</span></code> field in <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len1b_data</span></code> indicates a string format of 1 byte of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len2b_data</span></code> indicates a string format of 2 bytes of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len4b_data</span></code> indicates a string format of 4 bytes of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len8b_data</span></code> indicates a string format of 8 bytes of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.lenVb_data</span></code> indicates a string format of a variable
number of bytes of length, encoded with high-bit meaning more bytes
of length follow, and where the 7-bits of length from each byte store
the 7-bit portions of the length in order from least-significant to
most-significant. This way of encoding a variable-byte length  matches
<a class="reference external" href="https://github.com/protocolbuffers/protobuf">Google Protocol Buffers</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.data_toeof</span></code> indicates a string format that contains
only the string data without any length or terminator. When reading,
this format will read a string until the end of the file is reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.data_null</span></code> indicates a string that is terminated
by a zero byte. It can be combined with other numeric
values to indicate a string terminated by a particular byte. For example,
to indicate a string terminated by <code class="docutils literal notranslate"><span class="pre">$</span></code> (which in ASCII has byte value 0x24),
one would use the value <code class="docutils literal notranslate"><span class="pre">iostringstyle.data_null|0x24</span></code>.</p></li>
<li><p>A positive and nonzero value indicates that a string of exactly that many
bytes should be read or written.</p></li>
</ul>
<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.len1b_data">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">len1b_data</span></span> <span class="pre">=</span> <span class="pre">-1</span><a class="headerlink" href="#IO.iostringstyle.len1b_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.len2b_data">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">len2b_data</span></span> <span class="pre">=</span> <span class="pre">-2</span><a class="headerlink" href="#IO.iostringstyle.len2b_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.len4b_data">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">len4b_data</span></span> <span class="pre">=</span> <span class="pre">-4</span><a class="headerlink" href="#IO.iostringstyle.len4b_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.len8b_data">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">len8b_data</span></span> <span class="pre">=</span> <span class="pre">-8</span><a class="headerlink" href="#IO.iostringstyle.len8b_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.lenVb_data">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">lenVb_data</span></span> <span class="pre">=</span> <span class="pre">-10</span><a class="headerlink" href="#IO.iostringstyle.lenVb_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.data_toeof">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">data_toeof</span></span> <span class="pre">=</span> <span class="pre">-0xff00</span><a class="headerlink" href="#IO.iostringstyle.data_toeof" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringstyle.data_null">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">data_null</span></span> <span class="pre">=</span> <span class="pre">-0x0100</span><a class="headerlink" href="#IO.iostringstyle.data_null" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl enum">
<dt class="sig sig-object chpl" id="IO.iostringformat">
<em class="property"><span class="pre">enum</span> </em><span class="sig-name descname"><span class="pre">iostringformat</span></span> <span class="pre">{</span> <span class="pre">word</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">basic</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">chpl</span> <span class="pre">=</span> <span class="pre">2,</span> <span class="pre">json</span> <span class="pre">=</span> <span class="pre">3,</span> <span class="pre">toend</span> <span class="pre">=</span> <span class="pre">4,</span> <span class="pre">toeof</span> <span class="pre">=</span> <span class="pre">5</span> <span class="pre">}</span><a class="headerlink" href="#IO.iostringformat" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>iostringformat is deprecated, please use Serializers or Deserializers instead</p>
</div>
<p>This enum contains values used to control text I/O with strings
via the <code class="docutils literal notranslate"><span class="pre">string_format</span></code> field in <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.word</span></code> means string is as-is;
reading reads until whitespace. This is the default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.basic</span></code> means only escape <em>string_end</em> and <code class="docutils literal notranslate"><span class="pre">\</span></code>
with <code class="docutils literal notranslate"><span class="pre">\</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.chpl</span></code> means  escape <em>string_end</em>
<code class="docutils literal notranslate"><span class="pre">\</span></code> <code class="docutils literal notranslate"><span class="pre">'</span></code> <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> <code class="docutils literal notranslate"><span class="pre">\n</span></code> with <code class="docutils literal notranslate"><span class="pre">\</span></code> and
nonprinting characters <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">0xXY</span></code> with <code class="docutils literal notranslate"><span class="pre">\xXY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.json</span></code> means  escape <em>string_end</em> <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">\</span></code>
with <code class="docutils literal notranslate"><span class="pre">\</span></code>, and nonprinting characters <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">\uABCD</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.toend</span></code> means string is as-is; reading reads until
<em>string_end</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.toeof</span></code> means string is as-is; reading reads until
end of file</p></li>
</ul>
</div></blockquote>
<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringformat.word">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">word</span></span> <span class="pre">=</span> <span class="pre">0</span><a class="headerlink" href="#IO.iostringformat.word" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringformat.basic">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">basic</span></span> <span class="pre">=</span> <span class="pre">1</span><a class="headerlink" href="#IO.iostringformat.basic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringformat.chpl">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">chpl</span></span> <span class="pre">=</span> <span class="pre">2</span><a class="headerlink" href="#IO.iostringformat.chpl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringformat.json">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">json</span></span> <span class="pre">=</span> <span class="pre">3</span><a class="headerlink" href="#IO.iostringformat.json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringformat.toend">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">toend</span></span> <span class="pre">=</span> <span class="pre">4</span><a class="headerlink" href="#IO.iostringformat.toend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl enumconstant">
<dt class="sig sig-object chpl" id="IO.iostringformat.toeof">
<em class="property"><span class="pre">enum</span> <span class="pre">constant</span> </em><span class="sig-name descname"><span class="pre">toeof</span></span> <span class="pre">=</span> <span class="pre">5</span><a class="headerlink" href="#IO.iostringformat.toeof" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.stringStyleTerminated">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">stringStyleTerminated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">terminator:</span> <span class="pre">uint(8)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleTerminated" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>stringStyleTerminated is deprecated following the deprecation of ‘iostyle’, please use Serializers or Deserializers instead</p>
</div>
<p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> <code class="docutils literal notranslate"><span class="pre">str_style</span></code> value
to indicate a string format where strings are terminated by a
particular byte.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>terminator</strong> – a byte value that the strings will be terminated by</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a value that indicates a string format where strings
are terminated by the terminator byte. This value is appropriate
to store in iostyle.str_style.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.stringStyleNullTerminated">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">stringStyleNullTerminated</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleNullTerminated" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>stringStyleNullTerminated is deprecated following the deprecation of ‘iostyle’, please use Serializers or Deserializers instead</p>
</div>
<p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> <code class="docutils literal notranslate"><span class="pre">str_style</span></code> value
to indicate a string format where strings are terminated by a
zero byte.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.stringStyleWithLength">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">stringStyleWithLength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lengthBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.stringStyleWithLength" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>stringStyleWithLength is deprecated following the deprecation of ‘iostyle’, please use Serializers or Deserializers instead</p>
</div>
<p>Return the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> <code class="docutils literal notranslate"><span class="pre">str_style</span></code> value
to indicate a string format where string data is preceded by a
<cite>lengthBytes</cite> of length. Only lengths of 1, 2, 4, or 8 are supported.
When <cite>lengthBytes</cite> is 0, the returned value indicates variable-byte length.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown for an unsupported value of <cite>lengthBytes</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.iostyle">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">iostyle</span></span> <span class="pre">=</span> <span class="pre">iostyleInternal</span><a class="headerlink" href="#IO.iostyle" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>iostyle is deprecated; please use Serializers or Deserializers instead</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.defaultIOStyle">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">defaultIOStyle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">iostyle</span><a class="headerlink" href="#IO.defaultIOStyle" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>defaultIOStyle is deprecated due to returning the deprecated type ‘iostyle’</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the default I/O style. See <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>
and <a class="reference internal" href="#about-io-styles"><span class="std std-ref">I/O Styles</span></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.ioHintSet">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ioHintSet</span></span><a class="headerlink" href="#IO.ioHintSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A value of the <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a> type defines a set of hints to provide
information about the operations that a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>, <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>
or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> will perform. These hints may be used by the
implementation to select optimized versions of the I/O operations.</p>
<p>Most hints have POSIX equivalents associated with posix_fadvise() and
posix_madvise().</p>
<p>This example depicts how an <code class="docutils literal notranslate"><span class="pre">ioHintSet</span></code> might be used.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>

<span class="c1">// define a set of hints using a union operation</span>
<span class="kd">var</span> <span class="nx">hints</span> <span class="o">=</span> <span class="nx">ioHintSet</span><span class="p">.</span><span class="nx">sequential</span> <span class="o">|</span> <span class="nx">ioHintSet</span><span class="p">.</span><span class="nx">prefetch</span><span class="p">;</span>

<span class="c1">// open a file using the hints</span>
<span class="kd">var</span> <span class="nx">f</span><span class="p">:</span> <span class="nx">file</span><span class="p">;</span>
<span class="k">try</span><span class="o">!</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;path/to/my/file.txt&quot;</span><span class="p">,</span> <span class="nx">ioMode</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">hints</span><span class="o">=</span><span class="nx">hints</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.empty">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">empty</span></span><a class="headerlink" href="#IO.ioHintSet.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an empty set, which provides no hints.
Corresponds to ‘POSIX_*_NORMAL’.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.sequential">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">sequential</span></span><a class="headerlink" href="#IO.ioHintSet.sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggests that the file will be accessed sequentially.
Corresponds to ‘POSIX_*_SEQUENTIAL’</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.random">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">random</span></span><a class="headerlink" href="#IO.ioHintSet.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggests that the file will be accessed randomly.
Corresponds to ‘POSIX_*_RANDOM’.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.prefetch">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">prefetch</span></span><a class="headerlink" href="#IO.ioHintSet.prefetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggests that the runtime/OS should immediately begin prefetching the file contents.
Corresponds to ‘POSIX_*_WILLNEED’.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.mmap">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">mmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">useMmap</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggests whether or not ‘mmap’ should be used to access the file contents.</p>
<blockquote>
<div><ul class="simple">
<li><p>when <code class="docutils literal notranslate"><span class="pre">useMmap</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>, suggests that ‘mmap’ should be used</p></li>
<li><p>when <code class="docutils literal notranslate"><span class="pre">useMmap</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, suggests that ‘mmap’ should not be used and ‘pread’/’pwrite’ should be used instead</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.noMmap">
<em class="property"><span class="pre">proc</span> <span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">noMmap</span></span><a class="headerlink" href="#IO.ioHintSet.noMmap" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><cite>ioHintSet.noMmap</cite> is deprecated; please use <cite>ioHintSet.mmap(false)</cite> instead</p>
</div>
<p>Suggests that ‘mmap’ should not be used to access the file contents.
Instead, pread/pwrite are used.</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.|">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">|</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.|" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the union of two hint sets</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.&amp;">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">&amp;</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.&" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the intersection of two hint sets</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.==">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">==</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.==" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two hint sets for equality</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ioHintSet.!=">
<em class="property"><span class="pre">operator</span> </em><span class="sig-prename descclassname"><span class="pre">ioHintSet.</span></span><span class="sig-name descname"><span class="pre">!=</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lhs:</span> <span class="pre">ioHintSet</span></em>, <em class="sig-param"><span class="pre">rhs:</span> <span class="pre">ioHintSet</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.ioHintSet.!=" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two hint sets for inequality</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.file">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">file</span></span><a class="headerlink" href="#IO.file" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type is implementation-defined.  A value of the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type refers to the state that is used by the implementation to
identify and interact with the OS file.</p>
<p>When a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> formal argument has default intent, the actual is passed
by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the formal upon a function call, and the formal
cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type does not represent any OS file.
It is illegal to perform any I/O operations on the default value.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.init">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fp:</span> <span class="pre">c_ptr(c_FILE)</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em>, <em class="sig-param"><span class="pre">own</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.init" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>initializing a file with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fp:</span> <span class="pre">c_ptr(c_FILE)</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">own</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Create a Chapel <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> that wraps around an open C file. A pointer to
a C <code class="docutils literal notranslate"><span class="pre">FILE</span></code> object can be obtained via Chapel’s
<a class="reference internal" href="../../primers/interopWithC.html#primers-c-interop-using-c"><span class="std std-ref">C Interoperability</span></a> functionality.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an alternative way to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>.  The main way to do so
is via the <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> function.</p>
</div>
<p>Once the Chapel file is created, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to
create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a fileWriter to perform I/O
operations on the C file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The resulting file value should only be used with one <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or
<a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> at a time. The I/O system will ignore the offsets when
reading or writing to a file opened using this initializer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fp</strong> – a pointer to a C <code class="docutils literal notranslate"><span class="pre">FILE</span></code>. See <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a>.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
<li><p><strong>own</strong> – set to indicate if the <a class="reference internal" href="CTypes.html#CTypes.c_FILE" title="CTypes.c_FILE"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_FILE</span></code></a> provided should be
cleaned up when the <code class="docutils literal notranslate"><span class="pre">file</span></code> is closed.  Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – Thrown if the C file could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fileDescriptor:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em>, <em class="sig-param"><span class="pre">own</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>initializing a file with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fileDescriptor:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">own</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Create a Chapel file that works with a system file descriptor.  Note that once
the file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a
fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a fileWriter to actually perform I/O
operations</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an alternative way to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>.  The main way to do so
is via the <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> function.</p>
</div>
<p>The system file descriptor will be closed when the Chapel file is closed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can be used to create Chapel files that refer to system file
descriptors that do not support the <code class="docutils literal notranslate"><span class="pre">seek</span></code> functionality. For example, file
descriptors that represent pipes or open socket connections have this
property. In that case, the resulting file value should only be used with one
<a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> or <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> at a time.  The I/O system will
ignore the fileReader offsets when reading (or the fileWriter offsets when
writing) to files backed by non-seekable file descriptors.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fileDescriptor</strong> – a system file descriptor.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
<li><p><strong>own</strong> – set to indicate if the <cite>fileDescriptor</cite> provided should be cleaned up
when the <code class="docutils literal notranslate"><span class="pre">file</span></code> is closed.  Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – Thrown if the file descriptor could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.isOpen">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">isOpen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.file.isOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates if the file is currently open.  Will return <code class="docutils literal notranslate"><span class="pre">false</span></code> for both
closed and invalid files</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.close">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a file.</p>
<p>In order to free the resources allocated for a file, it
must be closed using this method.</p>
<p>Closing a file does not guarantee immediate persistence of the performed
updates, if any. In cases where immediate persistence is important,
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> should be used for that purpose prior to closing the file.
In particular, even though closing the file might complete without errors,
the data written might not persist in the event of a severe error like
running out of storage space or power loss. See also
<a class="reference internal" href="#about-io-ensuring-successful-io"><span class="std std-ref">Ensuring Successful I/O</span></a>.</p>
<p>Files are automatically closed when the file variable goes out of scope and
all fileReaders and fileWriters using that file are closed. Programs may also
explicitly close a file using this method.</p>
<p>It is an error to perform any I/O operations on a file that has been closed.
It is an error to close a file when it has fileReaders and/or fileWriters
that have not been closed.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the file could not be closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.fsync">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">fsync</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Sync a file to disk.</p>
<p>Commits file data to the device associated with this file.
Data written to the file by a fileWriter will only be guaranteed
committed if the fileWriter has been closed or flushed.</p>
<p>This function will typically call the <code class="docutils literal notranslate"><span class="pre">fsync</span></code> system call.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the file could not be synced.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.path">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">path</span></span><span class="pre">:</span> <span class="pre">string</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the absolute path to an open file.</p>
<p>Note that not all files have a path (e.g. files opened with <a class="reference internal" href="#IO.openMemFile" title="IO.openMemFile"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openMemFile</span></code></a>),
and that this procedure may not work on all operating systems.</p>
<p>The function <a class="reference internal" href="Path.html#Path.realPath" title="Path.realPath"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">Path.realPath</span></code></a> is an alternative way
to get the path to a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the absolute path to the file</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the path could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.size">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">size</span></span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current size of an open file. Note that the size can always
change if other fileWriters, tasks or programs are writing to the file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the current file size</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – Thrown if the size could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.open">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">mode:</span> <span class="pre">ioMode</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span><a class="headerlink" href="#IO.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file on a filesystem. Note that once the file is open, you will need to
use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to
create a fileWriter to actually perform I/O operations</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – which file to open (for example, “some/file.txt”).</p></li>
<li><p><strong>mode</strong> – specify whether to open the file for reading or writing and
whether or not to create the file if it doesn’t exist.
See <a class="reference internal" href="#IO.ioMode" title="IO.ioMode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioMode</span></code></a>.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open file to the requested resource.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – Thrown if part of the provided path did not exist</p></li>
<li><p><strong>PermissionError</strong> – Thrown if part of the provided path had inappropriate
permissions</p></li>
<li><p><strong>NotADirectoryError</strong> – Thrown if part of the provided path was expected to
be a directory but was not</p></li>
<li><p><strong>SystemError</strong> – Thrown if the file could not be opened.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">mode:</span> <span class="pre">ioMode</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>open with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openTempFile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openTempFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span><a class="headerlink" href="#IO.openTempFile" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>openTempFile with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openTempFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span></dt>
<dd><p>Open a temporary file. Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a
fileWriter to actually perform I/O operations.</p>
<p>The temporary file will be created in an OS-dependent temporary directory,
for example “/tmp” is the typical location. The temporary file will be
deleted upon closing.</p>
<p>Temporary files are opened with <a class="reference internal" href="#IO.ioMode" title="IO.ioMode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioMode</span></code></a> <code class="docutils literal notranslate"><span class="pre">ioMode.cwr</span></code>; that is, a new
file is created that supports both writing and reading.  When possible, it may
be opened using OS support for temporary files in order to make sure that a new
file is created only for use by the current application.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open temporary file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the temporary file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openMemFile">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openMemFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span><a class="headerlink" href="#IO.openMemFile" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>openMemFile with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openMemFile</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">file</span> <span class="pre">throws</span></dt>
<dd><p>Open a file that is backed by a buffer in memory that will not persist when the
file is closed.  Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> to create a fileReader or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a
fileWriter to actually perform I/O operations.</p>
<p>The resulting file supports both reading and writing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an open memory file.</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – Thrown if the memory buffered file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.fileReader">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">fileReader</span></span><a class="headerlink" href="#IO.fileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> supports sequential reading from an underlying <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>
object. It can buffer data. Read operations on it might return old data.</p>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type is implementation-defined.
A value of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type refers to the state that is used
to implement the reading operations.</p>
<p>When a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> formal argument has default intent, the actual is
passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the formal upon a function call, and the formal
cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type is not associated
with any file, and so cannot be used to perform I/O.</p>
<p>The <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type is generic.</p>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileReader.kind">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">kind</span></span><span class="pre">:</span> <span class="pre">iokind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span><a class="headerlink" href="#IO.fileReader.kind" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘fileReader.kind’ is deprecated, please use Deserializers to configure endianness instead</p>
</div>
<p>kind is an enum <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> that allows narrowing
this fileReader’s I/O style for more efficient binary I/O.</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileReader.locking">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">locking</span></span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileReader.locking" title="Permalink to this definition">¶</a></dt>
<dd><p>locking is a boolean indicating whether it is safe to use this
fileReader concurrently (when <cite>true</cite>).</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileReader.deserializerType">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">deserializerType</span></span> <span class="pre">=</span> <span class="pre">defaultSerializeType(false,</span> <span class="pre">kind)</span><a class="headerlink" href="#IO.fileReader.deserializerType" title="Permalink to this definition">¶</a></dt>
<dd><p>deserializerType indicates the type of the deserializer that this
fileReader will use to deserialize data.</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.writing">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">writing</span></span> <span class="pre">param:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileReader.writing" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘fileReader.writing’ is deprecated and will be removed in a future release</p>
</div>
<p>Returns a bool indicating whether the fileReader is used for writing.  It is
always <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.deserializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">deserializer</span></span> <span class="pre">ref:</span> <span class="pre">deserializerType</span><a class="headerlink" href="#IO.fileReader.deserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mutable reference to this fileReader’s deserializer.</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.fileWriter">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">fileWriter</span></span><a class="headerlink" href="#IO.fileWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> supports sequential writing to an underlying <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a>
object. A <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> can buffer data. Write operations might not have an
immediate effect. Use <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a> to control this buffering.</p>
<p>The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type is implementation-defined.
A value of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type refers to the state that is used
to implement the writing operations.</p>
<p>When a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> formal argument has default intent, the actual is
passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the formal upon a function call, and the formal
cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type is not associated with any
file, and so cannot be used to perform I/O.</p>
<p>The <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type is generic.</p>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileWriter.kind">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">kind</span></span><span class="pre">:</span> <span class="pre">iokind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span><a class="headerlink" href="#IO.fileWriter.kind" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘fileWriter.kind’ is deprecated, please use Serializers to configure endianness instead</p>
</div>
<p>kind is an enum <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> that allows narrowing
this fileWriter’s I/O style for more efficient binary I/O.</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileWriter.locking">
<em class="property"><span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">locking</span></span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileWriter.locking" title="Permalink to this definition">¶</a></dt>
<dd><p>locking is a boolean indicating whether it is safe to use this
fileWriter concurrently (when <cite>true</cite>).</p>
</dd></dl>

<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.fileWriter.serializerType">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">serializerType</span></span> <span class="pre">=</span> <span class="pre">defaultSerializeType(true,</span> <span class="pre">kind)</span><a class="headerlink" href="#IO.fileWriter.serializerType" title="Permalink to this definition">¶</a></dt>
<dd><p>serializerType indicates the type of the serializer that this fileWriter
will use to serialize data.</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writing">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writing</span></span> <span class="pre">param:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileWriter.writing" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘fileWriter.writing’ is deprecated and will be removed in a future release</p>
</div>
<p>Returns a bool indicating whether the fileWriter is used for writing.  It is
always <code class="docutils literal notranslate"><span class="pre">true</span></code></p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.serializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">serializer</span></span> <span class="pre">ref:</span> <span class="pre">serializerType</span><a class="headerlink" href="#IO.fileWriter.serializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mutable reference to this fileWriter’s serializer.</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">defaultSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The default Serializer used by <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Serializers and their usage.</p>
<p>Otherwise, please refer to the individual methods in this type for a
description of the default IO format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.serializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">serializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.serializeValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code> with <code class="docutils literal notranslate"><span class="pre">writer</span></code>.</p>
<p>Numeric values are serialized as though they were written with the format
as <code class="docutils literal notranslate"><span class="pre">%i</span></code> for integers and <code class="docutils literal notranslate"><span class="pre">%r</span></code> for <code class="docutils literal notranslate"><span class="pre">real</span></code> numbers. Complex numbers are
serialized as <code class="docutils literal notranslate"><span class="pre">%z</span></code>. Please refer to <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">the section on Formatted
IO</span></a> for more information.</p>
<p>Booleans are serialized as the literal strings <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> values are serialized using the same format as <code class="docutils literal notranslate"><span class="pre">%s</span></code> — that is,
literally and without quotes. <code class="docutils literal notranslate"><span class="pre">bytes</span></code> values are also serialized
literally without extra formatting.</p>
<p>Enums are serialized using the name of the corresponding value. For example
with an enum like <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">colors</span> <span class="pre">{red,</span> <span class="pre">green</span> <span class="pre">blue}</span></code>, the value <code class="docutils literal notranslate"><span class="pre">red</span></code>
would simply be serialized as <code class="docutils literal notranslate"><span class="pre">red</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nil</span></code> value and nilable class variables storing <code class="docutils literal notranslate"><span class="pre">nil</span></code> will be
serialized as the text <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>Classes and records will have their <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method invoked, passing
in <code class="docutils literal notranslate"><span class="pre">writer</span></code> and this Serializer as arguments. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement the <code class="docutils literal notranslate"><span class="pre">writeSerializable</span></code>
or <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> used to write serialized output.</p></li>
<li><p><strong>val</strong> – The value to be serialized.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a class by writing the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer" title="IO.defaultSerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.startRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a record by writing the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the record type.</p></li>
<li><p><strong>size</strong> – The number of fields in the record.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new AggregateSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateSerializer</span></span><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startClass</span></code> or <code class="docutils literal notranslate"><span class="pre">startRecord</span></code> to provide the API for
serializing classes or records.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">class</span></code> with integer fields ‘x’ and ‘y’ with values ‘0’ and ‘5’ would
be serialized as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{x = 0, y = 5}
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">record</span></code> with matching fields would be serialized in the same way, but
would use <code class="docutils literal notranslate"><span class="pre">(</span></code> and <code class="docutils literal notranslate"><span class="pre">)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.writeField">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">field:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.writeField" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">field</span></code> named <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>Serializes fields in the form ‘&lt;name&gt; = &lt;field&gt;’. Adds a comma before the
name if this is not the first field.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.startClass">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start serializing a nested class inside the current class. In this format
inheritance is not represented and parent fields are printed before child
fields. For example, the following classes with values
<code class="docutils literal notranslate"><span class="pre">x=5</span></code> and <code class="docutils literal notranslate"><span class="pre">y=2.0</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>would be serialized as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{x = 5, y = 2.0}
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing. Must match
the writer used to create current AggregateSerializer.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new AggregateSerializer</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.endClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current class by writing the character <code class="docutils literal notranslate"><span class="pre">}</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is an error to call methods on an AggregateSerializer after
invoking ‘endClass’.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultSerializer.AggregateSerializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultSerializer.AggregateSerializer.endRecord" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current record by writing the character <code class="docutils literal notranslate"><span class="pre">)</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is an error to call methods on an AggregateSerializer after
invoking ‘endRecord’.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.startTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.startTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a tuple by writing the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new TupleSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.TupleSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleSerializer</span></span><a class="headerlink" href="#IO.TupleSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> to provide the API for serializing tuples.</p>
<p>A tuple will be serialized as a comma-separated list between two
parentheses. For example, the tuple literal <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> would be
serialized as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>A 1-tuple will be serialized with a trailing comma. For example, the literal
<code class="docutils literal notranslate"><span class="pre">(4,)</span></code> would be serialized as <code class="docutils literal notranslate"><span class="pre">(4,)</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.TupleSerializer.writeElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.TupleSerializer.writeElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>Writes a leading comma before serializing the element if this is not the
first element in the tuple.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.TupleSerializer.endTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.TupleSerializer.endTuple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current tuple by writing the character <code class="docutils literal notranslate"><span class="pre">)</span></code>.</p>
<p>Adds a comma between the last value and <code class="docutils literal notranslate"><span class="pre">)</span></code> if there was only one
element.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.startList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.startList" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a list by writing the character <code class="docutils literal notranslate"><span class="pre">[</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new ListSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.ListSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListSerializer</span></span><a class="headerlink" href="#IO.ListSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startList</span></code> to provide the API for serializing lists.</p>
<p>A list will be serialized as a comma-separated series of serialized
elements between two square brackets. For example, serializing a list
with elements <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> will produce the text:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
</pre></div>
</div>
<p>Empty lists will be serialized as <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ListSerializer.writeElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ListSerializer.writeElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>Writes a leading comma before serializing the element if this is not the
first element in the list.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ListSerializer.endList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ListSerializer.endList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current list by writing the character <code class="docutils literal notranslate"><span class="pre">]</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.startArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.startArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new ArraySerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.ArraySerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArraySerializer</span></span><a class="headerlink" href="#IO.ArraySerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startArray</span></code> to provide the API for serializing arrays.</p>
<p>In the default format, an array will be serialized as a
whitespace-separated series of serialized elements.</p>
<p>A 1D array is serialized simply using spaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
</pre></div>
</div>
<p>A 2D array is serialized using spaces between elements in a row, and
prints newlines for new rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
</pre></div>
</div>
<p>Arrays with three or more dimensions will be serialized as a series of
2D “panes”, with multiple newlines separating new dimensions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>

<span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span>
<span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span>
<span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span>

<span class="mi">19</span> <span class="mi">20</span> <span class="mi">21</span>
<span class="mi">22</span> <span class="mi">23</span> <span class="mi">24</span>
<span class="mi">25</span> <span class="mi">26</span> <span class="mi">27</span>
</pre></div>
</div>
<p>Empty arrays result in no output to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArraySerializer.startDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArraySerializer.startDim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Inform the <code class="docutils literal notranslate"><span class="pre">ArraySerializer</span></code> to start serializing a new dimension of
size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArraySerializer.endDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArraySerializer.endDim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End the current dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArraySerializer.writeElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArraySerializer.writeElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>Adds a space if this is not the first element in the row.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArraySerializer.endArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArraySerializer.endArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.startMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.startMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a map by writing the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of entries in the map.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new MapSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.MapSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapSerializer</span></span><a class="headerlink" href="#IO.MapSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startMap</span></code> to provide the API for serializing maps.</p>
<p>Maps are serialized as a comma-separated series of pairs between curly
braces. Pairs are serialized with a <code class="docutils literal notranslate"><span class="pre">:</span></code> separating the key and value. For
example, the keys <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> with values corresponding to
their squares would be serialized as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">9</span><span class="p">}</span>
</pre></div>
</div>
<p>Empty maps will be serialized as <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapSerializer.writeKey">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">writeKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">key:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapSerializer.writeKey" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<p>Adds a leading comma if this is not the first pair in the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapSerializer.writeValue">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapSerializer.writeValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code>, preceded by the character <code class="docutils literal notranslate"><span class="pre">:</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapSerializer.endMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapSerializer.endMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Ends serialization of the current map by writing the character <code class="docutils literal notranslate"><span class="pre">}</span></code></p>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.DefaultSerializer">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">DefaultSerializer</span></span> <span class="pre">=</span> <span class="pre">defaultSerializer</span><a class="headerlink" href="#IO.DefaultSerializer" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘DefaultSerializer’ is deprecated; please use ‘defaultSerializer’ instead</p>
</div>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">defaultDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The default Deserializer used by <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Deserializers and their usage.</p>
<p>Otherwise, please refer to <a class="reference internal" href="#IO.defaultSerializer" title="IO.defaultSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">defaultSerializer</span></code></a> for a description
of the default IO format. Individual methods on this type may clarify
behavior specific to deserialization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prior to the 1.32 release and the advent of the ‘serializers’ feature, the
default implementation for reading classes and records permitted reading
fields out of order. This functionality is not supported by the
<code class="docutils literal notranslate"><span class="pre">defaultDeserializer</span></code>.</p>
<p>For an unspecified amount of time this module will retain the ability to
disable automatic use of the <code class="docutils literal notranslate"><span class="pre">defaultDeserializer</span></code> by recompiling
programs with the config-param <code class="docutils literal notranslate"><span class="pre">useIOSerializers</span></code> set to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Eventually, however, users must update their programs to account for
reading fields out of order.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.deserializeType">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">readType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">readType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.deserializeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize type <code class="docutils literal notranslate"><span class="pre">readType</span></code> with <code class="docutils literal notranslate"><span class="pre">reader</span></code>.</p>
<p>Classes and records will be deserialized using an appropriate initializer,
passing in <code class="docutils literal notranslate"><span class="pre">reader</span></code> and this Deserializer as arguments. If an
initializer is unavailable, this method may invoke the class or record’s
<code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. Please see the <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> interfaces (or both).
Alternatively, types implementing the entire <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface
are also accepted.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> from which types are deserialized.</p></li>
<li><p><strong>readType</strong> – The type to be deserialized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A value of type <code class="docutils literal notranslate"><span class="pre">readType</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.deserializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">val:</span> <span class="pre">?readType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.deserializeValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize from <code class="docutils literal notranslate"><span class="pre">reader</span></code> directly into <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
<p>Like <a class="reference internal" href="#IO.defaultDeserializer.deserializeType" title="IO.defaultDeserializer.deserializeType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">deserializeType</span></code></a>, but reads into an initialized value rather
than creating a new value. For classes and records, this method will first
attempt to invoke a <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. If the <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method
is unavailable, this method may fall back on invoking a suitable
initializer and assigning the resulting value into <code class="docutils literal notranslate"><span class="pre">val</span></code>.. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> interfaces (or both).
Alternatively, types implementing the entire <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface
are also accepted.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> from which values are deserialized.</p></li>
<li><p><strong>val</strong> – The value into which this Deserializer will deserialize.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Start deserializing a class by reading the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the class type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.AggregateDeserializer" title="IO.defaultDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.startRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Start deserializing a record by reading the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the record type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.defaultDeserializer.AggregateDeserializer" title="IO.defaultDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateDeserializer</span></span><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startClass</span></code> or <code class="docutils literal notranslate"><span class="pre">startRecord</span></code> to provide the API for
deserializing classes or records.</p>
<p>See <a class="reference internal" href="#IO.defaultSerializer.AggregateSerializer" title="IO.defaultSerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a> for details of the
default format for classes and records.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.readField">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">fieldType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fieldType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.readField" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize a field named <code class="docutils literal notranslate"><span class="pre">name</span></code> of type <code class="docutils literal notranslate"><span class="pre">fieldType</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">fieldType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">field</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize a field named <code class="docutils literal notranslate"><span class="pre">name</span></code> in-place.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start deserializing a nested class inside the current class.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">defaultSerializer.AggregateSerializer.startClass</span></code> for details
on inheritance on the default format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new AggregateDeserializer</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.endClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current class by reading the character <code class="docutils literal notranslate"><span class="pre">}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.defaultDeserializer.AggregateDeserializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.defaultDeserializer.AggregateDeserializer.endRecord" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current record by reading the character <code class="docutils literal notranslate"><span class="pre">)</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing a tuple by reading the character <code class="docutils literal notranslate"><span class="pre">(</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.TupleDeserializer" title="IO.TupleDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">TupleDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.TupleDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleDeserializer</span></span><a class="headerlink" href="#IO.TupleDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> to provide the API for deserializing tuples.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">defaultSerializer.TupleSerializer</span></code> for details of the default format
for tuples.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.TupleDeserializer.readElement">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.TupleDeserializer.readElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the tuple.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.TupleDeserializer.endTuple">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.TupleDeserializer.endTuple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current tuple by reading the character <code class="docutils literal notranslate"><span class="pre">)</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing a list by reading the character <code class="docutils literal notranslate"><span class="pre">[</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.ListDeserializer" title="IO.ListDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ListDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.ListDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListDeserializer</span></span><a class="headerlink" href="#IO.ListDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startList</span></code> to provide the API for deserializing lists.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">defaultSerializer.ListSerializer</span></code> for details of the default format
for lists.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ListDeserializer.readElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ListDeserializer.readElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the list.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ListDeserializer.endList">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ListDeserializer.endList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current list by reading the character <code class="docutils literal notranslate"><span class="pre">]</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ListDeserializer.hasMore">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ListDeserializer.hasMore" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.ArrayDeserializer" title="IO.ArrayDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.ArrayDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArrayDeserializer</span></span><a class="headerlink" href="#IO.ArrayDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startArray</span></code> to provide the API for deserializing arrays.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">defaultSerializer.ArraySerializer</span></code> for details of the default format
for arrays.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArrayDeserializer.startDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArrayDeserializer.startDim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Inform the <code class="docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code> to start deserializing a new dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArrayDeserializer.endDim">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArrayDeserializer.endDim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArrayDeserializer.readElement">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArrayDeserializer.readElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize an element of the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the array.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArrayDeserializer.endArray">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.ArrayDeserializer.endArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing a map by reading the character <code class="docutils literal notranslate"><span class="pre">{</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.MapDeserializer" title="IO.MapDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">MapDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.MapDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapDeserializer</span></span><a class="headerlink" href="#IO.MapDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startMap</span></code> to provide the API for deserializing maps.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">defaultSerializer.MapSerializer</span></code> for details of the default
format for map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapDeserializer.readKey">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">keyType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">keyType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapDeserializer.readKey" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a key of type <code class="docutils literal notranslate"><span class="pre">keyType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">key</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">key</span></code> in-place as a key of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapDeserializer.readValue">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">valType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">valType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapDeserializer.readValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a value of type <code class="docutils literal notranslate"><span class="pre">valType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">value</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">value</span></code> in-place as a value of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapDeserializer.endMap">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapDeserializer.endMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current map by reading the character <code class="docutils literal notranslate"><span class="pre">}</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.MapDeserializer.hasMore">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.MapDeserializer.hasMore" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Behavior of ‘hasMore’ is undefined when called between <code class="docutils literal notranslate"><span class="pre">readKey</span></code> and
<code class="docutils literal notranslate"><span class="pre">readValue</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.DefaultDeserializer">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">DefaultDeserializer</span></span> <span class="pre">=</span> <span class="pre">defaultDeserializer</span><a class="headerlink" href="#IO.DefaultDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘DefaultDeserializer’ is deprecated; please use ‘defaultDeserializer’ instead</p>
</div>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.warnBinaryStructured">
<em class="property"><span class="pre">config</span> <span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">warnBinaryStructured</span></span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">true</span><a class="headerlink" href="#IO.warnBinaryStructured" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This config param is unstable and may be removed without advance notice</p>
</div>
<p>This config param allows users to disable a warning for reading and writing
classes and strings with <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code> and <code class="docutils literal notranslate"><span class="pre">binaryDeserializer</span></code>
following a format change in the 1.33 release.</p>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">binarySerializer</span></span><a class="headerlink" href="#IO.binarySerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>A binary Serializer that implements a simple binary format.</p>
<p>This Serializer supports an <code class="docutils literal notranslate"><span class="pre">endian</span></code> field which may be configured at
execution time.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Serializers and their usage.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the 1.32 release this format included bytes representing the length of
a string. Also, classes were serialized beginning with a single byte to
indicate whether the class value was <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This behavior was changed
in the subsequent release to provide users with a more flexible
serializer that did not insert bytes that the user did not request. A
compile-time warning will be issued to indicate that this behavior has
changed. Users can recompile with <code class="docutils literal notranslate"><span class="pre">-swarnBinaryStructured=false</span></code> to
silence the warning.</p>
<p>To mimic the old behavior, please use the unstable
<a class="reference internal" href="../packages/ObjectSerialization.html#module-ObjectSerialization" title="ObjectSerialization: The ObjectSerialization module provides an objectSerializer and"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">ObjectSerialization</span></code></a> module.</p>
</div>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.binarySerializer.endian">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">endian</span></span><span class="pre">:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span><a class="headerlink" href="#IO.binarySerializer.endian" title="Permalink to this definition">¶</a></dt>
<dd><p>‘endian’ represents the endianness of the binary output produced by this
Serializer.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.serializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">serializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(serializerType</span> <span class="pre">=</span> <span class="pre">binarySerializer</span></em>, <em class="sig-param"><span class="pre">locking</span> <span class="pre">=</span> <span class="pre">false</span></em>, <em class="sig-param"><span class="pre">?)</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.serializeValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code> with <code class="docutils literal notranslate"><span class="pre">writer</span></code>.</p>
<p>Numeric values like integers, real numbers, and complex numbers are
serialized directly to the associated <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> as binary data in the
specified endianness.</p>
<p>Booleans are serialized as single byte unsigned values of either <code class="docutils literal notranslate"><span class="pre">0</span></code> or
<code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> values are serialized as a raw sequence of bytes that does not
include a null terminator, nor any bytes representing length. This means
that <code class="docutils literal notranslate"><span class="pre">string</span></code> values cannot be deserialized without manual intervention
by users to decide how their strings should be stored such that they can
be deserialized.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nil</span></code> value is serialized as a single unsigned byte of value <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Classes and records will have their <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method invoked, passing
in <code class="docutils literal notranslate"><span class="pre">writer</span></code> and this Serializer as arguments. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more on the <code class="docutils literal notranslate"><span class="pre">serialize</span></code>
method.</p>
<p>Classes and records are expected to implement the <code class="docutils literal notranslate"><span class="pre">writeSerializable</span></code>
interface. The <code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface is also acceptable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Serializing and deserializing enums is not stable in this format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> used to write serialized output.</p></li>
<li><p><strong>val</strong> – The value to be serialized.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a class and return a new <code class="docutils literal notranslate"><span class="pre">AggregateSerializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binarySerializer.AggregateSerializer" title="IO.binarySerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.startRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serializing a record and return a new <code class="docutils literal notranslate"><span class="pre">AggregateSerializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>name</strong> – The name of the record type.</p></li>
<li><p><strong>size</strong> – The number of fields in the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binarySerializer.AggregateSerializer" title="IO.binarySerializer.AggregateSerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateSerializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateSerializer</span></span><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startClass</span></code> or <code class="docutils literal notranslate"><span class="pre">startRecord</span></code> to provide the API for
serializing classes or records.</p>
<p>In this simple binary format, classes and records do not begin or end with
any bytes indicating size, and instead serialize their field values in
<code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<p>For example, a record with two <code class="docutils literal notranslate"><span class="pre">uint(8)</span></code> fields with values <code class="docutils literal notranslate"><span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">2</span></code> would be serialized as <code class="docutils literal notranslate"><span class="pre">0x01</span></code> followed by <code class="docutils literal notranslate"><span class="pre">0x02</span></code> (in raw binary).</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.writeField">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">const</span> <span class="pre">field:</span> <span class="pre">?T</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.writeField" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">field</span></code> in <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start serializing a nested class inside the current class. In this
binary format, this has no impact on the serialized output.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.endClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of this class.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binarySerializer.AggregateSerializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binarySerializer.AggregateSerializer.endRecord" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of this record.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start serializing a tuple and return a new <code class="docutils literal notranslate"><span class="pre">TupleSerializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new TupleSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleSerializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> to provide the API for serializing tuples.</p>
<p>In this simple binary format, tuples do not begin or end with any bytes
indicating size, and instead serialize their elements sequentially in
<code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?T</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Ends serialization of the current tuple.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start serializing a list by serializing <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new ListSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListSerializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startList</span></code> to provide the API for serializing lists.</p>
<p>In this simple binary format, lists begin with the serialization of an
<code class="docutils literal notranslate"><span class="pre">int</span></code> representing the size of the list. This data is then followed by
the binary serialization of the specified number of elements.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Ends serialization of  the current list.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start serializing an array and return a new <code class="docutils literal notranslate"><span class="pre">ArraySerializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of elements in the array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new ArraySerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArraySerializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startArray</span></code> to provide the API for serializing arrays.</p>
<p>In this simple binary format, arrays are serialized element by element
in the order indicated by the caller of <code class="docutils literal notranslate"><span class="pre">writeElement</span></code>. Dimensions and
the start or end of the array are not represented.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Start serializing a new dimension of the array.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Ends serialization of this dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">element:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArraySerializer.writeBulkElements">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeBulkElements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data:</span> <span class="pre">c_ptr(?eltType)</span></em>, <em class="sig-param"><span class="pre">numElements:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isNumericType(eltType)</span></em><a class="headerlink" href="#IO.ArraySerializer.writeBulkElements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">numElements</span></code> number of elements in <code class="docutils literal notranslate"><span class="pre">data</span></code>, provided that
the element type of <code class="docutils literal notranslate"><span class="pre">data</span></code> is a numeric type.</p>
<p>This performance-motivated implementation of the optional
<code class="docutils literal notranslate"><span class="pre">writeBulkElements</span></code> will write the elements of <code class="docutils literal notranslate"><span class="pre">data</span></code> in the order
in which they are represented in memory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only optimized for the case where the
<code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code> has been configured for <code class="docutils literal notranslate"><span class="pre">native</span></code> endianness.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Ends serialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">writer:</span> <span class="pre">fileWriter(?)</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start serializing a map by serializing <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>writer</strong> – The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> to be used when serializing.</p></li>
<li><p><strong>size</strong> – The number of entries in the map.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new MapSerializer</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapSerializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startMap</span></code> to provide the API for serializing maps.</p>
<p>In this simple binary format, maps begin with the serialization of an
<code class="docutils literal notranslate"><span class="pre">int</span></code> representing the size of the map. This data is then followed by the
binary serialization of the specified number of key-value pairs. The binary
serialization of a key-value pair has no structure, and simply consists of
the serialization of the key followed by the serialization of the value.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">key:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">key</span></code> in <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">writeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">val:</span> <span class="pre">?</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Serialize <code class="docutils literal notranslate"><span class="pre">val</span></code> in <code class="docutils literal notranslate"><span class="pre">binarySerializer</span></code>’s format.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Ends serialization of the current map.</p>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.BinarySerializer">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">BinarySerializer</span></span> <span class="pre">=</span> <span class="pre">binarySerializer</span><a class="headerlink" href="#IO.BinarySerializer" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘BinarySerializer’ is deprecated; please use ‘binarySerializer’ instead</p>
</div>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">binaryDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>A binary Deserializer that implements a simple binary format.</p>
<p>This Deserializer supports an <code class="docutils literal notranslate"><span class="pre">endian</span></code> field which may be configured at
execution time.</p>
<p>See <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">the serializers technote</span></a> for a general overview
of Deserializers and their usage.</p>
<p>Otherwise, please refer to <a class="reference internal" href="#IO.binarySerializer" title="IO.binarySerializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">binarySerializer</span></code></a> for a description of the
binary format. Individual methods on this type may clarify relevant behavior
specific to deserialization</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deserializing <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> types will result in an
IllegalArgumentError because these types cannot currently be deserialized
with the raw nature of the format.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the 1.32 release this format included bytes representing the length of
a string. Also, classes were serialized beginning with a single byte to
indicate whether the class value was <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This behavior was changed
in the subsequent release to provide users with a more flexible
deserializer that did not read bytes that the user did not request. A
compile-time warning will be issued to indicate that this behavior has
changed. Users can recompile with <code class="docutils literal notranslate"><span class="pre">-swarnBinaryStructured=false</span></code> to
silence the warning.</p>
<p>To mimic the old behavior, please use the unstable
<a class="reference internal" href="../packages/ObjectSerialization.html#module-ObjectSerialization" title="ObjectSerialization: The ObjectSerialization module provides an objectSerializer and"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">ObjectSerialization</span></code></a> module.</p>
</div>
<dl class="chpl attribute">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.endian">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">endian</span></span><span class="pre">:</span> <span class="pre">IO.endianness</span> <span class="pre">=</span> <span class="pre">IO.endianness.native</span><a class="headerlink" href="#IO.binaryDeserializer.endian" title="Permalink to this definition">¶</a></dt>
<dd><p>‘endian’ represents the endianness that this Deserializer should use when
deserializing input.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.deserializeType">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">readType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">readType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.deserializeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize type <code class="docutils literal notranslate"><span class="pre">readType</span></code> with <code class="docutils literal notranslate"><span class="pre">reader</span></code>.</p>
<p>Classes and records will be deserialized using an appropriate initializer,
passing in <code class="docutils literal notranslate"><span class="pre">reader</span></code> and this Deserializer as arguments. If an
initializer is unavailable, this method may invoke the class or record’s
<code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. Please see the <a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> interfaces (or both). The
<code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface is also acceptable.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> from which types are deserialized.</p></li>
<li><p><strong>readType</strong> – The type to be deserialized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A value of type <code class="docutils literal notranslate"><span class="pre">readType</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.deserializeValue">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">deserializeValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">val:</span> <span class="pre">?readType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.deserializeValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize from <code class="docutils literal notranslate"><span class="pre">reader</span></code> directly into <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
<p>Like <a class="reference internal" href="#IO.binaryDeserializer.deserializeType" title="IO.binaryDeserializer.deserializeType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">deserializeType</span></code></a>, but reads into an initialized value rather
than creating a new value. For classes and records, this method will first
attempt to invoke a <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method. If the <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method
is unavailable, this method may fall back on invoking a suitable
initializer and assigning the resulting value into <code class="docutils literal notranslate"><span class="pre">val</span></code>.. Please see the
<a class="reference internal" href="../../technotes/ioSerializers.html#ioserializers"><span class="std std-ref">serializers technote</span></a> for more.</p>
<p>Classes and records are expected to implement either the
<code class="docutils literal notranslate"><span class="pre">readDeserializable</span></code> or <code class="docutils literal notranslate"><span class="pre">initDeserializable</span></code> interfaces (or both). The
<code class="docutils literal notranslate"><span class="pre">serializable</span></code> interface is also acceptable.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> from which values are deserialized.</p></li>
<li><p><strong>val</strong> – The value into which this Deserializer will deserialize.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Start deserializing a class by returning an <code class="docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the class type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.startRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.startRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Start deserializing a record by returning an <code class="docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p></li>
<li><p><strong>name</strong> – The name of the record type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.binaryDeserializer.AggregateDeserializer" title="IO.binaryDeserializer.AggregateDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">AggregateDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">AggregateDeserializer</span></span><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startClass</span></code> or <code class="docutils literal notranslate"><span class="pre">startRecord</span></code> to provide the API for
deserializing classes or records.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">binarySerializer.AggregateSerializer</span></code> for details of the
binary format for classes and records.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.readField">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">type</span> <span class="pre">fieldType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fieldType</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.readField" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize and return a value of type <code class="docutils literal notranslate"><span class="pre">fieldType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">field</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">field</span></code> in-place.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.startClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader</span></em>, <em class="sig-param"><span class="pre">name:</span> <span class="pre">string</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.startClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Start deserializing a nested class inside the current class.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">binarySerializer.AggregateSerializer.startClass</span></code> for details
on inheritance on the binary format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new AggregateDeserializer</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.endClass">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.endClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current class.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.binaryDeserializer.AggregateDeserializer.endRecord">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endRecord</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.binaryDeserializer.AggregateDeserializer.endRecord" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>End deserialization of the current record.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing a tuple by returning a <code class="docutils literal notranslate"><span class="pre">TupleDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.TupleDeserializer" title="IO.TupleDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">TupleDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">TupleDeserializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startTuple</span></code> to provide the API for deserializing tuples.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">binarySerializer.TupleSerializer</span></code> for details of the binary format
for tuples.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize an element of the tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the tuple.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endTuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>End deserialization of the current tuple.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing a list by returning a <code class="docutils literal notranslate"><span class="pre">ListDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.ListDeserializer" title="IO.ListDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ListDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ListDeserializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startList</span></code> to provide the API for deserializing lists.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">binarySerializer.ListSerializer</span></code> for details of the binary format
for lists.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize an element of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the list.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>End deserialization of the current list.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p>A <code class="docutils literal notranslate"><span class="pre">BadFormatError</span></code> if there are remaining elements.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing an array by returning an <code class="docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.ArrayDeserializer" title="IO.ArrayDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">ArrayDeserializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startArray</span></code> to provide the API for deserializing arrays.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">binarySerializer.ArraySerializer</span></code> for details of the binary format
for arrays.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Inform the <code class="docutils literal notranslate"><span class="pre">ArrayDeserializer</span></code> to start deserializing a new dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endDim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>End deserialization of the current dimension.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">eltType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">eltType</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize an element of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A deserialized value of type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">element</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">element</span></code> in-place as an element of the array.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.ArrayDeserializer.readBulkElements">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readBulkElements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data:</span> <span class="pre">c_ptr(?eltType)</span></em>, <em class="sig-param"><span class="pre">numElements:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isNumericType(eltType)</span></em><a class="headerlink" href="#IO.ArrayDeserializer.readBulkElements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">numElements</span></code> number of elements into <code class="docutils literal notranslate"><span class="pre">data</span></code>, provided
that the element type of <code class="docutils literal notranslate"><span class="pre">data</span></code> is a numeric type.</p>
<p>This performance-motivated implementation of the optional
<code class="docutils literal notranslate"><span class="pre">readBulkElements</span></code> will read the elements of <code class="docutils literal notranslate"><span class="pre">data</span></code> in the order in
which they are represented in memory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only optimized for the case where the
<code class="docutils literal notranslate"><span class="pre">binaryDeserializer</span></code> has been configured for <code class="docutils literal notranslate"><span class="pre">native</span></code> endianness.</p>
</div>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>End deserialization of the current array.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">startMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reader:</span> <span class="pre">fileReader(?)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Start deserializing a map by returning a <code class="docutils literal notranslate"><span class="pre">MapDeserializer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>reader</strong> – The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> to use when deserializing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new <a class="reference internal" href="#IO.MapDeserializer" title="IO.MapDeserializer"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">MapDeserializer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">record</span> </em><span class="sig-name descname"><span class="pre">MapDeserializer</span></span></dt>
<dd><p>Returned by <code class="docutils literal notranslate"><span class="pre">startMap</span></code> to provide the API for deserializing maps.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">binarySerializer.MapSerializer</span></code> for details of the binary
format for map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">keyType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">keyType</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize and return a key of type <code class="docutils literal notranslate"><span class="pre">keyType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> <span class="pre">ref</span> </em><span class="sig-name descname"><span class="pre">readKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">key</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">key</span></code> in-place as a key of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">valType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">valType</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize and return a value of type <code class="docutils literal notranslate"><span class="pre">valType</span></code>.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">value</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>Deserialize <code class="docutils literal notranslate"><span class="pre">value</span></code> in-place as a value of the map.</p>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">endMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<p>End deserialization of the current map.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p>A <code class="docutils literal notranslate"><span class="pre">BadFormatError</span></code> if there are entries remaining.</p>
</dd>
</dl>
<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">hasMore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are more elements to read.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Behavior of ‘hasMore’ is undefined when called between <code class="docutils literal notranslate"><span class="pre">readKey</span></code> and
<code class="docutils literal notranslate"><span class="pre">readValue</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.BinaryDeserializer">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">BinaryDeserializer</span></span> <span class="pre">=</span> <span class="pre">binaryDeserializer</span><a class="headerlink" href="#IO.BinaryDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘BinaryDeserializer’ is deprecated; please use ‘binaryDeserializer’ instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.withDeserializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">withDeserializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">deserializerType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(this._kind,</span> <span class="pre">this.locking,</span> <span class="pre">deserializerType)</span><a class="headerlink" href="#IO.fileReader.withDeserializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return an alias of this <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> configured to use
<code class="docutils literal notranslate"><span class="pre">deserializerType</span></code> for deserialization. The provided <code class="docutils literal notranslate"><span class="pre">deserializerType</span></code>
must be able to be default-initialized.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">withDeserializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(this._kind,</span> <span class="pre">this.locking,</span> <span class="pre">dt)</span></dt>
<dd><p>Create and return an alias of this <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> configured to use
<code class="docutils literal notranslate"><span class="pre">deserializer</span></code> for deserialization.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.withSerializer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">withSerializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">serializerType</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(this._kind,</span> <span class="pre">this.locking,</span> <span class="pre">serializerType)</span><a class="headerlink" href="#IO.fileWriter.withSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return an alias of this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> configured to use
<code class="docutils literal notranslate"><span class="pre">serializerType</span></code> for serialization. The provided <code class="docutils literal notranslate"><span class="pre">serializerType</span></code> must be
able to be default-initialized.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">withSerializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(this._kind,</span> <span class="pre">this.locking,</span> <span class="pre">st)</span></dt>
<dd><p>Create and return an alias of this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> configured to use
<code class="docutils literal notranslate"><span class="pre">serializer</span></code> for serialization.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is an error for the returned alias to outlive the original <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</div>
</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.ioNewline">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">ioNewline</span></span> <span class="pre">=</span> <span class="pre">chpl_ioNewline</span><a class="headerlink" href="#IO.ioNewline" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.ioNewline" title="IO.ioNewline"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioNewline</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.fileReader.readNewline" title="IO.fileReader.readNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readNewline</span></code></a>, <a class="reference internal" href="#IO.fileReader.matchNewline" title="IO.fileReader.matchNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.matchNewline</span></code></a>, or <a class="reference internal" href="#IO.fileWriter.writeNewline" title="IO.fileWriter.writeNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeNewline</span></code></a> instead</p>
</div>
<p>Represents a newline character or character sequence (ie <code class="docutils literal notranslate"><span class="pre">\n</span></code>). I/O routines
(such as <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a> and <a class="reference internal" href="#IO.fileWriter.write" title="IO.fileWriter.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.write</span></code></a>) can use arguments
of this type in order to read or write a newline. This is different from <code class="docutils literal notranslate"><span class="pre">\n</span></code>
because an ioNewline always produces an actual newline, but in some cases
writing <code class="docutils literal notranslate"><span class="pre">\n</span></code> will produce an escaped string (such as <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>).</p>
<p>When reading an ioNewline, read routines will skip any character sequence
(including, e.g., letters and numbers) to get to the newline character unless
<code class="docutils literal notranslate"><span class="pre">skipWhitespaceOnly</span></code> is set to true.</p>
</dd></dl>

<dl class="chpl type">
<dt class="sig sig-object chpl" id="IO.ioLiteral">
<em class="property"><span class="pre">type</span> </em><span class="sig-name descname"><span class="pre">ioLiteral</span></span> <span class="pre">=</span> <span class="pre">chpl_ioLiteral</span><a class="headerlink" href="#IO.ioLiteral" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.ioLiteral" title="IO.ioLiteral"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">ioLiteral</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a>, <a class="reference internal" href="#IO.fileReader.matchLiteral" title="IO.fileReader.matchLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.matchLiteral</span></code></a>, or <a class="reference internal" href="#IO.fileWriter.writeLiteral" title="IO.fileWriter.writeLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeLiteral</span></code></a> instead</p>
</div>
<p>Used to represent a constant string we want to read or write.</p>
<p>When writing, the <code class="docutils literal notranslate"><span class="pre">ioLiteral</span></code> is output without any quoting or escaping.</p>
<p>When reading, the <code class="docutils literal notranslate"><span class="pre">ioLiteral</span></code> must be matched exactly - or else the read call
will return an error for incorrectly formatted input</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.lock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a fileReader’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the lock could not be acquired.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.lock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a fileWriter’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the lock could not be acquired.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.unlock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">unlock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a fileReader’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.unlock">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">unlock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a fileWriter’s lock. See <a class="reference internal" href="#locking-filereaders-and-filewriters"><span class="std std-ref">Locking Behavior of FileReaders and FileWriters</span></a>
for more details.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.offset">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int(64)</span><a class="headerlink" href="#IO.fileReader.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset of a fileReader.</p>
<p>If the fileReader can be used by multiple tasks, take care when doing
operations that rely on the fileReader’s current offset. To prevent race
conditions, lock the fileReader with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lock</span></code></a> before calling
<a class="reference internal" href="#IO.fileReader.offset" title="IO.fileReader.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.offset</span></code></a>, then unlock it afterwards with
<a class="reference internal" href="#IO.fileReader.unlock" title="IO.fileReader.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.unlock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the current offset of the fileReader</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.offset">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int(64)</span><a class="headerlink" href="#IO.fileWriter.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset of a fileWriter.</p>
<p>If the fileWriter can be used by multiple tasks, take care when doing
operations that rely on the fileWriter’s current offset. To prevent race
conditions, lock the fileWriter with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a> before calling
<a class="reference internal" href="#IO.fileWriter.offset" title="IO.fileWriter.offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.offset</span></code></a>, then unlock it afterwards with
<a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the current offset of the fileWriter</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.advance">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">advance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">amount:</span> <span class="pre">int(64)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> offset forward.</p>
<p>This routine will consume the next <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes from the file, storing
them in the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s buffer. This can be useful for advancing to some
known offset in the file before reading.</p>
<p>Note that calling <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a> before advancing will cause at
least <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes to be retained in memory until
<a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a> are called. As such,
it is typical to advance by a small number of bytes during an I/O transaction.</p>
<p>To make large adjustments to the offset, consider creating a new
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> or using <a class="reference internal" href="#IO.fileReader.seek" title="IO.fileReader.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">seek</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If EOF is reached before the requested number of bytes can
be consumed. The offset will be left at EOF.</p></li>
<li><p><strong>SystemError</strong> – For other failures, for which fileReader offset is not
moved.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.advance">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">advance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">amount:</span> <span class="pre">int(64)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> offset forward.</p>
<p>This routine will populate the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s buffer as the offset is moved
forward by <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes. The buffer can be populated with any of the
following data depending on the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s configuration and whether
it was marked before advancing:</p>
<ul class="simple">
<li><p>zeros</p></li>
<li><p>bytes directly from the file</p></li>
<li><p>bytes from a previously buffered portion of the file</p></li>
</ul>
<p>The contents of the buffer will subsequently be written to the file by the
buffering mechanism.</p>
<p>Note that calling <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a> before advancing will cause at
least <code class="docutils literal notranslate"><span class="pre">amount</span></code> bytes to be retained in memory until
<a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a> are called. As such,
it is typical to advance by a small number of bytes during an I/O transaction.</p>
<p>To make large adjustments to the offset, consider creating a new
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> or using <a class="reference internal" href="#IO.fileWriter.seek" title="IO.fileWriter.seek"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">seek</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – If EOF is reached before the offset can be advanced by the
requested number of bytes. The offset will be left at EOF.</p></li>
<li><p><strong>SystemError</strong> – For other failures, for which fileWriter offset is not
moved.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.advanceThrough">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">advanceThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.advanceThrough" title="Permalink to this definition">¶</a></dt>
<dd><p>Read until a separator is found, leaving the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset just
after it.</p>
<p>If the separator cannot be found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left at EOF
and an <code class="docutils literal notranslate"><span class="pre">UnexpectedEofError</span></code> is thrown.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation is faster for single-byte <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
separators.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>
or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the requested <code class="docutils literal notranslate"><span class="pre">separator</span></code> could not
be found.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.advanceTo">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">advanceTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.advanceTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read until a separator is found, leaving the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset just before it.</p>
<p>If the separator cannot be found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left at EOF and an
<code class="docutils literal notranslate"><span class="pre">UnexpectedEofError</span></code> is thrown.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation is faster for single-byte <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
separators.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the requested <code class="docutils literal notranslate"><span class="pre">separator</span></code> could not be found.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.mark">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">mark</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.mark" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p><em>Mark</em> a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> - that is, save the current offset of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> on its <em>mark stack</em>.</p>
<p>The <em>mark stack</em> stores several file offsets. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> will keep
the region of the file between its minimum and maximum <em>mark stack</em> values
buffered in memory so that IO operations can be undone. As a result, it is
possible to perform <em>I/O transactions</em> on a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>. The basic steps
for an <em>I/O transaction</em> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>mark</em> the current offset with <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a></p></li>
<li><p>do something speculative (e.g. try to read 200 bytes of anything followed
by a ‘B’)</p></li>
<li><p>if the speculative operation was successful, commit the changes by
calling <a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.commit</span></code></a></p></li>
<li><p>if the speculative operation was not successful, go back to the <em>mark</em> by
calling <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.revert</span></code></a>. Subsequent I/O operations will work
as though nothing happened.</p></li>
</ul>
</div></blockquote>
<p>If a fileReader has <code class="docutils literal notranslate"><span class="pre">locking==true</span></code>, <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> should only
be called once it has been locked with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.lock</span></code></a>. The
fileReader should not be unlocked with <a class="reference internal" href="#IO.fileReader.unlock" title="IO.fileReader.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.unlock</span></code></a> until
after the mark has been committed with <a class="reference internal" href="#IO.fileReader.commit" title="IO.fileReader.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or reverted
with <a class="reference internal" href="#IO.fileReader.revert" title="IO.fileReader.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a>.</p>
<p>See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for more.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that it is possible to request an entire file be buffered in memory
using this feature, for example by <em>marking</em> at offset=0 and then
advancing to the end of the file. It is important to be aware of these
memory space requirements.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The offset that was marked</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – if marking the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> failed</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.mark">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">mark</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.mark" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p><em>Mark</em> a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> - that is, save the current offset of the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> on its <em>mark stack</em>.</p>
<p>The <em>mark stack</em> stores several file offsets. The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> will keep
the region of the file between its minimum and maximum <em>mark stack</em> values
buffered in memory so that IO operations can be undone. As a result, it
is possible to perform <em>I/O transactions</em> on a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>. The basic
steps for an <em>I/O transaction</em> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>mark</em> the current offset with <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a></p></li>
<li><p>do something speculative (e.g. try to write 200 bytes)</p></li>
<li><p>if the speculative operation was successful, commit the changes by
calling <a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.commit</span></code></a></p></li>
<li><p>if the speculative operation was not successful, go back to the <em>mark</em> by
calling <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.revert</span></code></a>. Subsequent I/O operations will work
as though nothing happened.</p></li>
</ul>
</div></blockquote>
<p>If a fileWriter has <code class="docutils literal notranslate"><span class="pre">locking==true</span></code>, <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> should only
be called once it has been locked with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.lock</span></code></a>. The
fileWriter should not be unlocked with <a class="reference internal" href="#IO.fileWriter.unlock" title="IO.fileWriter.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.unlock</span></code></a> until
after the mark has been committed with <a class="reference internal" href="#IO.fileWriter.commit" title="IO.fileWriter.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">commit</span></code></a> or reverted
with <a class="reference internal" href="#IO.fileWriter.revert" title="IO.fileWriter.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">revert</span></code></a>.</p>
<p>See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for more.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that it is possible to request an entire file be buffered in memory
using this feature, for example by <em>marking</em> at offset=0 and then
advancing to the end of the file. It is important to be aware of these
memory space requirements.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The offset that was marked</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – if marking the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> failed</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.revert">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">revert</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s <em>mark stack</em>
and adjusting its position to that offset. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileReader that has already
been marked. If called on a fileReader with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileReader
should have already been locked manually with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.revert">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">revert</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s <em>mark stack</em>
and adjusting its position to that offset. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileWriter that has already
been marked. If called on a fileWriter with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileWriter
should have already been locked manually with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.commit">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s <em>mark stack</em>
and leaving its position in the file unchanged. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileReader that has already
been marked. If called on a fileReader with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileReader
should have already been locked manually with <a class="reference internal" href="#IO.fileReader.lock" title="IO.fileReader.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.commit">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em> by popping from the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s <em>mark stack</em>
and leaving its position in the file unchanged. See <a class="reference internal" href="#io-transactions"><span class="std std-ref">I/O Transactions</span></a> for
more.</p>
<p>This routine should only be called on a fileWriter that has already
been marked. If called on a fileWriter with <code class="docutils literal notranslate"><span class="pre">locking=true</span></code>, the fileWriter
should have already been locked manually with <a class="reference internal" href="#IO.fileWriter.lock" title="IO.fileWriter.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">lock</span></code></a> before
<a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">mark</span></code></a> was called.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.seek">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">seek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.seek" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a>’s region. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s buffer will be
discarded.</p>
<p>This routine has the following constraints:</p>
<blockquote>
<div><ul class="simple">
<li><p>the underlying file must be seekable (sockets and pipes are not seekable)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> must be non-locking (to avoid race conditions if two
tasks seek and read simultaneously)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> must not be marked (see: <a class="reference internal" href="#IO.fileReader.mark" title="IO.fileReader.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.mark</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset needs to be updated during an I/O transaction
or if discarding the buffer will incur a performance penalty, consider using
<a class="reference internal" href="#IO.fileReader.advance" title="IO.fileReader.advance"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.advance</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>region</strong> – the new region, measured in bytes and counting from 0. An upper
bound can be omitted (e.g., <code class="docutils literal notranslate"><span class="pre">r.seek(range=42..)</span></code>). See
<a class="reference internal" href="#filereader-filewriter-regions"><span class="std std-ref">region</span></a> for more.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – if seeking failed. Possible reasons include
that the file is not seekable, or that the
fileReader is marked.</p></li>
<li><p><strong>IllegalArgumentError</strong> – if region argument did not have a lower bound</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.seek">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">seek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.seek" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a>’s region. The <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s buffer will be
discarded.</p>
<p>This routine has the following constraints:</p>
<blockquote>
<div><ul class="simple">
<li><p>the underlying file must be seekable (sockets and pipes are not seekable)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> must be non-locking (to avoid race conditions if two
tasks seek and read simultaneously)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> must not be marked (see: <a class="reference internal" href="#IO.fileWriter.mark" title="IO.fileWriter.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.mark</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset needs to be updated during an I/O transaction
or if discarding the buffer will incur a performance penalty, consider using
<a class="reference internal" href="#IO.fileWriter.advance" title="IO.fileWriter.advance"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.advance</span></code></a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>region</strong> – the new region, measured in bytes and counting from 0. An upper
bound can be omitted (e.g., <code class="docutils literal notranslate"><span class="pre">w.seek(range=42..)</span></code>). See
<a class="reference internal" href="#filereader-filewriter-regions"><span class="std std-ref">region</span></a> for more.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – if seeking failed. Possible reasons include
that the file is not seekable, or that the
fileReader is marked.</p></li>
<li><p><strong>IllegalArgumentError</strong> – if region argument did not have a lower bound</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader._style">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">_style</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">iostyle</span><a class="headerlink" href="#IO.fileReader._style" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>fileReader._style is deprecated because it returns a type that is deprecated</p>
</div>
<p>Return the current style used by a fileReader. This function should only be
called on a locked fileReader.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter._style">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">_style</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">iostyle</span><a class="headerlink" href="#IO.fileWriter._style" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>fileWriter._style is deprecated because it returns a type that is deprecated</p>
</div>
<p>Return the current style used by a fileWriter. This function should only be
called on a locked fileWriter.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader._set_style">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">_set_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader._set_style" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>fileReader._set_style is deprecated because its purpose involves a deprecated type</p>
</div>
<p>Set the style associated with a fileReader. This function should only
be called on a locked fileReader.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter._set_style">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">_set_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter._set_style" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>fileWriter._set_style is deprecated because its purpose involves a deprecated type</p>
</div>
<p>Set the style associated with a fileWriter. This function should only
be called on a locked fileWriter.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readWriteThisFromLocale">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readWriteThisFromLocale</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.readWriteThisFromLocale" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readWriteThisFromLocale’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Return the locale on which an ongoing I/O was started with a fileReader.
This method will return <code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> unless it is called on a fileReader
that is the formal argument to a <cite>readThis</cite> method.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.readWriteThisFromLocale">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">readWriteThisFromLocale</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileWriter.readWriteThisFromLocale" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readWriteThisFromLocale’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Return the locale on which an ongoing I/O was started with a fileWriter.
This method will return <code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> unless it is called on a fileWriter
that is the formal argument to a <cite>writeThis</cite> method.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openReader">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">_iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">start:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">0</span></em>, <em class="sig-param"><span class="pre">end:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">max(int(64))</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(kind,</span> <span class="pre">locking,</span> <span class="pre">defaultSerializeType(false,</span> <span class="pre">kind))</span> <span class="pre">throws</span><a class="headerlink" href="#IO.openReader" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>openReader with a ‘style’ argument is deprecated, please pass a Deserializer to the ‘deserializer’ argument instead</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(locking,</span> <span class="pre">dt)</span> <span class="pre">throws</span></dt>
<dd><p>Open a file at a particular path and return a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> and then
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> on the resulting file.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – which file to open (for example, “some/file.txt”).</p></li>
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileReader should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>region</strong> – zero-based byte offset indicating where in the file the
fileReader should start and stop reading. Defaults to
<code class="docutils literal notranslate"><span class="pre">0..</span></code>, meaning from the start of the file to no specified end
point.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open fileReader to the requested resource.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – Thrown if part of the provided path did not exist</p></li>
<li><p><strong>PermissionError</strong> – Thrown if part of the provided path had inappropriate
permissions</p></li>
<li><p><strong>NotADirectoryError</strong> – Thrown if part of the provided path was expected to
be a directory but was not</p></li>
<li><p><strong>SystemError</strong> – Thrown if a fileReader could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if trying to read explicitly prior to byte
0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false</span></em>, <em class="sig-param"><span class="pre">kind)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(kind,</span> <span class="pre">locking,</span> <span class="pre">dt)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>openReader with a ‘kind’ argument is deprecated, please use Deserializers that support endianness instead</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.openWriter">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">start:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">0</span></em>, <em class="sig-param"><span class="pre">end:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">max(int(64))</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(kind,</span> <span class="pre">locking,</span> <span class="pre">defaultSerializeType(true,</span> <span class="pre">kind))</span> <span class="pre">throws</span><a class="headerlink" href="#IO.openWriter" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>openWriter with a ‘style’ argument is deprecated, please pass a Serializer to the ‘serializer’ argument instead</p>
</div>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(true)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(locking,</span> <span class="pre">st)</span> <span class="pre">throws</span></dt>
<dd><p>Open a file at a particular path and return a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> with <code class="docutils literal notranslate"><span class="pre">ioMode.cwr</span></code> and then
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> on the resulting file.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – which file to open (for example, “some/file.txt”).</p></li>
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileWriter should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>hints</strong> – optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open fileWriter to the requested resource.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – Thrown if part of the provided path did not exist</p></li>
<li><p><strong>PermissionError</strong> – Thrown if part of the provided path had inappropriate
permissions</p></li>
<li><p><strong>NotADirectoryError</strong> – Thrown if part of the provided path was expected to
be a directory but was not</p></li>
<li><p><strong>SystemError</strong> – Thrown if a fileWriter could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if trying to write explicitly prior to byte
0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">openWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(true</span></em>, <em class="sig-param"><span class="pre">kind)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(kind,</span> <span class="pre">locking,</span> <span class="pre">st)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>openWriter with a ‘kind’ argument is deprecated, please use Serializers that support endianness instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.reader">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">start:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">0</span></em>, <em class="sig-param"><span class="pre">end:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">max(int(64))</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(kind,</span> <span class="pre">locking)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.reader" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>reader with a ‘style’ argument is deprecated, please pass a Deserializer to the ‘deserializer’ argument instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(locking,</span> <span class="pre">dt)</span> <span class="pre">throws</span></dt>
<dd><p>Create a <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> that supports reading from a file. See
<a class="reference internal" href="#about-io-overview"><span class="std std-ref">I/O Overview</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">region=</span></code> argument defines the portion of the file that the fileReader
will read from.  This is a byte offset; the beginning of the file is at the
offset 0.  The default for this argument enables the fileReader to access the
entire file.</p>
<p>A fileReader will never read beyond its maximum end offset. In addition,
reading from a fileReader beyond the end of the underlying file will not
extend that file.  Reading beyond the end of the file or beyond the end
offset of the fileReader will produce the error <code class="docutils literal notranslate"><span class="pre">OS.EofError</span></code> (or just
return <cite>false</cite> in many cases such as <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a>) to indicate
that the end was reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileReader should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>region</strong> – zero-based byte offset indicating where in the file the
fileReader should start and stop reading. Defaults to
<code class="docutils literal notranslate"><span class="pre">0..</span></code> - meaning from the start of the file to no end point.</p></li>
<li><p><strong>hints</strong> – provide hints about the I/O that this fileReader will perform.
See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>. The default value of <cite>ioHintSet.empty</cite>
will cause the fileReader to use the hints provided when the
file was opened.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – Thrown if a fileReader could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if trying to read explicitly prior to
byte 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">deserializer:</span> <span class="pre">?dt</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(false</span></em>, <em class="sig-param"><span class="pre">kind)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileReader(kind,</span> <span class="pre">locking,</span> <span class="pre">dt)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>reader with a ‘kind’ argument is deprecated, please use Deserializers instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.writer">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">start:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">0</span></em>, <em class="sig-param"><span class="pre">end:</span> <span class="pre">int(64)</span> <span class="pre">=</span> <span class="pre">max(int(64))</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(kind,</span> <span class="pre">locking)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.file.writer" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>writer with a ‘style’ argument is deprecated, please pass a Serializer to the ‘serializer’ argument instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(true)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(locking,</span> <span class="pre">st)</span> <span class="pre">throws</span></dt>
<dd><p>Create a <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> that supports writing to a file. See
<a class="reference internal" href="#about-io-overview"><span class="std std-ref">I/O Overview</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">region=</span></code> argument defines the portion of the file that the fileWriter
will write to.  This is a byte offset; the beginning of the file is at the
offset 0.  The default for this argument enables the fileWriter to access the
entire file.</p>
<p>When a fileWriter writes to a file, it will replace file data that was
previously stored at the relevant offset. If the offset is beyond the
end of the file, the file will be extended.</p>
<p>A fileWriter will never write beyond its maximum end offset.  It will
extend the file only as necessary to store data written to the fileWriter. In
other words, specifying the high bound of the region argument here does not
impact the file size directly; it impacts only the section of the file that
this fileWriter can write to. After all fileWriters to a file are closed,
that file will have a size equal to the last offset written to by any
fileWriter.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locking</strong> – compile-time argument to determine whether or not the
fileWriter should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>region</strong> – zero-based byte offset indicating where in the file the
fileWriter should start and stop writing. Defaults to
<code class="docutils literal notranslate"><span class="pre">0..</span></code> - meaning from the start of the file to no specified end
point.</p></li>
<li><p><strong>hints</strong> – provide hints about the I/O that this fileWriter will perform.
See <a class="reference internal" href="#IO.ioHintSet" title="IO.ioHintSet"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ioHintSet</span></code></a>. The default value of <cite>ioHintSet.empty</cite>
will cause the fileWriter to use the hints provided when the
file was opened.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The region argument will ignore any specified stride other than 1.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SystemError</strong> – Thrown if a fileWriter could not be returned.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if trying to write explicitly prior to
byte 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">param</span> <span class="pre">kind</span> <span class="pre">=</span> <span class="pre">iokind.dynamic</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">locking</span> <span class="pre">=</span> <span class="pre">true</span></em>, <em class="sig-param"><span class="pre">region:</span> <span class="pre">range(?)</span> <span class="pre">=</span> <span class="pre">0..</span></em>, <em class="sig-param"><span class="pre">hints</span> <span class="pre">=</span> <span class="pre">ioHintSet.empty</span></em>, <em class="sig-param"><span class="pre">in</span> <span class="pre">serializer:</span> <span class="pre">?st</span> <span class="pre">=</span> <span class="pre">defaultSerializeVal(true</span></em>, <em class="sig-param"><span class="pre">kind)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">fileWriter(kind,</span> <span class="pre">locking,</span> <span class="pre">st)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>writer with a ‘kind’ argument is deprecated, please use Serializers instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readWriteLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readWriteLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lit:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ignoreWhiteSpace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readWriteLiteral" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.fileReader.readWriteLiteral" title="IO.fileReader.readWriteLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readWriteLiteral</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a> instead</p>
</div>
<p>Explicit call for reading or writing a literal. Equivalent to calling
<a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.readWriteLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">readWriteLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lit:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ignoreWhiteSpace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.readWriteLiteral" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.fileWriter.readWriteLiteral" title="IO.fileWriter.readWriteLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.readWriteLiteral</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.fileWriter.writeLiteral" title="IO.fileWriter.writeLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeLiteral</span></code></a> instead</p>
</div>
<p>Explicit call for reading or writing a literal. Equivalent to calling
<a class="reference internal" href="#IO.fileWriter.writeLiteral" title="IO.fileWriter.writeLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeLiteral</span></code></a></p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readLiteral" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the offset of a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> within the file by reading the exact
text of the given string <code class="docutils literal notranslate"><span class="pre">literal</span></code> from the fileReader.</p>
<p>If the string is not matched exactly, then the fileReader’s offset is
unchanged. In such cases a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> will be thrown, unless
the end of the fileReader is encountered in which case an <a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>
will be thrown.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the string to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if literal could not be matched.</p></li>
<li><p><strong>EofError</strong> – Thrown if end of fileReader is encountered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></dt>
<dd><p>Advances the offset of a fileReader by reading the exact bytes of the given
<code class="docutils literal notranslate"><span class="pre">literal</span></code> from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
<p>If the bytes are not matched exactly, then the fileReader’s offset is
unchanged. In such cases a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> will be thrown, unless
the end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered in which case an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a> will be thrown.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the bytes to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if literal could not be matched.</p></li>
<li><p><strong>EofError</strong> – Thrown if end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readNewline" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the offset of the fileReader by reading a newline.</p>
<p>If a newline is not matched exactly, then the fileReader’s offset is
unchanged. In such cases a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> will be thrown, unless
the end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered in which case an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a> will be thrown. By default this method will ignore
leading whitespace when attempting to read a newline.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if a newline could not be matched.</p></li>
<li><p><strong>EofError</strong> – Thrown if end of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is encountered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.matchLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">matchLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.matchLiteral" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the offset of a fileReader by reading the exact text of the given
string <code class="docutils literal notranslate"><span class="pre">literal</span></code> from the fileReader.</p>
<p>If the string is not matched exactly, then the fileReader’s offset is
unchanged and this method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>. In other words, this
fileReader will return <code class="docutils literal notranslate"><span class="pre">false</span></code> in the cases where
<a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a> would throw a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> or an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the string to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the read succeeded, and <code class="docutils literal notranslate"><span class="pre">false</span></code> on end of file or if
the literal could not be matched.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">matchLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ignoreWhitespace</span> <span class="pre">=</span> <span class="pre">true</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Advances the offset of a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> by reading the exact bytes of the
given <code class="docutils literal notranslate"><span class="pre">literal</span></code> from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>.</p>
<p>If the bytes are not matched exactly, then the fileReader’s offset is
unchanged and this method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>. In other words, this
fileReader will return <code class="docutils literal notranslate"><span class="pre">false</span></code> in the cases where
<a class="reference internal" href="#IO.fileReader.readLiteral" title="IO.fileReader.readLiteral"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLiteral</span></code></a> would throw a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> or an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>.</p>
<p>By default this method will ignore leading whitespace in the file when
attempting to read a literal (leading whitespace in the <code class="docutils literal notranslate"><span class="pre">literal</span></code> itself
is still matched against whitespace in the file).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>literal</strong> – the bytes to be matched.</p></li>
<li><p><strong>ignoreWhitespace</strong> – determines whether leading whitespace is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the read succeeded, and <code class="docutils literal notranslate"><span class="pre">false</span></code> on end of file or if
the literal could not be matched.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.matchNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">matchNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.matchNewline" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the offset of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> by reading a newline.</p>
<p>If a newline is not matched exactly, then the fileReader’s offset is
unchanged and this method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>. In other words, this
fileReader will return <code class="docutils literal notranslate"><span class="pre">false</span></code> in the cases where
<a class="reference internal" href="#IO.fileReader.readNewline" title="IO.fileReader.readNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readNewline</span></code></a> would throw a <a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.BadFormatError</span></code></a> or an
<a class="reference internal" href="OS.html#OS.EofError" title="OS.EofError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">OS.EofError</span></code></a>.</p>
<p>By default this method will ignore leading whitespace when attempting to
read a newline.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the read succeeded, and <code class="docutils literal notranslate"><span class="pre">false</span></code> on end of file or if
the newline could not be matched.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeLiteral">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeLiteral" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a string to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>, ignoring any formatting configured for
this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeLiteral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">literal:</span> <span class="pre">bytes</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span></dt>
<dd><p>Writes bytes to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>, ignoring any formatting configured for this
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeNewline" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a newline to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>, ignoring any formatting configured for
this <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readWriteNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readWriteNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readWriteNewline" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.fileReader.readWriteNewline" title="IO.fileReader.readWriteNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readWriteNewline</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.fileReader.readNewline" title="IO.fileReader.readNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readNewline</span></code></a> instead</p>
</div>
<p>Explicit call for reading or writing a newline. Equivalent to
<a class="reference internal" href="#IO.fileReader.readNewline" title="IO.fileReader.readNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readNewline</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.readWriteNewline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">readWriteNewline</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.readWriteNewline" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#IO.fileWriter.readWriteNewline" title="IO.fileWriter.readWriteNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.readWriteNewline</span></code></a> is deprecated; please use <a class="reference internal" href="#IO.fileWriter.writeNewline" title="IO.fileWriter.writeNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeNewline</span></code></a> instead</p>
</div>
<p>Explicit call for reading or writing a newline. Equivalent to
<a class="reference internal" href="#IO.fileWriter.writeNewline" title="IO.fileWriter.writeNewline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.writeNewline</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.binary">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">binary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileReader.binary" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘fileReader.binary()’ is deprecated; please use ‘fileReader.deserializerType’ to check for a binary deserializer instead</p>
</div>
<p>Returns <cite>true</cite> if this fileReader is configured for binary I/O.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.binary">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">binary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileWriter.binary" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘fileWriter.binary()’ is deprecated; please use ‘fileWriter.serializerType’ to check for a binary serializer instead</p>
</div>
<p>Returns <cite>true</cite> if this fileWriter is configured for binary I/O.</p>
</dd></dl>

<dl class="chpl itermethod">
<dt class="sig sig-object chpl" id="IO.fileReader.lines">
<em class="property"><span class="pre">iter</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">lines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all of the lines ending in <code class="docutils literal notranslate"><span class="pre">\n</span></code> in a fileReader - the
fileReader lock will be held while iterating over the lines.</p>
<p>Only serial iteration is supported. This iterator will halt on internal
system errors.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This iterator executes on the current locale. This may impact multilocale
performance if the current locale is not the same locale on which the
fileReader was created.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line. Defaults to false</p>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>lines from the fileReader, by default with a trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.stringify">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">stringify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">string</span><a class="headerlink" href="#IO.stringify" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘stringify(x)’ is deprecated; please use ‘try! “%?”.format(x)’ from IO.FormattedIO instead</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.read">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one or more values from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s lock
will be held while reading the values — this protects against interleaved
reads.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>args</strong> – a series of variables to read into. Basic types are handled
internally, but for other types this function will call
value.readThis() with a <code class="docutils literal notranslate"><span class="pre">Reader</span></code> argument as described
in <a class="reference internal" href="ChapelIO.html#readthis-writethis"><span class="std std-ref">The readThis() and writeThis() Methods</span></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the read succeeded, and <cite>false</cite> on end of file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if an EOF occurred while reading an item.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
for <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">another reason</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?k</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>read with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">[]</span> <span class="pre">uint(8)</span></em>, <em class="sig-param"><span class="pre">out</span> <span class="pre">numRead:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">arg.domain.lowBound</span></em>, <em class="sig-param"><span class="pre">amount</span> <span class="pre">=</span> <span class="pre">arg.domain.highBound</span> <span class="pre">-</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">arg.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">arg.isRectangular()</span></em><a class="headerlink" href="#IO.fileReader.readline" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>fileReader.readline is deprecated. Use <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a> instead</p>
</div>
<p>Read a line into a Chapel array of bytes. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.
The <code class="docutils literal notranslate"><span class="pre">\n</span></code> is returned in the array.</p>
<p>Note that this routine currently requires a 1D rectangular non-strided array.</p>
<p>Throws a SystemError if a line could not be read from the fileReader.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – A 1D DefaultRectangular array which must have at least 1 element.</p></li>
<li><p><strong>numRead</strong> – The number of bytes read.</p></li>
<li><p><strong>start</strong> – Index to begin reading into.</p></li>
<li><p><strong>amount</strong> – The maximum amount of bytes to read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if the bytes were read without error.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readLine">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">a:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">a.size</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(t</span> <span class="pre">==</span> <span class="pre">uint(8)</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">int(8))</span></em><a class="headerlink" href="#IO.fileReader.readLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a line into an array of bytes.</p>
<p>Reads bytes from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached. Values are
read in binary format (i.e., this method is not aware of UTF-8 encoding).</p>
<p>The array’s size is not changed to accommodate bytes. If a newline is not
found before the array is filled, or <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes are read, a
<a class="reference internal" href="OS.html#OS.BadFormatError" title="OS.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">BadFormatError</span></code></a> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is
returned to its original position.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A 1D DefaultRectangular non-strided array storing <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> or
<code class="docutils literal notranslate"><span class="pre">uint(8)</span></code>. Values are overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to store into the <code class="docutils literal notranslate"><span class="pre">a</span></code> array.
Defaults to the size of the array.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line. If
<code class="docutils literal notranslate"><span class="pre">true</span></code>, the newline isn’t counted in the number of
bytes read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The number of array elements set by this call, or <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise
(i.e., the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> – Thrown if <code class="docutils literal notranslate"><span class="pre">maxSize</span> <span class="pre">&gt;</span> <span class="pre">a.size</span></code></p></li>
<li><p><strong>BadFormatError</strong> – Thrown if the line is longer than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code>. File
offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>fileReader.readline is deprecated. Use <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a> instead</p>
</div>
<p>Read a line into a Chapel string or bytes. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.
The <code class="docutils literal notranslate"><span class="pre">\n</span></code> is included in the resulting value.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>arg</strong> – a string or bytes to receive the line</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if a line was read without error, <cite>false</cite> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if unexpected EOF encountered while reading.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the fileReader.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a line into a <code class="docutils literal notranslate"><span class="pre">string</span></code>. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents are overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to store into <code class="docutils literal notranslate"><span class="pre">s</span></code>. The
default of -1 means to read an unlimited number of codepoints.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if a line was read without error, <code class="docutils literal notranslate"><span class="pre">false</span></code> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the line is longer than <cite>maxSize</cite>. The
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a line into a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to receive the line. Contents are overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to store into <code class="docutils literal notranslate"><span class="pre">b</span></code>. The default of
-1 means to read an unlimited number of bytes.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if a line was read without error, <code class="docutils literal notranslate"><span class="pre">false</span></code> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the line is longer than <cite>maxSize</cite>. The file
offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em></dt>
<dd><p>Read a line. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – the type of data to read, which must be <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>. Defaults to <code class="docutils literal notranslate"><span class="pre">string</span></code> if not specified.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. The default of -1
means to read an unlimited number of codepoints.</p></li>
<li><p><strong>stripNewline</strong> – Whether to strip the trailing <code class="docutils literal notranslate"><span class="pre">\n</span></code> from the line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
up to (and possibly including) the newline.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – Thrown if the line is longer than <cite>maxSize</cite>. The file
offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readThrough">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.readThrough" title="Permalink to this definition">¶</a></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> through that point.</p>
<p>If the separator is found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left immediately
after it. If the separator could not be found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes,
a <code class="docutils literal notranslate"><span class="pre">BadFormatError</span></code> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s offset is not
changed. Otherwise, if EOF is reached before finding the separator, the
remainder of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s contents are returned and the offset is
left at EOF.</p>
<p>To match with multiple separators, or a more complex separator, use the
overload of <a class="reference internal" href="Regex.html#Regex.fileReader.readThrough" title="Regex.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readThrough</span></code></a> that accepts a
<a class="reference internal" href="Regex.html#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>
or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value of
<code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned
<code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code>. If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the returned
value will not include the separator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
up to (and possibly including) the separator.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<cite>maxSize</cite> bytes. The fileReader offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> through that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned <code class="docutils literal notranslate"><span class="pre">string</span></code>.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the separator will not be included in <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<cite>maxSize</cite> bytes. The fileReader offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readThrough</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripSeparator</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> through that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readThrough" title="IO.fileReader.readThrough"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of codepoints to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
<li><p><strong>stripSeparator</strong> – Whether to strip the separator from the returned <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, the separator will not be included in <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes. The fileReader offset is not moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readTo">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.readTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> up to that point.</p>
<p>If the separator is found, the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is left immediately
before it. If the separator could not be found in the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes,
a <code class="docutils literal notranslate"><span class="pre">BadFormatError</span></code> is thrown and the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s offset is not
changed. Otherwise, if EOF is reached before finding the separator, the
remainder of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s contents are returned and the offset is
left at EOF.</p>
<p>To match with multiple separators, or a more complex separator, use the
overload of <a class="reference internal" href="Regex.html#Regex.fileReader.readTo" title="Regex.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readTo</span></code></a> that accepts a
<a class="reference internal" href="Regex.html#Regex.regex" title="Regex.regex"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">regex</span></code></a> separator.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with. Must be a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>
or <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default
value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method can read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> with the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
up to the <code class="docutils literal notranslate"><span class="pre">separator</span></code>.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not
moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> up to that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readTo" title="IO.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>s</strong> – The <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method will read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<cite>maxSize</cite> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not
moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">separator:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read until the given separator is found, returning the contents of the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> up to that point.</p>
<p>See the above <a class="reference internal" href="#IO.fileReader.readTo" title="IO.fileReader.readTo"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">overload</span></code></a> of this method for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>separator</strong> – The separator to match with.</p></li>
<li><p><strong>b</strong> – The <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into. Contents will be overwritten.</p></li>
<li><p><strong>maxSize</strong> – The maximum number of bytes to read. For the default value
of <code class="docutils literal notranslate"><span class="pre">-1</span></code>, this method will read until EOF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BadFormatError</strong> – Thrown if the separator was not found in the next
<code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes. The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is not
moved.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readAll">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">bytes</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em><a class="headerlink" href="#IO.fileReader.readAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the remaining contents of the fileReader into an instance of the
specified type</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> – the type to read into; must be <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> or
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>. Defaults to <code class="docutils literal notranslate"><span class="pre">bytes</span></code> if not specified.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> as a <code class="docutils literal notranslate"><span class="pre">t</span></code></p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if nothing could be read because the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></dt>
<dd><p>Read the remaining contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into a <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
<p>Note that any existing contents of the <code class="docutils literal notranslate"><span class="pre">string</span></code> are overwritten.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>s</strong> – the <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to read into</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of codepoints that were stored in <code class="docutils literal notranslate"><span class="pre">s</span></code>, or 0 if
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is at EOF.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></dt>
<dd><p>Read the remaining contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
<p>Note that any existing contents of the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> are overwritten.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>b</strong> – the <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to read into</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of bytes that were stored in <code class="docutils literal notranslate"><span class="pre">b</span></code>, or 0 if
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is at EOF.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">a:</span> <span class="pre">[?d]</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(t</span> <span class="pre">==</span> <span class="pre">uint(8)</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">int(8))</span></em></dt>
<dd><p>Read the remaining contents of the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into an array of bytes.</p>
<p>Note that this routine currently requires a 1D rectangular non-strided array.</p>
<p>If the remaining contents of the fileReader exceed the size of <code class="docutils literal notranslate"><span class="pre">a</span></code>, the
first <code class="docutils literal notranslate"><span class="pre">a.size</span></code> bytes will be read into <code class="docutils literal notranslate"><span class="pre">a</span></code>, and then an
<a class="reference internal" href="OS.html#OS.InsufficientCapacityError" title="OS.InsufficientCapacityError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">InsufficientCapacityError</span></code></a> will be thrown. In such a case, the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset is advanced <code class="docutils literal notranslate"><span class="pre">a.size</span></code> bytes from its original
position.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>a</strong> – the array of bytes to read into</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of bytes that were stored in <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>InsufficientCapacityError</strong> – Thrown if the fileReader’s contents do not
fit into <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readString">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">string</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readString" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a given number of codepoints from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>, returning a new
<a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">string</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached while
reading. If nothing is read, the empty string (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>maxSize</strong> – the maximum number of codepoints to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new <code class="docutils literal notranslate"><span class="pre">string</span></code> containing up to the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> codepoints
from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a given number of codepoints from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into a
<a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a>.</p>
<p>The updated <code class="docutils literal notranslate"><span class="pre">string</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is
reached while reading. If nothing is read, it will be set to the empty
string (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to read into — contents will be overwritten</p></li>
<li><p><strong>maxSize</strong> – the maximum number of codepoints to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readBytes">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bytes</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readBytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a given number of bytes from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>, returning a new
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bytes</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached while
reading. If nothing is read, the empty bytes (<code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>) will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>maxSize</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new <code class="docutils literal notranslate"><span class="pre">bytes</span></code> containing up to the next <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes
from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a given number of bytes from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into a
<a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>The updated <code class="docutils literal notranslate"><span class="pre">bytes</span></code>’s length may be less than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is
reached while reading. If nothing is read, it will be set to the empty
bytes (<code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to read into — contents will be overwritten</p></li>
<li><p><strong>maxSize</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if something was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readBits">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">x:</span> <span class="pre">integral</span></em>, <em class="sig-param"><span class="pre">numBits:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readBits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – where to store the read bits. This value will have its <em>numBits</em>
least-significant bits set.</p></li>
<li><p><strong>numBits</strong> – how many bits to read</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the bits were read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e., the
<code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered before <code class="docutils literal notranslate"><span class="pre">numBits</span></code>
could be read.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">resultType</span></em>, <em class="sig-param"><span class="pre">numBits:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">resultType</span> <span class="pre">throws</span></dt>
<dd><p>Read bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resultType</strong> – type of the value returned</p></li>
<li><p><strong>numBits</strong> – how many bits to read</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>bits read. This value will have its <em>numBits</em> least-significant
bits set</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered before <code class="docutils literal notranslate"><span class="pre">numBits</span></code>
could be read.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeBits">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x:</span> <span class="pre">integral</span></em>, <em class="sig-param"><span class="pre">numBits:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">void</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeBits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – a value containing <em>numBits</em> bits to write the least-significant bits</p></li>
<li><p><strong>numBits</strong> – how many bits to write</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if writing more bits than fit into <cite>x</cite>.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeCodepoint">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeCodepoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">codepoint:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeCodepoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a single Unicode codepoint to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>codepoint</strong> – Unicode codepoint to write</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readCodepoint">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readCodepoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readCodepoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a single Unicode codepoint from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Unicode codepoint read</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered while reading a
codepoint.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readCodepoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">codepoint:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a single Unicode codepoint from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>c</strong> – where to store the read codepoint</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the codepoint was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered while reading a
codepoint.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeByte">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeByte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">byte:</span> <span class="pre">uint(8)</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeByte" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a single byte to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>byte</strong> – the byte to write</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readByte">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readByte</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">uint(8)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readByte" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a single byte from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the byte read</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> offset was already at EOF.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readByte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">byte:</span> <span class="pre">uint(8)</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a single byte from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>byte</strong> – where to store the read byte</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the byte was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.IOSkipBufferingForLargeOps">
<em class="property"><span class="pre">config</span> <span class="pre">param</span> </em><span class="sig-name descname"><span class="pre">IOSkipBufferingForLargeOps</span></span> <span class="pre">=</span> <span class="pre">true</span><a class="headerlink" href="#IO.IOSkipBufferingForLargeOps" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>IOSkipBufferingForLargeOps is unstable and could change or be removed in the future</p>
</div>
<p>Controll whether large read/write operations can bypass the IO runtime’s
buffering mechanism.</p>
<p>This optimization is on by default as it can improve performance for large
operations where buffering doesn’t significantly reduce the number of system
I/O calls and thus adds unnecessary overhead.</p>
<p>To disable the optimization, compile with <code class="docutils literal notranslate"><span class="pre">-sIOSkipBufferingForLargeOps=false</span></code>.</p>
<p>Note that this flag controls an implementation-specific feature and
thus is not part of the Chapel language specification.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeString">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">s.size</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeString" title="Permalink to this definition">¶</a></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">size</span></code> codepoints from a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of codepoints to write from the <code class="docutils literal notranslate"><span class="pre">string</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">s.size</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeBytes">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">b.size</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeBytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes from a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of bytes to write from the <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified range.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">b.size</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeBinary">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(?t)</span></em>, <em class="sig-param"><span class="pre">numBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">numBytes</span></code> of data from a <a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<p>Note that native endianness is always used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">numBytes</span></code> is not evenly divisible by the size of <code class="docutils literal notranslate"><span class="pre">t</span></code>, the remaining
bytes will be ignored. For example, if the <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code>’s internal type is 4
bytes in length, and <code class="docutils literal notranslate"><span class="pre">numBytes=17</span></code>, only 16 bytes will be written.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method provides no protection against attempting to access invalid
memory</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to some valid memory</p></li>
<li><p><strong>numBytes</strong> – the number of bytes to write</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(void)</span></em>, <em class="sig-param"><span class="pre">numBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Write <code class="docutils literal notranslate"><span class="pre">numBytes</span></code> of data from a <code class="docutils literal notranslate"><span class="pre">CTypes.c_ptr(void)</span></code> to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<p>The data are written to the file one byte at a time.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method provides no protection against attempting to access invalid
memory</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <code class="docutils literal notranslate"><span class="pre">c_ptr(void)</span></code> to some valid memory</p></li>
<li><p><strong>numBytes</strong> – the number of bytes to write</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Write a binary number to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be written</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to write the number. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Write a binary number to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be written</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to write the number.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">s.size</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Write a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a> to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> in binary format</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the <code class="docutils literal notranslate"><span class="pre">string</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of codepoints to write from the <code class="docutils literal notranslate"><span class="pre">string</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">s.size</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">b.size</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Write a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a> to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> in binary format</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to write</p></li>
<li><p><strong>size</strong> – the number of bytes to write from the <code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
<li><p><strong>IllegalArgumentError</strong> – Thrown if <code class="docutils literal notranslate"><span class="pre">size</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">b.size</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[?d]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Write an array of binary numbers to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<p>Note that this routine currently requires a local rectangular non-strided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array of numbers to write to the fileWriter</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to read the numbers. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Write an array of binary numbers to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code></p>
<p>Note that this routine currently requires a local rectangular non-strided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array of numbers to write to the fileWriter</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to write the number.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> offset was already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if the write operation exceeds the
<code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>’s specified region.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readBinary">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian:</span> <span class="pre">endianness</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a binary number from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> – number to be read</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to read the number. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the number was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered while reading the
number.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">numeric</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><blockquote>
<div><p>Read a binary number from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">arg arg</dt>
<dd class="field-odd"><p>number to be read</p>
</dd>
<dt class="field-even">arg endian</dt>
<dd class="field-even"><p><a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to read the number.</p>
</dd>
<dt class="field-odd">returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the number was read, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise (i.e.,
the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> was already at EOF).</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered while reading the
number.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a specified number of codepoints into a <a class="reference internal" href="../../language/spec/strings.html#String.string" title="String.string"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">string</span></code></a></p>
<p>The resulting string <code class="docutils literal notranslate"><span class="pre">s</span></code> may be smaller than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached
before reading the specified number of codepoints. Additionally, if nothing
is read from the fileReader, <code class="docutils literal notranslate"><span class="pre">s</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> (the empty string)
and the method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method always uses UTF-8 encoding regardless of the fileReader’s
configuration</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the string to read into — this value is overwritten</p></li>
<li><p><strong>maxSize</strong> – the number of codepoints to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if some codepoints were read, or <code class="docutils literal notranslate"><span class="pre">false</span></code> on EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Read a specified number of bytes into a <a class="reference internal" href="../../language/spec/bytes.html#Bytes.bytes" title="Bytes.bytes"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">bytes</span></code></a></p>
<p>The bytes <code class="docutils literal notranslate"><span class="pre">b</span></code> may be smaller than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> if EOF is reached before
reading the specified number of bytes. Additionally, if nothing is read
from the fileReader, <code class="docutils literal notranslate"><span class="pre">b</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code> (the empty bytes) and
the method will return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – the bytes to read into — this value is overwritten</p></li>
<li><p><strong>maxSize</strong> – the number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if some bytes were read, or <code class="docutils literal notranslate"><span class="pre">false</span></code> on EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[?d]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">param</span> <span class="pre">endian</span> <span class="pre">=</span> <span class="pre">endianness.native</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Read an array of binary numbers from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<p>Binary values of the type <code class="docutils literal notranslate"><span class="pre">data.eltType</span></code> are consumed from the fileReader
until <code class="docutils literal notranslate"><span class="pre">data</span></code> is full or EOF is reached.</p>
<p>Note that this routine currently requires a local rectangular non-strided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array to read into – existing values are overwritten.</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> compile-time argument that specifies the byte
order in which to read the numbers in. Defaults to
<a class="reference internal" href="#IO.endianness.native" title="IO.endianness.native"><code class="xref chpl chpl-enumconstant docutils literal notranslate"><span class="pre">endianness.native</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of values that were read into the array. This can be
less than <code class="docutils literal notranslate"><span class="pre">data.size</span></code> if EOF was reached, or an error occurred,
before filling the array.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">data:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">endian:</span> <span class="pre">endianness</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">isSuitableForBinaryReadWrite(data)</span> <span class="pre">&amp;&amp;</span> <span class="pre">data.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(isIntegralType(t)</span> <span class="pre">||</span> <span class="pre">isRealType(t)</span> <span class="pre">||</span> <span class="pre">isImagType(t)</span> <span class="pre">||</span> <span class="pre">isComplexType(t))</span></em></dt>
<dd><p>Read an array of binary numbers from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<p>Binary values of the type <code class="docutils literal notranslate"><span class="pre">data.eltType</span></code> are consumed from the fileReader
until <code class="docutils literal notranslate"><span class="pre">data</span></code> is full or EOF is reached.</p>
<p>Note that this routine currently requires a local rectangular non-strided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – an array to read into – existing values are overwritten.</p></li>
<li><p><strong>endian</strong> – <a class="reference internal" href="#IO.endianness" title="IO.endianness"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">endianness</span></code></a> specifies the byte order in which
to read the number.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of values that were read into the array. This can be
less than <code class="docutils literal notranslate"><span class="pre">data.size</span></code> if EOF was reached, or an error occurred,
before filling the array.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(?t)</span></em>, <em class="sig-param"><span class="pre">maxBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></dt>
<dd><p>Read up to <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> bytes from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into a
<a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a></p>
<p>Note that native endianness is always used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> is not evenly divisible by the size of <code class="docutils literal notranslate"><span class="pre">t</span></code>, then the
remaining bytes are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <a class="reference internal" href="CTypes.html#CTypes.c_ptr" title="CTypes.c_ptr"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to some memory — existing values will be
overwritten</p></li>
<li><p><strong>maxBytes</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of bytes that were read. this can be less than
<code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> if EOF was reached before reading the specified
number of bytes, or if <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> is not evenly divisible by
the size of <code class="docutils literal notranslate"><span class="pre">t</span></code></p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ptr:</span> <span class="pre">c_ptr(void)</span></em>, <em class="sig-param"><span class="pre">maxBytes:</span> <span class="pre">int</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span></dt>
<dd><p>Read up to <code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> bytes from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> into a
<code class="docutils literal notranslate"><span class="pre">CTypes.c_ptr(void)</span></code></p>
<p>Note that data are read from the file one byte at a time.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – a <code class="docutils literal notranslate"><span class="pre">c_ptr(void)</span></code> to some memory — existing
values will be overwritten</p></li>
<li><p><strong>maxBytes</strong> – the maximum number of bytes to read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of bytes that were read. this can be less than
<code class="docutils literal notranslate"><span class="pre">maxBytes</span></code> if EOF was reached before reading the specified number
of bytes</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.readln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.readln" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Read values from a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> and then consume any bytes until
newline is reached. The input will be consumed atomically - the
fileReader lock will be held while reading all of the passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>args</strong> – a list of arguments to read. This routine can be called
with zero or more such arguments. Basic types are handled
internally, but for other types this function will call
value.readThis() with a <code class="docutils literal notranslate"><span class="pre">Reader</span></code> argument as described
in <a class="reference internal" href="ChapelIO.html#readthis-writethis"><span class="std std-ref">The readThis() and writeThis() Methods</span></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the read succeeded, and <cite>false</cite> upon end of file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered before data could
be read.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?k</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>readln with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Read a value of passed type.</p>
<p>For example, the following line of code reads a value of type <cite>int</cite>
from <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a> and uses it to initialize a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> – the type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value read</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered before data could
be fully read.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Read a value of passed type followed by a newline.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> – the type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value read</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is at already EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered before data could
be fully read.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">numTypes</span> <span class="pre">&gt;</span> <span class="pre">1</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Read values of passed types followed by a newline
and return a tuple containing the read values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> – more than one type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of the read values</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered before data could
be fully read.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">numTypes</span> <span class="pre">&gt;</span> <span class="pre">1</span></em></dt>
<dd><p>Read values of passed types and return a tuple containing the read values.
The <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>’s lock will be held while reading — this protects against
interleaved reads.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> – more than one type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of the read values</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is already at EOF.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF was encountered while more data was
expected.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be read from the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.write">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write values to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>. The output will be produced atomically -
the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> lock will be held while writing all of the passed
values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>args</strong> – a list of arguments to write. Basic types are handled
internally, but for other types this function will call
value.writeThis() with the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> as an argument.</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if EOF is reached before all the arguments could be
written.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF is encountered while writing one of
the arguments.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>write with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.writeln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.writeln" title="Permalink to this definition">¶</a></dt>
<dd><p>Write values to a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> followed by a newline.  The output will be
produced atomically - the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> lock will be held while writing all of
the passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>args</strong> – a variable number of arguments to write. This method can be
called with zero or more arguments. Basic types are handled
internally, but for other types this function will call
value.writeThis() with the fileWriter as an argument.</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EofError</strong> – Thrown if EOF is reached before all the arguments
could be written.</p></li>
<li><p><strong>UnexpectedEofError</strong> – Thrown if EOF is encountered while writing one of
the arguments.</p></li>
<li><p><strong>SystemError</strong> – Thrown if data could not be written to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>
due to a <a class="reference internal" href="#io-general-sys-error"><span class="std std-ref">system error</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">writeln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">const</span> <span class="pre">args</span> <span class="pre">...?k</span></em>, <em class="sig-param"><span class="pre">style:</span> <span class="pre">iostyle</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>writeln with a ‘style’ argument is deprecated</p>
</div>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.flush">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes all writes to the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>, if any, available to concurrent
viewers of its associated file, such as other fileWriters/fileReader or other
applications accessing this file concurrently.</p>
<p>Unlike <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a>, this does not commit the written data
to the file’s device.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the flush fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.assertEOF">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">assertEOF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">errStr:</span> <span class="pre">string</span> <span class="pre">=</span> <span class="pre">&quot;-</span> <span class="pre">Not</span> <span class="pre">at</span> <span class="pre">EOF&quot;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.fileReader.assertEOF" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘assertEOF’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Assert that a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> has reached end-of-file and that there was no
error doing the read.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.close">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileReader.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a <code class="docutils literal notranslate"><span class="pre">fileReader</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileReader</span></code> is not successfully closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.close">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="pre">throws</span><a class="headerlink" href="#IO.fileWriter.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code>. Implicitly performs the <a class="reference internal" href="#IO.fileWriter.flush" title="IO.fileWriter.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileWriter.flush</span></code></a>
operation (see <a class="reference internal" href="#about-io-filereader-filewriter-synchronization"><span class="std std-ref">Synchronization of fileReader and fileWriter Data and Avoiding Data Races</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> – Thrown if the <code class="docutils literal notranslate"><span class="pre">fileWriter</span></code> is not successfully closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileReader.isClosed">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileReader.</span></span><span class="sig-name descname"><span class="pre">isClosed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileReader.isClosed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if a fileReader is currently closed.</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.fileWriter.isClosed">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">fileWriter.</span></span><span class="sig-name descname"><span class="pre">isClosed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span><a class="headerlink" href="#IO.fileWriter.isClosed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if a fileWriter is currently closed.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.stdin">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">stdin</span></span><span class="pre">:</span> <span class="pre">fileReader(true)</span><a class="headerlink" href="#IO.stdin" title="Permalink to this definition">¶</a></dt>
<dd><p>A locking <a class="reference internal" href="#IO.fileReader" title="IO.fileReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileReader</span></code></a> instance that reads from standard input.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.stdout">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">stdout</span></span><span class="pre">:</span> <span class="pre">fileWriter(true)</span><a class="headerlink" href="#IO.stdout" title="Permalink to this definition">¶</a></dt>
<dd><p>A locking <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> instance that writes to standard output.</p>
</dd></dl>

<dl class="chpl data">
<dt class="sig sig-object chpl" id="IO.stderr">
<em class="property"><span class="pre">const</span> </em><span class="sig-name descname"><span class="pre">stderr</span></span><span class="pre">:</span> <span class="pre">fileWriter(true)</span><a class="headerlink" href="#IO.stderr" title="Permalink to this definition">¶</a></dt>
<dd><p>A locking <a class="reference internal" href="#IO.fileWriter" title="IO.fileWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">fileWriter</span></code></a> instance that writes to standard error.</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.read">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?n</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.read</span></code>. See <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.read</span></code>. See <a class="reference internal" href="#IO.fileReader.read" title="IO.fileReader.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.read</span></code></a> for types</p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.readLine">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">a:</span> <span class="pre">[]</span> <span class="pre">?t</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">a.size</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">int</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.isRectangular()</span> <span class="pre">&amp;&amp;</span> <span class="pre">a.strides</span> <span class="pre">==</span> <span class="pre">strideKind.one</span> <span class="pre">&amp;&amp;</span> <span class="pre">(t</span> <span class="pre">==</span> <span class="pre">uint(8)</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">int(8))</span></em><a class="headerlink" href="#IO.readLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.readline">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg:</span> <span class="pre">[]</span> <span class="pre">uint(8)</span></em>, <em class="sig-param"><span class="pre">out</span> <span class="pre">numRead:</span> <span class="pre">int</span></em>, <em class="sig-param"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">arg.domain.lowBound</span></em>, <em class="sig-param"><span class="pre">amount</span> <span class="pre">=</span> <span class="pre">arg.domain.highBound</span> <span class="pre">-</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">1</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">arg.rank</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">arg.isRectangular()</span></em><a class="headerlink" href="#IO.readline" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>readline is deprecated. Use <a class="reference internal" href="#IO.readLine" title="IO.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readLine</span></code></a> instead</p>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readline</span></code>.  See <a class="reference internal" href="#IO.fileReader.readline" title="IO.fileReader.readline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readline</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">arg:</span> <span class="pre">?t</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>readline is deprecated. Use <a class="reference internal" href="#IO.readLine" title="IO.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readLine</span></code></a> instead</p>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readline</span></code>.  See <a class="reference internal" href="#IO.fileReader.readline" title="IO.fileReader.readline"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readline</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">s:</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">b:</span> <span class="pre">bytes</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">string</span></em>, <em class="sig-param"><span class="pre">maxSize</span> <span class="pre">=</span> <span class="pre">-1</span></em>, <em class="sig-param"><span class="pre">stripNewline</span> <span class="pre">=</span> <span class="pre">false</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">t</span> <span class="pre">throws</span><em class="property">&#160; <span class="pre">where</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">string</span> <span class="pre">||</span> <span class="pre">t</span> <span class="pre">==</span> <span class="pre">bytes</span></em></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readLine</span></code>.  See <a class="reference internal" href="#IO.fileReader.readLine" title="IO.fileReader.readLine"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readLine</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl" id="IO.readln">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ref</span> <span class="pre">args</span> <span class="pre">...?n</span></em><span class="sig-paren">)</span><span class="pre">:</span> <span class="pre">bool</span> <span class="pre">throws</span><a class="headerlink" href="#IO.readln" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readln</span></code>. See <a class="reference internal" href="#IO.fileReader.readln" title="IO.fileReader.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readln</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt class="sig sig-object chpl">
<em class="property"><span class="pre">proc</span> </em><span class="sig-name descname"><span class="pre">readln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">...?numTypes</span></em><span class="sig-paren">)</span> <span class="pre">throws</span></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>‘readln’ is unstable and may be removed or modified in a future release</p>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readln</span></code>. See <a class="reference internal" href="#IO.fileReader.readln" title="IO.fileReader.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">fileReader.readln</span></code></a> for types</p>
</dd></dl>

<dl class="chpl method">
<dt class="sig sig-object chpl" id="IO.file.localesForRegion">
<em class="property"><span class="pre">proc</span> </em><span class="sig-prename descclassname"><span class="pre">file.</span></span><span class="sig-name descname"><span class="pre">localesForRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">start:</span> <span class="pre">int(64)</span></em>, <em class="sig-param"><span class="pre">end:</span> <span class="pre">int(64)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.localesForRegion" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>file.localesForRegion is deprecated</p>
</div>
<p>Returns the ‘best’ locale to run something working with the region
of the file in start..end-1.</p>
<p>This <em>must</em> return the same result when called from different locales.
Returns a domain of locales that are “best” for the given region. If no
locales are “best” we return a domain containing all locales.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – the file offset (starting from 0) where the region begins</p></li>
<li><p><strong>end</strong> – the file offset just after the region</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a set of locales that are best for working with this region</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>domain(locale)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="FileSystem.html" class="btn btn-neutral float-left" title="FileSystem" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="IO/FormattedIO.html" class="btn btn-neutral float-right" title="FormattedIO" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Hewlett Packard Enterprise Development LP.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>