<!DOCTYPE html>
<html data-theme="light" lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#00cbff">
    
    <meta name="description" content="A solution to day ten of AoC 2022, introducing scan expressions.">
    

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" media="screen,print">
    
    
    
    
    
    
    
    <style>.sidenote-checkbox { display: none; }</style>
    <style>.feather { width: 1rem; height: 1rem; }</style>
    <link rel="stylesheet" href="../../scss/style.min.css" media="screen,print">
    <link rel="stylesheet" href="../../scss/sidenotes.min.css" media="screen,print">
    <link rel="stylesheet" href="../../css/syntax.min.css" media="screen,print">
    <link rel="stylesheet" href="../../scss/syntax-terminal.min.css" media="screen,print">
    <link rel="stylesheet" href="../../scss/code.min.css" media="screen,print">
    <link rel="icon" type="image/png" href="../../img/favicon.ico">

    <script src="../../js/dropdown-menu.js" defer></script>

    <title>Advent of Code 2022, Day 10: Scan Lines</title>
</head>
<body>
<header>
    
    <div class="container">
        <a class="site-title" href="../../">
            <img alt="Chapel logo" width="50" height="50" src="../../img/logo.png">
            <h1>Chapel Language Blog</h1>
        </a>
    </div>
    <nav id="Header">
        <div class="container">
            <a href="../../about">About</a>
            <a href="https://chapel-lang.org">Chapel Website</a>
            <a href="../../featured">Featured</a>
            <a href="../../series">Series</a>
            <a href="../../tags">Tags</a>
            <a href="../../authors">Authors</a>
            <a href="../../posts">All Posts</a>
        </div>
    </nav>
    
</header>
<main class="container">
<h2>Advent of Code 2022, Day 10: Scan Lines</h2>
<div class="post-subscript">
    <p>Posted on December 14, 2022.</p>
    <p>
        Tags:
        
        <a class="button" href="../../tags/advent-of-code">Advent of Code</a>
        
        <a class="button" href="../../tags/how-to">How-To</a>
        
    </p>
    <p>
    By:
    <a href="../../authors/daniel-fedorin">Daniel Fedorin</a>
    </p>
</div>

<div class="post-content">
    
    <div class="table-of-contents">
        <div class="wrapper">
            <span class="header">Table of Contents</span>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#the-task-at-hand-and-my-approach">The Task at Hand and My Approach</a></li>
    <li><a href="#an-iterator-to-represent-operations">An Iterator to Represent Operations</a></li>
    <li><a href="#using-scans-to-compute-values-of-x-at-every-state">Using Scans to Compute Values of <code>X</code> at Every State</a></li>
    <li><a href="#slicing-and-operator-promotion-to-compute-signal-strengths">Slicing and Operator Promotion to Compute Signal Strengths</a></li>
    <li><a href="#displaying-the-crt-output">Displaying the CRT Output</a></li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
        </div>
    </div>
    

    

    <p>Welcome to day 10 of Chapel&rsquo;s Advent of Code 2022 series. Having taken a little
break for the weekend, we&rsquo;re ready to dive into the remaining three problems
in our <a href="../../posts/aoc2022-day00-intro/">Twelve Days of Chapel</a>. Check
out that linked introductory post if you would like more context on the
series!</p>
<h3 id="the-task-at-hand-and-my-approach">
  <a href="#the-task-at-hand-and-my-approach">The Task at Hand and My Approach</a>
</h3>
<p>It wouldn&rsquo;t be Advent of Code without a <a href="https://adventofcode.com/2016/day/12"target="_blank" rel="noopener">problem</a>
<a href="https://adventofcode.com/2017/day/18"target="_blank" rel="noopener">involving</a> <a href="https://adventofcode.com/2018/day/16"target="_blank" rel="noopener">some</a>
<a href="https://adventofcode.com/2019/day/5"target="_blank" rel="noopener">virtual</a> <a href="https://adventofcode.com/2021/day/24"target="_blank" rel="noopener">machine</a>. In <a href="https://adventofcode.com/2022/day/10"target="_blank" rel="noopener">today&rsquo;s challenge</a>,
we are given a virtual computer with a single register (memory cell) <code>X</code>, and two operations:
<code>addx</code> and <code>noop</code>. The <code>addx</code> operation is used to add a number to the
<code>X</code> register (subtractions can be achieved by adding negative numbers to <code>X</code>),
and <code>noop</code> does nothing. Each instruction takes some time to execute: the
<code>noop</code> instruction takes one step, while <code>addx</code> takes two steps. We are tasked
with determining the values of the register <code>X</code> at particular times, which
realistically means we have to figure out what <code>X</code> is equal to after every
step.</p>
<p>My approach for this problem uses concepts that we&rsquo;ve already covered
in previous articles, with the notable exceptions of <em>scan expressions</em>
and <em>array reshaping</em>. By expressing our computation as a scan, we can elegantly solve the first
part of today&rsquo;s puzzle. Chapel&rsquo;s <code>scan</code> expressions, just like its <code>reduce</code>
expressions, are executed in parallel, so our solution immediately benefits from Chapel&rsquo;s
multitasking capabilities. Array reshaping leads to some very clean code
when it comes to drawing the output of the CRT monitor for part two.</p>
<p><strong>If you are a fan of palindromes, here is the complete solution for the day:</strong>




<div class="file" data-code-type="main">
    <details>
        <summary class="file-header">
            <a href="./code/aoc2022-day10-crt.chpl" download="aoc2022-day10-crt.chpl">aoc2022-day10-crt.chpl</a>
            
        </summary>
        
        <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-chpl" data-lang="chpl"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="nx">IO</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">iter</span><span class="w"> </span><span class="nf">ops</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">yield</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initial state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">line</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">stdin</span><span class="p">.</span><span class="nx">lines</span><span class="p">().</span><span class="nx">strip</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="nx">line</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">when</span><span class="w"> </span><span class="s">&#34;noop&#34;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">when</span><span class="w"> </span><span class="s">&#34;addx&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">yield</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">yield</span><span class="w"> </span><span class="nx">line</span><span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">const</span><span class="w"> </span><span class="nx">deltas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ops</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">cycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">deltas</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">Xs</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">cycles</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">deltas</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">interesting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="o">..</span><span class="mi">220</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">writeln</span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="p">(</span><span class="nx">Xs</span><span class="p">[</span><span class="nx">interesting</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">interesting</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">crtRows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="nx">crtCols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">const</span><span class="w"> </span><span class="nx">Screen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="o">..&lt;</span><span class="nx">crtRows</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">..&lt;</span><span class="nx">crtCols</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">const</span><span class="w"> </span><span class="nx">spritePos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">reshape</span><span class="p">(</span><span class="nx">Xs</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">Screen</span><span class="p">.</span><span class="nx">size</span><span class="p">],</span><span class="w"> </span><span class="nx">Screen</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">const</span><span class="w"> </span><span class="nx">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">Screen</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">spritePos</span><span class="p">[</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&#34;#&#34;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&#34;.&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">pixels</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
    </details>
</div>
</p>
<p>As usual, before we begin, let&rsquo;s bring in our old friend, the <code>IO</code> module.</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="nx">IO</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>And now, onward to our first task &mdash; parsing!</p>
<h3 id="an-iterator-to-represent-operations">
  <a href="#an-iterator-to-represent-operations">An Iterator to Represent Operations</a>
</h3>
<p>The first order of business is to read in the puzzle input, and turn it into
a representation that is convenient for simulating the tiny virtual computer.
The instructions we&rsquo;re reading look like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">noop
</span></span><span class="line"><span class="cl">addx 3
</span></span><span class="line"><span class="cl">addx -5
</span></span></code></pre></div><p>In the world of our little processor, only one thing can change at any
given step: the value of <code>X</code> can go up or down by a certain amount. We can therefore represent
the effects of the <code>noop</code> and <code>addx</code> instructions as a
<span class="sidenote"><label class="sidenote-label" for="sidenote-0">simple list of integers:</label><input class="sidenote-checkbox" type="checkbox" id="sidenote-0"></input><span class="sidenote-content sidenote-right"><span class="sidenote-delimiter">[note:</span>
I think there's a curious analogy between the integers we create and
CPU <a href="https://en.wikipedia.org/wiki/Micro-operation">micro-operations</a>.
Just like a CPU might break down complex instructions into smaller ones, we
break individual operations like <code>noop</code> and <code>addx</code> into
smaller pieces (changes to the register).
<span class="sidenote-delimiter">]</span></span></span> each integer will indicate that one step took place, and that
during that step, the register <code>X</code> changed by the amount stored in
the integer. Let&rsquo;s call such a change to <code>X</code> a <em>delta</em>. My solution defines
an iterator that reads input from the console and yields deltas.</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">iter</span><span class="w"> </span><span class="nf">ops</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">yield</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initial state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">line</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">stdin</span><span class="p">.</span><span class="nx">lines</span><span class="p">().</span><span class="nx">strip</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="nx">line</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">when</span><span class="w"> </span><span class="s">&#34;noop&#34;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">when</span><span class="w"> </span><span class="s">&#34;addx&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">yield</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">yield</span><span class="w"> </span><span class="nx">line</span><span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The first statement in the iterator is a <code>yield</code> that produces
a fixed value of <code>1</code>. As indicated by the comment, this encodes the initial
state of the CPU. This first value will end up &mdash; unchanged &mdash; in the very beginning of our history of
values of <code>X</code>. If we wanted the CPU to start at <code>100</code> instead of <code>1</code>, we
could simply change this statement to <code>yield 100;</code>.</p>
<p>Next, my solution iterates over every line in the input. Here I use
<code>stdin.lines()</code>, which is an iterator that yields a single string for each
line from the program&rsquo;s input stream. These strings contain the newline
character <code>\n</code>, which I don&rsquo;t want; I get rid of it by calling the <code>strip()</code>
method on each string. Note that it looks like I&rsquo;m calling <code>strip()</code> on the iterator,
<code>stdin.lines()</code>, itself &mdash; this is another example of promotion in Chapel. We
first covered promotion in <a href="../../posts/aoc2022-day02-rochambeau/#argument-promotion">our day 2 article</a>.</p>
<p>For each line of input, what&rsquo;s yielded depends on the instruction; we can
identify the instruction by its first four characters, which I retrieve
by slicing the line (see the <a href="../../posts/aoc2022-day03-rucksacks/#ranges-and-slicing">day 3 article</a> for
an introduction to slicing). From there, the two options are:</p>
<ul>
<li>In the <code>noop</code> case, a single step transpires. During this step, the value
of <code>X</code> does not change, and so a single integer <code>0</code> is yielded.</li>
<li>In the <code>addx n</code> case, two steps transpire. During the first step, the
<code>addx</code> instruction is still running, so the state doesn&rsquo;t change, and
the iterator yields <code>0</code>. During the second step, however, the instruction
completes, and the register is changed by the amount listed in the operation, <code>n</code>.
I use more slicing and an integer cast to retrieve the part of the string
after the <code>addx</code> and convert it to an integer.</li>
</ul>
<p>That completes the iterator of deltas, <code>ops</code>. For a set of instructions
like the ones in the problem statement:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">noop
</span></span><span class="line"><span class="cl">addx 3
</span></span><span class="line"><span class="cl">addx -5
</span></span></code></pre></div><p>the following integers would be yielded by <code>ops</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1 0 0 3 0 -5
</span></span></code></pre></div><h3 id="using-scans-to-compute-values-of-x-at-every-state">
  <a href="#using-scans-to-compute-values-of-x-at-every-state">Using Scans to Compute Values of <code>X</code> at Every State</a>
</h3>
<p>How do we go from a series of deltas to a series of register values? It&rsquo;s
pretty easy: to get the value of <code>X</code> after a certain number of steps,
we just have to sum up all the changes that have happened so far. Thus,
for the initial state, we just take the first element yielded by <code>ops</code>;
for the second state we sum the first two elements; for the third, we sum
up the first three. The words &ldquo;summing&rdquo; might evoke memories of <code>+ reduce</code>,
and these memories would be on the right track. However, there&rsquo;s a difference
between what we can get with <code>+ reduce</code> and what we need: reductions compute
a single value from an iterable, whereas we want to have a whole array of items,
each representing reductions over some prefix of a sequence!</p>
<p>This is where Chapel&rsquo;s <code>scan</code> expressions come in. They do exactly what
I just described above: given an iterable and a binary operation, they compute
and yield partial reductions up to and including each element. For example,
take the following array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><p>We can apply a <code>+ scan</code> to compute partial sums of its elements:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">writeln</span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">A</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints 1 3 6 10
</span></span></span></code></pre></div><p>We can also use a <code>* scan</code> to compute the factorials of the numbers <code>1</code> through
<code>4</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">writeln</span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">A</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints 1 2 6 24
</span></span></span></code></pre></div><p>Note that although the answer is the same, the way <code>scan</code> performs the
factorial computation above is <strong>not the same</strong> as writing something like
the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">writeln</span><span class="p">([</span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="k">domain</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="o">..</span><span class="nx">i</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Prints 1 2 6 24
</span></span></span></code></pre></div><p>In this last snippet, for each index of <code>A</code>, we use a <code>* reduce</code> to compute
the partial product of the elements up to that index.
The difference is that scans don&rsquo;t do extra work; the sum for the first three elements,
for instance, can be computed just by adding the third element to the sum
of the first two. Thus, there&rsquo;s no need to re-run a reduction for each prefix:
the result can be computed incrementally.</p>
<p>It gets even better: just as <code>reduce</code> expressions are parallel operations in
Chapel, so too are <code>scan</code> expressions. Even though it seems like
computing partial sums is a serial algorithm (&ldquo;add 1, then add 2, then add 3&hellip;&rdquo;),
the following code is <strong>also not how <code>scan</code> operates:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">indices</span><span class="p">[</span><span class="o">..&lt;</span><span class="nx">A</span><span class="p">.</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><p>Whereas that last snippet of code is serial, there are ways to break scans
into concurrent pieces (see the <a href="https://en.wikipedia.org/wiki/Prefix_sum#Parallel_algorithms"target="_blank" rel="noopener">Parallel Algorithms</a>
section on Wikipedia&rsquo;s page on prefix sums), and Chapel applies such techniques. Thus, we get cleaner code and
better performance &mdash; nice!</p>
<p>We can apply a <code>+ scan</code> to our <code>ops()</code> iterator to create a sequence of
partial sums. These partial sums, as we have discussed, work out to be the
values of <code>X</code> at each step. I perform the computation as follows:</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">const</span><span class="w"> </span><span class="nx">deltas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ops</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">cycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">deltas</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">Xs</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">cycles</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">deltas</span><span class="p">,</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In this snippet, I first collect the output of the iterator into an array,
<code>deltas</code>. I then retrieve the array&rsquo;s size into another variable, <code>cycles</code>.
Finally, I use a <code>+ scan</code> on <code>deltas</code> to compute the partial sums, storing
the result into a new array <code>Xs</code>. By default, this new array <code>Xs</code> would be
0-indexed just like the <code>deltas</code> array it&rsquo;s computed from. However, the
problem statement starts counting CPU steps at 1 (i.e., it&rsquo;s 1-indexed).
I therefore explicitly specify the domain of <code>Xs</code> to be <code>1..cycles</code>, which
makes it use 1-indexing and helps me write cleaner code down the line.</p>
<h3 id="slicing-and-operator-promotion-to-compute-signal-strengths">
  <a href="#slicing-and-operator-promotion-to-compute-signal-strengths">Slicing and Operator Promotion to Compute Signal Strengths</a>
</h3>
<p>The next thing we need to do is to compute the signal strengths at six
different indices. The problem asks for strengths at 20, 60, 100, 140, 180,
and 220. The first step we can take is notice that the numbers go up by 40
each time, and express them as a range:</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">      </span><span class="nx">interesting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="o">..</span><span class="mi">220</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This way of representing the interesting indices is both more concise and less error-prone:
we only have to keep track of three constants instead of six. Also, because
<code>interesting</code> is a range, we can use slicing to get the values of <code>Xs</code> at each
of the required time steps. This would look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">writeln</span><span class="p">(</span><span class="nx">Xs</span><span class="p">[</span><span class="nx">interesting</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Prints 21 19 18 21 16 18 for sample input
</span></span></span></code></pre></div><p>In the above statement, we took advantage of the fact that we declared <code>Xs</code>
to be 1-indexed instead of 0-indexed. The <code>interesting</code> range is built
based on the problem description, which counts from one, making its indices
a perfect match for the 1-based <code>Xs</code> array.</p>
<p>The values of the register <code>X</code> are <em>not</em> signal strengths, though! To compute
the signal strengths, we must multiply the value of <code>X</code> at a particular step
by the number of that step. Fortunately, we already have both ingredients
for computing signal strengths: the six values of <code>X</code>
(in <code>Xs[interesting]</code>) as well as the indices of these six values (in
<code>interesting</code> itself). We can multiply these two lists of values element-by-element
&mdash; thus computing the desired signal strengths &ndash; by using Chapel&rsquo;s
operator promotion (first seen in our <a href="../../posts/aoc2022-day08-treehouse/#using-promotions-and-reductions-to-compute-visibility">day 8 article</a>).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">writeln</span><span class="p">(</span><span class="nx">Xs</span><span class="p">[</span><span class="nx">interesting</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">interesting</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Prints 420 1140 1800 2940 2880 3960 for sample input
</span></span></span></code></pre></div><p>All that&rsquo;s left is to sum up the signal strengths, which we can do using
a reduction.</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">writeln</span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="p">(</span><span class="nx">Xs</span><span class="p">[</span><span class="nx">interesting</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">interesting</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>That&rsquo;s our answer to part one!</p>
<h3 id="displaying-the-crt-output">
  <a href="#displaying-the-crt-output">Displaying the CRT Output</a>
</h3>
<p>In part two, we discover that the value of the register is actually moving
a three-pixel sprite. A CRT monitor, which is drawing on a screen pixel-by-pixel,
draws a <code>#</code> if the current column overlaps with the sprite&rsquo;s position, and a <code>.</code> if the
current column does not.</p>
<p>The first thing I do is encode the information about the CRT into a few helper
variables. I made the variables <code>config const</code>s (first seen in our <a href="../../posts/aoc2022-day06-packets/#a-config-declaration-for-the-marker-length">day 6 article</a>)
so that it&rsquo;s possible to change the CRT&rsquo;s size from the command line.</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">crtRows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="nx">crtCols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>I then use the information to create a new two-dimensional domain
representing the possible pixel positions on the CRT&rsquo;s screen.</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">const</span><span class="w"> </span><span class="nx">Screen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="o">..&lt;</span><span class="nx">crtRows</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">..&lt;</span><span class="nx">crtCols</span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Iterating over <code>Screen</code> would give us the positions (row and column) of each
pixel that the CRT draws, in order. It would be nice to associate the
corresponding value of the register <code>X</code> (i.e., the location of the sprite)
with each of these scan positions. To do so, we can make use of Chapel&rsquo;s
<code>reshape</code> function.</p>
<p>Reshaping lets us &ldquo;reorganize&rdquo; the elements of an array:
for instance, we could turn an 8-element one-dimensional array into a
two-dimensional 2-by-4 array, or a three-dimensional 2-by-2-by-2 array.
The elements of the resulting array are the same as those of the original.
In the case of this problem, we want to arrange the sprite positions from
<code>Xs</code> (a one-dimensional array) into the same shape as our CRT monitor,
to match them up with each row and column.</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">const</span><span class="w"> </span><span class="nx">spritePos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">reshape</span><span class="p">(</span><span class="nx">Xs</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">Screen</span><span class="p">.</span><span class="nx">size</span><span class="p">],</span><span class="w"> </span><span class="nx">Screen</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In the above snippet, I use slicing to retrieve only the first <code>Screen.size</code>
positions from <code>Xs</code>, since the puzzle input leaves us with slightly more steps
than we need to draw the screen. Then, I call <code>reshape</code> with the resulting
slice, and the <code>Screen</code> domain. This tells Chapel to make <code>spritePos</code>
a two-dimensional array, with <code>crtRows</code> rows and <code>crtCols</code> columns, whose
elements are taken from the first <code>crtRows * crtCols</code> sprite positions in <code>Xs</code>.</p>
<p>Now: how do we know when the CRT&rsquo;s current column overlaps with the sprite?
The sprite is three pixels wide, and centered at the value of the register
<code>X</code> at a particular time step. Thus, a column overlaps with the sprite if
it&rsquo;s no more than one pixel away from its center. We can express this in
terms of an absolute value:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="nx">abs</span><span class="p">(</span><span class="nx">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">X</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span></code></pre></div><p>The above expression produces a boolean.  We can get the correct symbol from
this boolean (<code>#</code> when it&rsquo;s <code>true</code>, or <code>.</code> when it&rsquo;s <code>false</code>) by using
an if-expression:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">if</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">X</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&#39;#&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">
</span></span></span></code></pre></div><p>Since we have just reshaped our <code>Xs</code> into a two-dimensional array matching
our <code>Screen</code>, we can figure out the value of <code>X</code> simply by accessing that
array at a particular row and column:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">if</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">spritePos</span><span class="p">[</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&#39;#&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">
</span></span></span></code></pre></div><p>That last piece of code gives us the value of a particular pixel in the
CRT monitor. All that&rsquo;s left is to compute the value of <em>every</em> pixel in
the monitor. We can accomplish this using a parallel loop expression
(which we covered in <a href="../../posts/aoc2022-day06-packets/#parallel-loop-expressions">our day 6 article</a>).</p>
<div class="highlight" data-code-type="main" data-code-section="middle"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">const</span><span class="w"> </span><span class="nx">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">Screen</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">spritePos</span><span class="p">[</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&#34;#&#34;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&#34;.&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">pixels</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Since Chapel knows the <code>pixels</code> variable is in the shape of <code>Screen</code>, it knows
to print it line-by-line, and we get our desired output.</p>
<h3 id="summary">
  <a href="#summary">Summary</a>
</h3>
<p>That&rsquo;s it for both parts of today&rsquo;s solution! This time, we used <code>scan</code>
expressions to elegantly compute partial sums of an array (though they can
be used to compute any partial reduction). We also made use of <code>reshape</code>
to rearrange a one-dimensional array into a more desirable form &mdash; one that
matched up directly with our two-dimensional CRT screen.</p>
<p>Our solution is automatically parallel because of the <code>scan</code> and
the loop expression we used to define our <code>pixels</code> variable.
This once again highlights Chapel&rsquo;s power: we expressed our solution using
natural, high-level patterns, and the language took care of making them
parallel.</p>
<p>Thanks for reading! Please feel free
to ask any questions or post any comments you have in the new <a href="https://chapel.discourse.group/c/blog/21"target="_blank" rel="noopener">Blog
Category</a> of Chapel&rsquo;s
Discourse Page.</p>

</div>

        </main>
<div class="container">
    <div class="share-view">
        <h3>Share this article:</h3>
        <div class="share-buttons">
        
        
        
        <a style="--button-color: #6cb0f9; --button-color-light: white;" class="button share-button" href="https://bsky.app/intent/compose?text=Check&#43;out&#43;this&#43;post&#43;entitled&#43;%22Advent&#43;of&#43;Code&#43;2022%2C&#43;Day&#43;10%3A&#43;Scan&#43;Lines%22&#43;on&#43;the&#43;Chapel&#43;Programming&#43;Language&#43;blog%3A&#43;https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Faoc2022-day10-crt%2F" target="_blank" rel="noopener noreferrer">
    <img width="30" height="30" src="../../img/bluesky-logo.jpg" alt="Share on BlueSky">
</a>

        <a style="--button-color: #3a559f; --button-color-light: white;" class="button share-button" href="https://www.facebook.com/sharer/sharer.php?description=Check&#43;out&#43;this&#43;post&#43;entitled&#43;%22Advent&#43;of&#43;Code&#43;2022%2C&#43;Day&#43;10%3A&#43;Scan&#43;Lines%22&#43;on&#43;the&#43;Chapel&#43;Programming&#43;Language&#43;blog%3A&amp;u=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Faoc2022-day10-crt%2F" target="_blank" rel="noopener noreferrer">
    <img width="30" height="30" src="../../img/facebook-logo.png" alt="Share on Facebook">
</a>

        <a style="--button-color: #2867b2; --button-color-light: white;" class="button share-button" href="https://linkedin.com/share?text=Check&#43;out&#43;this&#43;post&#43;entitled&#43;%22Advent&#43;of&#43;Code&#43;2022%2C&#43;Day&#43;10%3A&#43;Scan&#43;Lines%22&#43;on&#43;the&#43;Chapel&#43;Programming&#43;Language&#43;blog%3A&amp;url=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Faoc2022-day10-crt%2F" target="_blank" rel="noopener noreferrer">
    <img width="30" height="30" src="../../img/linkedin-logo.png" alt="Share on LinkedIn">
</a>

        <a style="--button-color: #ff4500; --button-color-light: white;" class="button share-button" href="https://new.reddit.com/submit?title=Advent&#43;of&#43;Code&#43;2022%2C&#43;Day&#43;10%3A&#43;Scan&#43;Lines&amp;url=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Faoc2022-day10-crt%2F" target="_blank" rel="noopener noreferrer">
    <img width="30" height="30" src="../../img/reddit-logo.svg" alt="Share on Reddit">
</a>

        <a style="--button-color: #000000; --button-color-light: #7a7a7a;" class="button share-button" href="http://x.com/share?text=Check&#43;out&#43;this&#43;post&#43;entitled&#43;%22Advent&#43;of&#43;Code&#43;2022%2C&#43;Day&#43;10%3A&#43;Scan&#43;Lines%22&#43;on&#43;the&#43;Chapel&#43;Programming&#43;Language&#43;blog%3A&amp;url=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Faoc2022-day10-crt%2F" target="_blank" rel="noopener noreferrer">
    <img width="30" height="30" src="../../img/x-logo.svg" alt="Share on X">
</a>

        </div>
    </div>
</div>

    
    
    <nav class="container series-navigation">
        
        <div class="series-button-wrapper prev">
            <a class="button" href=../../posts/aoc2022-day09-elvish-string-theory/>
                <svg class="feather">
    <use xlink:href="../../feather-sprite.svg#chevrons-left"/>
</svg>

                <span>
                    Previous in series
                    <span class="series-button-name">
                        
 Day 9: Elvish String Theory


                    </span>
                </span>
            </a>
        </div>
        
        
        <div class="series-button-wrapper next">
            <a class="button" href=../../posts/aoc2022-day11-monkeys/>
                <span>
                    Next in series
                    <span class="series-button-name">
                        
 Day 11: Monkeying Around


                    </span>
                </span>
                <svg class="feather">
    <use xlink:href="../../feather-sprite.svg#chevrons-right"/>
</svg>

            </a>
        </div>
        
    </nav>


    </body>
</html>
